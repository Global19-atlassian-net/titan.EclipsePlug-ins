/******************************************************************************
 * Copyright (c) 2000-2020 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 *
 * Contributors:
 *   Botond Baranyi – initial implementation
 *   Jeno Balasko - rework for JSON
 *
 ******************************************************************************/

module JsonBasicTest_ucharstring {

type record Rec {
  integer num,
  universal charstring ustr
}

type component CT {}

external function f_enc_rec(in Rec x) return octetstring
  with { extension "prototype(convert) encode(JSON)" }
  
external function f_dec_rec(in octetstring x) return Rec
  with { extension "prototype(convert) decode(JSON)" }
  
external function f_enc_ustr(in universal charstring x) return octetstring
  with { extension "prototype(convert) encode(JSON)" }
  
external function f_dec_ustr(in octetstring x) return universal charstring
  with { extension "prototype(convert) decode(JSON)" }
  
const universal charstring c_ustr := "árvíztűrő tükörfúrógép"; // 31 UTF-8 characters
const octetstring c_enc_ustr := '22C3A17276C3AD7A74C5B172C5912074C3BC6BC3B67266C3BA72C3B367C3A97022'O  //raw:'C3A17276C3AD7A74C5B172C5912074C3BC6BC3B67266C3BA72C3B367C3A970'O;
  
testcase tc_JSON_ustr() runs on CT {
  var octetstring v_enc := f_enc_ustr(c_ustr);
  //cpp log: DEBUG ../src/JsonBasicTest_ucharstring.ttcn:39(testcase:tc_JSON_ustr) f_enc_ustr(): Encoding universal charstring: char(0, 0, 0, 225) & "rv" & char(0, 0, 0, 237) & "zt" & char(0, 0, 1, 113) & "r" & char(0, 0, 1, 81) & " t" & char(0, 0, 0, 252) & "k" & char(0, 0, 0, 246) & "rf" & char(0, 0, 0, 250) & "r" & char(0, 0, 0, 243) & "g" & char(0, 0, 0, 233) & "p"
  log("Expected: ", c_enc_ustr, oct2unichar(v_enc))
  if (v_enc != c_enc_ustr) {
    setverdict(fail, "Encoding failed. Expected: ", c_enc_ustr, ", got: ", v_enc);
  }
  //var:
  var universal charstring v_ustr := "árvíztűrő tükörfúrógép";
  var octetstring v_enc1 := f_enc_ustr(v_ustr);
  log("Expected: ", c_enc_ustr, oct2unichar(v_enc1))
  if (v_enc1 != c_enc_ustr) {
    setverdict(fail, "Encoding failed. Expected: ", c_enc_ustr, ", got: ", v_enc);
  }
  var universal charstring v_dec := f_dec_ustr(c_enc_ustr);
  if (v_dec != c_ustr) {
    setverdict(fail, "Decoding failed. Expected: ", c_ustr, ", got: ", v_dec);
  }
  setverdict(pass);
}

testcase tc_JSON_ustr_in_rec() runs on CT {
  var Rec v_rec := { 10, c_ustr };
  var octetstring v_enc_rec := '7B226E756D223A31302C2275737472223A22C3A17276C3AD7A74C5B172C5912074C3BC6BC3B67266C3BA72C3B367C3A970227D'O //{xxx}
  var octetstring v_enc := f_enc_rec(v_rec);
  if (v_enc != v_enc_rec) {
    setverdict(fail, "Encoding error. Expected: ", v_enc_rec, ", got: ", v_enc, oct2unichar(v_enc));
  }
  var Rec v_dec := f_dec_rec(v_enc_rec);
  var Rec v_dec_rec := { 10, c_ustr };
  if (v_dec != v_dec_rec) {
    setverdict(fail, "Decoding error. Expected: ", v_dec_rec, ", got: ", v_dec);
  }
  setverdict(pass);
}

//TODO: Check Higher plane codepoints !

control {
  execute(tc_JSON_ustr());
  execute(tc_JSON_ustr_in_rec());
}

}
with {
  encode "JSON"
}
