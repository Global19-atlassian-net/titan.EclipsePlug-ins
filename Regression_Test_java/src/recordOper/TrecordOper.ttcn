/******************************************************************************
 * Copyright (c) 2000-2021 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 *
 * Contributors:
 *   Balasko, Jeno
 *   Baranyi, Botond
 *   Beres, Szabolcs
 *   Kovacs, Ferenc
 *   Raduly, Csaba
 *   Szabados, Kristof
 *   Szabo, Janos Zoltan â€“ initial implementation
 *
 ******************************************************************************/
module TrecordOper {
// ********** Type definitions  *********************
type component Mycomp {};
type enumerated Myenum {xx1,xx2,xx3};
type record recordOper_empty {};
type record MyRec0 {
	integer x1 optional,
	float x2 };
type record of octetstring recordOper_trecof;
type set recordOper_tset {
	integer x1,
	float x2 optional };
type set of charstring recordOper_tsetof;
type union MyUnion {
	integer x1,
	float x2 };
type record Myrec1 {	// record from basic types
	integer x1,
	float x2,
	Myenum x3 };
type record Myrec2 {	// record from basic types, with optional field
	integer x1,
	float x2,
	Myenum x3,
	integer x4 optional };
type record Myrec3 {	 // record from record, with optional field
	MyRec0 x1,
	MyRec0 x2 optional
	};
type record Myrec4 {	 // record from record of, with optional field
	recordOper_trecof x1,
	recordOper_trecof x2 optional
	};
type record Myrec5 {	 // record from set, with optional field
	recordOper_tset x1,
	recordOper_tset x2 optional
	};
type record Myrec6 {	 // record from set of, with optional field
	recordOper_tsetof x1,
	recordOper_tsetof x2 optional
	};
type record Myrec7 {	 // record from union, with optional field
	MyUnion x1,
	MyUnion x2 optional
	};
type record typedefrecordComp_myrec { // testing complex content
	MyRec0 x1,
	recordOper_trecof x2,
	recordOper_tset x3,
	recordOper_tsetof x4 optional,
	MyUnion x5,
	integer x6[3]
};
type record Myrec8{
	integer f1 optional,
	charstring f2 optional
	};
type record Myrec9 { // test for the assignment of optional fields
  integer f1 optional,
  integer f2 optional
};
// *************** Constanst ***********************
const MyRec0 recordOper_temp1:={ x1:=omit, x2:=3.4 };
const recordOper_trecof recordOper_temp2:={ 'AF12'O };
const recordOper_tset recordOper_temp3:={ x1:=234, x2:=1.9};
const recordOper_tsetof recordOper_temp4:={"f","8"};
const MyUnion recordOper_temp5:={ x2:=1.3 };
const Myrec1 recordOper_const1:={	//record with basic types
x1:=1,
x2:=1.2,
x3:=xx2 };
const Myrec2 recordOper_const2:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=2 };
const Myrec2 recordOper_const3:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
const Myrec3 recordOper_const4:={   //record from record
 x1:={ x1:=1, x2:=1.2 },
 x2:=recordOper_temp1
};
const Myrec3 recordOper_const5:={   //record from record, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
const Myrec4 recordOper_const6:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=recordOper_temp2
};
const Myrec4 recordOper_const7:={   //record from record of, with omited field
 x1:={ '12AB'O, 'CD12'O },
 x2:=omit
};
const Myrec5 recordOper_const8:={   //record from set
 x1:={ x1:=2, x2:=1.3},
 x2:=recordOper_temp3
};
const Myrec5 recordOper_const9:={   //record from set, with omited field
 x1:={ x1:=2, x2:=1.3},
 x2:=omit
};
const Myrec6 recordOper_const10:={   //record from set of
 x1:={"a","b"},
 x2:=recordOper_temp4  //{"f","8"},
};
const Myrec6 recordOper_const11:={   //record from set of, with omited field
 x1:={"a","b"},
 x2:=omit
};
const Myrec7 recordOper_const12:={   //record from union
 x1:={ x1 :=3 },
 x2:=recordOper_temp5  //{ x2:=1.3 }
};
const Myrec7 recordOper_const13:={   //record from union, with omited field
 x1:={ x1 :=3 },
 x2:=omit
};
const typedefrecordComp_myrec recordOper_const14 := {  // complex record
  x1 := { x1:=omit, x2:=3.4 },
  x2 := { 'AF12'O },
  x3 := { x1:=234, x2:=1.9},
  x4 := {"f","8"},
  x5 := { x2:=1.3 },
  x6 := {1,2,3}
}

testcase tc_recordAssign() runs on Mycomp{
var Myrec1 x1:={	//record with basic types
x1:=1,
x2:=1.2,
x3:=xx2 };
var Myrec1 x2;
  x2:={ x1:=1, x2:=1.2, x3:=xx2 };
var Myrec1 x3 := {};
if (x1.x1==1) {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1==1) {setverdict(pass);}	//later
     else {setverdict(fail);}
if (x2.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
}

// test some incomplete assignment cases.
testcase tc_recordAssignIncomplete() runs on Mycomp{
var Myrec1 x1:={ x1:=1, x2:=1.2};
  if(x1.x1==1) {setverdict(pass);}
  else {setverdict(fail);}
  if(x1.x2==1.2) {setverdict(pass);}
  else {setverdict(fail);}
  if(not(isbound(x1.x3))) {setverdict(pass);}
  else {setverdict(fail);}

x1 := {2, -, -};
  if(x1.x1==2) {setverdict(pass);}
  else {setverdict(fail);}
  if(x1.x2==1.2) {setverdict(pass);}
  else {setverdict(fail);}
  if(not(isbound(x1.x3))) {setverdict(pass);}
  else {setverdict(fail);}

x1:= { x1 := -, x2:=2.2, x3 := -};
  if(x1.x1==2) {setverdict(pass);}
  else {setverdict(fail);}
  if(x1.x2==2.2) {setverdict(pass);}
  else {setverdict(fail);}
  if(not(isbound(x1.x3))) {setverdict(pass);}
  else {setverdict(fail);}

x1:= { x2:=3.2};
  if(x1.x1==2) {setverdict(pass);}
  else {setverdict(fail);}
  if(x1.x2==3.2) {setverdict(pass);}
  else {setverdict(fail);}
  if(not(isbound(x1.x3))) {setverdict(pass);}
  else {setverdict(fail);}
}

testcase tc_recordAssignOpt() runs on Mycomp{
var integer inttemp:=2;
var Myrec2 x1:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=inttemp};  //2
var Myrec2 x2:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
var Myrec2 x3, x4;
x3:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=inttemp };   //2
x4:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
//at declaration, with optional field
if (x1.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x4==2) {setverdict(pass);}
     else {setverdict(fail);}
//at declaration, with omited field
if (x2.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x4))) {setverdict(pass);}
     else {setverdict(fail);}
//later, with optional field
if (x3.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x4==2) {setverdict(pass);}
     else {setverdict(fail);}
//later, with optional field
if (x4.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x4))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignRec() runs on Mycomp{
var MyRec0 temp1:={ x1:=omit, x2:=3.4 };
var Myrec3 x1:={   //record from record
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
var Myrec3 x2:={   //record from record, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
var Myrec3 x3,x4;
x3:={   //record from record
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x4:={   //record from record, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
if (x1.x1.x1==1) {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (x1.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1.x1==1) {setverdict(pass);}	//at declaration, omit
     else {setverdict(fail);}
if (x2.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x1.x1==1) {setverdict(pass);}	//later
     else {setverdict(fail);}
if (x3.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x1.x1==1) {setverdict(pass);}	//later, omit
     else {setverdict(fail);}
if (x4.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignRecof() runs on Mycomp{
var recordOper_trecof temp2:={'AF12'O};
var Myrec4 x1:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=temp2
};
var Myrec4 x2:={   //record from record of, with omited field
 x1:={ '12AB'O, 'CD12'O },
 x2:=omit
};
var Myrec4 x3,x4
x3:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=temp2
};
x4:={   //record from record of, with omited field
 x1:={ '12AB'O, 'CD12'O },
 x2:=omit
};
if (x1.x1[0]=='12AB'O) {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (x1.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1[0]=='12AB'O) {setverdict(pass);}	//at declaration, omit
     else {setverdict(fail);}
if (x2.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x1[0]=='12AB'O) {setverdict(pass);}	//later
     else {setverdict(fail);}
if (x3.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x1[0]=='12AB'O) {setverdict(pass);}	//later, omit
     else {setverdict(fail);}
if (x4.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignSet() runs on Mycomp{
var recordOper_tset temp1:={ x1:=2, x2:=omit };
var Myrec5 x1:={   //record from set
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
var Myrec5 x2:={   //record from set, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
var Myrec5 x3,x4;
x3:={   //record from set
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x4:={   //record from set, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
if (x1.x1.x1==1) {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (x1.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1.x1==1) {setverdict(pass);}	//at declaration, omit
     else {setverdict(fail);}
if (x2.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x1.x1==1) {setverdict(pass);}	//later
     else {setverdict(fail);}
if (x3.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x1.x1==1) {setverdict(pass);}	//later, omit
     else {setverdict(fail);}
if (x4.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignSetof() runs on Mycomp{
var recordOper_tsetof temp2:={"a","7"};
var Myrec6 x1:={   //record from set of
 x1:={ "1", "a" },
 x2:=temp2
};
var Myrec6 x2:={   //record from set of, with omited field
 x1:={ "1", "a" },
 x2:=omit
};
var Myrec6 x3,x4
x3:={   //record from set of
 x1:={ "1", "a" },
 x2:=temp2
};
x4:={   //record from set of, with omited field
 x1:={ "1","a" },
 x2:=omit
};
if (x1.x1[0]=="1") {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (x1.x1[1]=="a") {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1[0]=="1") {setverdict(pass);}	//at declaration, omit
     else {setverdict(fail);}
if (x2.x1[1]=="a") {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x1[0]=="1") {setverdict(pass);}	//later
     else {setverdict(fail);}
if (x3.x1[1]=="a") {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x1[0]=="1") {setverdict(pass);}	//later, omit
     else {setverdict(fail);}
if (x4.x1[1]=="a") {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignUnion() runs on Mycomp{
var MyUnion temp5 := {x2:=1.3}
var Myrec7 x1:={   //record from union
 x1:={ x1 :=3 },
 x2:=temp5  //{ x2:=1.3 }
};
var Myrec7 x2:={   //record from union, with omited field
 x1:={ x1 :=3 },
 x2:=omit
};
var Myrec7 x3,x4;
x3:={   //record from union
 x1:={ x1 :=3 },
 x2:=temp5  //{ x2:=1.3 }
};
x4:={   //record from union, with omited field
 x1:={ x1 :=3 },
 x2:=omit
};
if (x1.x1.x1==3) {setverdict(pass);}	//at declaration
     else {setverdict(fail);}
if (ischosen(x1.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(x1.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp5) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x1.x1==3) {setverdict(pass);}	//at declaration, omit
     else {setverdict(fail);}
if (ischosen(x2.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(x2.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x2.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x1.x1==3) {setverdict(pass);}	//later
     else {setverdict(fail);}
if (ischosen(x3.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(x3.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==temp5) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x1.x1==3) {setverdict(pass);}	//later, omit
     else {setverdict(fail);}
if (ischosen(x4.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(x4.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignElem() runs on Mycomp{
var Myrec1 x1:={	//record with basic types
x1:=1,
x2:=1.2,
x3:=xx2 };
x1.x2:=3.4;
if (x1.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==3.4) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
}


testcase tc_recordAssignElemOpt() runs on Mycomp{
var integer inttemp:=2;
var Myrec2 x1:={	//record with basic types
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit } ;  //2
var Myrec2 x2, x3, x4;
x2:=x1;
x3:={x1:=1, x2:=1.2, x3:=xx2, x4:=inttemp };
x4:=x2;
x1.x1:=2;			//not optional field
x2.x4:=3;			//optional field; omited-> value
x3.x4:=3;			//optional field; value-> value
x4.x4:=omit;			//optional field; value -> omited
//change not optional field
if (x1.x1==2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x1.x4))) {setverdict(pass);}
     else {setverdict(fail);}
//omited -> value
if (x2.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (x2.x4==3) {setverdict(pass);}
     else {setverdict(fail);}
//optional field; value-> value
if (x3.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (x3.x4==3) {setverdict(pass);}
     else {setverdict(fail);}
//optional field; value -> omited
if (x4.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x4.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(x4.x4))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignElemRec() runs on Mycomp{
var MyRec0 temp1:={ x1:=omit, x2:=3.4 };
var Myrec3 x1;
x1:={   //record from record
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x1.x1.x1:=2;
//temp1.x1:=3;
//x1.x2:=temp1;
if (x1.x1.x1==2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
}


testcase tc_recordAssignElemRecof() runs on Mycomp{
var recordOper_trecof temp2:={'AF12'O};
var Myrec4 x1:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=temp2
};
x1.x1[1]:='34AB'O;
if (x1.x1[0]=='12AB'O) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x1[1]=='34AB'O) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignElemSet() runs on Mycomp{
var recordOper_tset temp1:={ x1:=2, x2:=omit };
var Myrec5 x1:={   //record from set
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x1.x1.x2:=3.4;
if (x1.x1.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x1.x2==3.4) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp1) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignElemSetof() runs on Mycomp{
var recordOper_tsetof temp2:={"a","7"};
var Myrec6 x1:={   //record from set of
 x1:={ "1", "a" },
 x2:=temp2
};
x1.x1[0]:="h";
if (x1.x1[0]=="h") {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x1[1]=="a") {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp2) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordAssignElemUnion() runs on Mycomp{
var MyUnion temp5 := {x2:=1.3}
var Myrec7 x1:={   //record from union
 x1:={ x1 :=3 },
 x2:=temp5  //{ x2:=1.3 }
};
x1.x1.x2:=3.4;
if (x1.x1.x2==3.4) {setverdict(pass);}
     else {setverdict(fail);}
if (ischosen(x1.x1.x2)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(x1.x1.x1))) {setverdict(pass);}
     else {setverdict(fail);}
if (x1.x2==temp5) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordSizeof() runs on Mycomp{
var integer inttemp:=2;
var Myrec2 x1:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=inttemp};  //2
var Myrec2 x2:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
var Myrec2 x3, x4;
x3:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=inttemp };   //2
x4:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
var Myrec4 x5;
x5.x1 := { '12AB'O, '12AB'O};
x5.x2 := { '12AB'O, '12AB'O, '12AB'O};
if (sizeof(x1)==4) {setverdict(pass);} //at declaration, with optional field
     else {setverdict(fail);}
if (sizeof(x2)==3) {setverdict(pass);}	//at declaration, with omited field
     else {setverdict(fail);}
if (sizeof(x3)==4) {setverdict(pass);}	//later, with optional field
     else {setverdict(fail);}
if (sizeof(x4)==3) {setverdict(pass);}	//testcase, with optional field
     else {setverdict(fail);}
if (sizeof(x5.x1)==2 and sizeof(x5.x2) == 3) {setverdict(pass);}	//testcase, with optional field
     else {setverdict(fail);}
}

testcase tc_recordConst() runs on Mycomp{
const Myrec1 const1:={	//record with basic types
x1:=1,
x2:=1.2,
x3:=xx2 };
if (recordOper_const1.x1==1) {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (recordOper_const1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (const1.x1==1) {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (const1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (const1.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstOpt() runs on Mycomp{
const Myrec2 const2:={	//record with basic types, with optional field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=2 };
const Myrec2 const3:={	//record with basic types, with omited field
x1:=1,
x2:=1.2,
x3:=xx2,
x4:=omit };
//definition part, with optional field
if (recordOper_const2.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const2.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const2.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const2.x4==2) {setverdict(pass);}
     else {setverdict(fail);}
//definition part, with omited field
if (recordOper_const3.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const3.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const3.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const3.x4))) {setverdict(pass);}
     else {setverdict(fail);}
//testcase, with optional field
if (const2.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (const2.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (const2.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (const2.x4==2) {setverdict(pass);}
     else {setverdict(fail);}
//testcase, with omited field
if (const3.x1==1) {setverdict(pass);}
     else {setverdict(fail);}
if (const3.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (const3.x3==xx2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const3.x4))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstRec() runs on Mycomp{
const Myrec3 const4:={   //record from record
 x1:={ x1:=1, x2:=1.2 },
 x2:=recordOper_temp1
};
const Myrec3 const5:={   //record from record, with omited field
 x1:={ x1:=1, x2:=1.2 },
 x2:=omit
};
if (recordOper_const4.x1.x1==1) {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (recordOper_const4.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const4.x2==recordOper_temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const5.x1.x1==1) {setverdict(pass);}	//definition part, omit
     else {setverdict(fail);}
if (recordOper_const5.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const5.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const4.x1.x1==1) {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (const4.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (const4.x2==recordOper_temp1) {setverdict(pass);}
     else {setverdict(fail);}
if (const5.x1.x1==1) {setverdict(pass);}	//testcase, omit
     else {setverdict(fail);}
if (const5.x1.x2==1.2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const5.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstRecof() runs on Mycomp{
const Myrec4 const6:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=recordOper_temp2
};
const Myrec4 const7:={   //record from record of, with omited field
 x1:={ '12AB'O, 'CD12'O },
 x2:=omit
};
if (recordOper_const6.x1[0]=='12AB'O) {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (recordOper_const6.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const6.x2==recordOper_temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const7.x1[0]=='12AB'O) {setverdict(pass);}	//definition part, omit
     else {setverdict(fail);}
if (recordOper_const7.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const7.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const6.x1[0]=='12AB'O) {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (const6.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (const6.x2==recordOper_temp2) {setverdict(pass);}
     else {setverdict(fail);}
if (const7.x1[0]=='12AB'O) {setverdict(pass);}	//testcase, omit
     else {setverdict(fail);}
if (const7.x1[1]=='CD12'O) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const7.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstSet() runs on Mycomp{
const Myrec5 const8:={   //record from set
 x1:={ x1:=2, x2:=1.3},
 x2:=recordOper_temp3
};
const Myrec5 const9:={   //record from set, with omited field
 x1:={ x1:=2, x2:=omit},
 x2:=omit
};
if (recordOper_const8.x1.x1==2) {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (recordOper_const8.x1.x2==1.3) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const8.x2==recordOper_temp3) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const9.x1.x1==2) {setverdict(pass);}	//definition part, omit
     else {setverdict(fail);}
if (recordOper_const9.x1.x2==1.3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const9.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const8.x1.x1==2) {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (const8.x1.x2==1.3) {setverdict(pass);}
     else {setverdict(fail);}
if (const8.x2==recordOper_temp3) {setverdict(pass);}
     else {setverdict(fail);}
if (const9.x1.x1==2) {setverdict(pass);}	//testcase, omit
     else {setverdict(fail);}
if (not(ispresent(const9.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const9.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstSetof() runs on Mycomp{
const Myrec6 const10:={   //record from set of
 x1:={"a","b"},
 x2:=recordOper_temp4  //{"f","8"},
};
const Myrec6 const11:={   //record from set of, with omited field
 x1:={"a","b"},
 x2:=omit
};
if (recordOper_const10.x1[0]=="a") {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (recordOper_const10.x1[1]=="b") {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const10.x2==recordOper_temp4) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const11.x1[0]=="a") {setverdict(pass);}	//definition part, omit
     else {setverdict(fail);}
if (recordOper_const11.x1[1]=="b") {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const11.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const10.x1[0]=="a") {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (const10.x1[1]=="b") {setverdict(pass);}
     else {setverdict(fail);}
if (const10.x2==recordOper_temp4) {setverdict(pass);}
     else {setverdict(fail);}
if (const11.x1[0]=="a") {setverdict(pass);}	//testcase, omit
     else {setverdict(fail);}
if (const11.x1[1]=="b") {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const11.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordConstUnion() runs on Mycomp{
const Myrec7 const12:={   //record from union
 x1:={ x1 :=3 },
 x2:=recordOper_temp5  //{ x2:=1.3 }
};
const Myrec7 const13:={   //record from union, with omited field
 x1:={ x1 :=3 },
 x2:=omit
};
if (recordOper_const12.x1.x1==3) {setverdict(pass);}	//definition part
     else {setverdict(fail);}
if (ischosen(recordOper_const12.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(recordOper_const12.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const12.x2==recordOper_temp5) {setverdict(pass);}
     else {setverdict(fail);}
if (recordOper_const13.x1.x1==3) {setverdict(pass);}	//definition part, omit
     else {setverdict(fail);}
if (ischosen(recordOper_const13.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(recordOper_const13.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(recordOper_const13.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const12.x1.x1==3) {setverdict(pass);}	//testcase
     else {setverdict(fail);}
if (ischosen(const12.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(const12.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (const12.x2==recordOper_temp5) {setverdict(pass);}
     else {setverdict(fail);}
if (const13.x1.x1==3) {setverdict(pass);}	//testcase, omit
     else {setverdict(fail);}
if (ischosen(const13.x1.x1)) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ischosen(const13.x1.x2))) {setverdict(pass);}
     else {setverdict(fail);}
if (not(ispresent(const13.x2))) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordComp() runs on Mycomp{
var Myrec1 x1,x2,x3; // record with basic types
x1:={ x1:=1, x2:=1.2, x3:=xx2 };
x2:={ x1:=1, x2:=1.2, x3:=xx2 };
x3:={ x1:=1, x2:=1.24, x3:=xx2 }
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x1!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}


testcase tc_recordCompOpt() runs on Mycomp{
var integer inttemp:=2;		// record with basic types and optional field
var Myrec2 x1,x2,x3;
x1 :={	x1:=1, x2:=1.2, x3:=xx2, x4:=inttemp };  //inntemp=2
x2:= { x1:=1, x2:=1.2, x3:=xx2, x4:=omit };
x3:= { x1:=1, x2:=1.2, x3:=xx2, x4:=omit };
if (x2==x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1==x2)) {setverdict(pass);}
     else {setverdict(fail);}
if (x1!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x2!=x3)) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordCompOptField() runs on Mycomp
{
  const MyRec0 c1 := { x1 := omit, x2 := 0.0 };
  const MyRec0 c2 := { x1 := 1, x2 := 0.0 };
  const integer ci := 1;
  var MyRec0 v := { x1 := omit };
  var integer i := 1;
  if (c1.x1 == omit and c1.x1 != 1 and /*c1.x1 != i and*/ c1.x1 != ci and c1.x1 == c1.x1 and
      omit == c1.x1 and 1 != c1.x1 and /*i != c1.x1 and*/ ci != c1.x1 and not c1.x1 != c1.x1)
    { setverdict(pass); }
  else { setverdict(fail); }
  if (c2.x1 != omit and c2.x1 == 1 and c2.x1 == i and c2.x1 == ci and c2.x1 == c2.x1 and
      omit != c2.x1 and 1 == c2.x1 and i == c2.x1 and ci == c2.x1 and not c2.x1 != c2.x1)
    { setverdict(pass); }
  else { setverdict(fail); }
  if (v.x1 == omit and v.x1 != 1 and v.x1 != i and v.x1 == v.x1 and
      omit == v.x1 and 1 != v.x1 and i != v.x1 and not v.x1 != v.x1)
    { setverdict(pass); }
  else { setverdict(fail); }
  v.x1 := 1;
  if (v.x1 != omit and v.x1 == 1 and v.x1 == i and v.x1 == v.x1 and
      omit != v.x1 and 1 == v.x1 and i == v.x1 and not v.x1 != v.x1)
    { setverdict(pass); }
  else { setverdict(fail); }
}

testcase tc_recordCompRec() runs on Mycomp{
var MyRec0 temp1:={ x1:=omit, x2:=3.4 };  // record with record
var Myrec3 x1,x2,x3;
x1 :={
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x2 :={
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x3 :={
 x1:={ x1:=2, x2:=1.2 },
 x2:=temp1
};
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x1!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}


testcase tc_recordCompRecof() runs on Mycomp{
var recordOper_trecof temp2:={'AF12'O};
var Myrec4 x1,x2,x3;
x1:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=temp2
};
x2:={   //record from record of
 x1:={ '12AB'O, 'CD12'O },
 x2:=temp2
};
x3:={   //record from record of
 x1:={ '12AB'O },
 x2:=temp2
};
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x2!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordCompSet() runs on Mycomp{
var recordOper_tset temp1:={ x1:=2, x2:=omit };
var Myrec5 x1,x2,x3; //record from set
x1:={
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x2:={
 x1:={ x1:=1, x2:=1.2 },
 x2:=temp1
};
x3:={
 x1:={ x1:=4, x2:=1.2 },
 x2:=temp1
};
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x2==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x1!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordCompSetof() runs on Mycomp{
var recordOper_tsetof temp2:={"a","7"};
var Myrec6 x1,x2,x3;  //record from set of
x1:={
 x1:={ "1", "a" },
 x2:=temp2
};
x2:={
 x1:={ "1", "a" },
 x2:=temp2
};
x3:={
 x1:={ "1", "a", "k" },
 x2:=temp2
};
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x2==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x1!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}

testcase tc_recordCompUnion() runs on Mycomp{
var MyUnion temp5 := {x2:=1.3};	//record from union
var Myrec7 x1,x2,x3;
x1:={
 x1:={ x1 :=3 },
 x2:=temp5  //{ x2:=1.3 }
};
x2:={
 x1:={ x1 :=3 },
 x2:=temp5  //{ x2:=1.3 }
};
x3:={
 x1:={ x2 :=3.9 },
 x2:=temp5  //{ x2:=1.3 }
};
if (x1==x2) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1==x3)) {setverdict(pass);}
     else {setverdict(fail);}
if (x2!=x3) {setverdict(pass);}
     else {setverdict(fail);}
if (not(x1!=x2)) {setverdict(pass);}
     else {setverdict(fail);}
}

// Example from CR 5262.  No need to list all fields explicitly in the further
// restricted type: `type myrecr1 myrecr2 ({ "", "" }, { "", "" })'.
type record Myrec10 {
  integer f1 (0..255),
  charstring f2,
  charstring f3 optional
}
type Myrec10 Myrec11 ({1, "", ""}, {2, "", ""}, {f1 := 3, f2 := "", f3 := omit})
type record MyRecordTypeWithSubtypedFields {
  integer field1 (1..100),
  charstring field2 length(2..255)
}
type Myrec10 Myrec13 (Myrec11, {1, "", ""})

const Myrec11 c_myrec1 := {1, "", ""}

template Myrec11 t_myrec1 := c_myrec1

function f_rec1() return MyRecordTypeWithSubtypedFields {
  return { 2, "aaa" }
}

testcase tc_recordSubtypes() runs on Mycomp {
  var template MyRecordTypeWithSubtypedFields vt_myrec1 := {100, "hello"}
  var MyRecordTypeWithSubtypedFields v_myrec1 := {field1 := 100, field2 := "hello"}
  var Myrec11 v_myrec2 := valueof(modifies t_myrec1 := {f1 := 2})
  if (match(valueof(v_myrec1), vt_myrec1)) { setverdict(pass) }
  else { setverdict(fail) }
  if ({ 2, "aaa" } == f_rec1() and f_rec1() == { 2, "aaa" }) { setverdict(pass) }
  else { setverdict(fail) }
  // FATAL_ERROR() with R8B: `if (valueof(MyRecordTypeWithSubtypedFields:{ 1, "hello" }) == valueof(v_myrec1)) { setverdict(pass) }'.
}

testcase  tc_recordIsvalue() runs on Mycomp{
  var recordOper_empty v1;
  var MyRec0 vs2_def;
  var MyRec0 v2;
  v2.x1 := 42;

  if ( isvalue(v1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vs2_def) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v2) ) { setverdict(fail); } else { setverdict(pass); };

  var MyRec0 vs2_part := { -, 1.0 };
  if ( isvalue(vs2_part) ) { setverdict(fail); } else { setverdict(pass); };
  vs2_part.x1 := omit;
  if ( isvalue(vs2_part) ) { setverdict(pass); } else { setverdict(fail); };

  var MyRec0 vs2_om := { omit, - };
  if ( isvalue(vs2_om) ) { setverdict(fail); } else { setverdict(pass); };
  vs2_om.x2 := 33.0;
  if ( isvalue(vs2_om) ) { setverdict(pass); } else { setverdict(fail); };
}

testcase tc_recordIsbound() runs on Mycomp{
  var recordOper_empty v1;
  var MyRec0 vs2_def;
  var MyRec0 v2;
  v2.x1 := 42;

  if ( isbound(v1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isbound(vs2_def) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isbound(vs2_def.x1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isbound(vs2_def.x2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isbound(v2) ) { setverdict(pass); } else { setverdict(fail); };

  var MyRec0 vs2_part := { -, 1.0 };
  if ( isbound(vs2_part) ) { setverdict(pass); } else { setverdict(fail); };
  vs2_part.x1 := omit;
  if ( isbound(vs2_part) ) { setverdict(pass); } else { setverdict(fail); };

  var MyRec0 vs2_om := { omit, - };
  if ( isbound(vs2_om) ) { setverdict(pass); } else { setverdict(fail); };
  vs2_om.x2 := 33.0;
  if ( isbound(vs2_om) ) { setverdict(pass); } else { setverdict(fail); };
}

type set AllRec {
  Myrec8 r1,
  Myrec8 r2 optional
}
template Myrec8 t_MyRec := { f1 := *, f2 := * };
const Myrec8 c1_MyRec := { f1 := 5, f2 := omit };
const Myrec8 c2_MyRec := { f1 := omit, f2 := "omit" };
const AllRec c_AllRec := { r1 := c1_MyRec, r2 := c2_MyRec }
// This function is called from testcase recordIsvalue2
function f_isvalue_record(in Myrec8 p1_MyRec, in Myrec8 p2_MyRec, in AllRec p_AllRec, in template Myrec8 pt_MyRec) runs on Mycomp
{
  var Myrec8 v1_MyRec;
  var Myrec8 v2_MyRec;
  var template Myrec8 vt_MyRec;
  var AllRec v_AllRec;
  template integer ti := 5 ifpresent;
  template Myrec8 rrr1 := { 11, "true" }
  template Myrec8 rrr2 := { 11, "true" } ifpresent;
  template Myrec8 rrr3 := { 11, "true" ifpresent}

  if ( isvalue(v1_MyRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v_AllRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v_AllRec.r1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v_AllRec.r2) ) { setverdict(fail); } else { setverdict(pass); };

  v1_MyRec := c1_MyRec;
  v_AllRec := { r1 := c1_MyRec, r2 := c2_MyRec };

  if ( isvalue(v1_MyRec) ) {setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(v_AllRec.r1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c1_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c_AllRec.r1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p1_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p_AllRec.r1) ) { setverdict(pass); } else { setverdict(fail); };

  if ( isvalue(v1_MyRec .f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(v_AllRec.r1.f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c1_MyRec .f1) ) { setverdict(pass); } else {  setverdict(fail); };
  if ( isvalue(c_AllRec.r1.f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p1_MyRec .f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p_AllRec.r1.f1) ) { setverdict(pass); } else { setverdict(fail); };

  if ( isvalue(v1_MyRec .f2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v_AllRec.r1.f2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(c1_MyRec .f2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(c_AllRec.r1.f2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(p1_MyRec .f2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(p_AllRec.r1.f2) ) { setverdict(fail); } else { setverdict(pass); };

  v2_MyRec := c2_MyRec; //{ f1 := omit, f2 := "omit" };

  if ( isvalue(v2_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(v_AllRec.r2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c2_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c_AllRec.r2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p2_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p_AllRec.r2) ) { setverdict(pass); } else { setverdict(fail); };

  if ( isvalue(v2_MyRec .f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v_AllRec.r2.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(p2_MyRec .f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(p_AllRec.r2.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(c2_MyRec .f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(c_AllRec.r2.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v2_MyRec .f2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(v_AllRec.r2.f2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p2_MyRec .f2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(p_AllRec.r2.f2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c2_MyRec .f2) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(c_AllRec.r2.f2) ) { setverdict(pass); } else { setverdict(fail); };

  v1_MyRec := { f1 := omit, f2 := omit };

  if ( isvalue(v1_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(v1_MyRec.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(v1_MyRec.f2) ) { setverdict(fail); } else { setverdict(pass); };
  // can't modify c1_MyRec or p1_MyRec

/************** templates ***************/

  vt_MyRec := { f1 := 5, f2 := omit };

  if ( isvalue(vt_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(vt_MyRec.f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(vt_MyRec.f2) ) { setverdict(fail); } else { setverdict(pass); };

  vt_MyRec := { f1 := omit, f2 := "five" };

  if ( isvalue(vt_MyRec) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(vt_MyRec.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f2) ) { setverdict(pass); } else { setverdict(fail); };

  vt_MyRec := { f1 := ?, f2 := "5" };

  if ( isvalue(vt_MyRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f2) ) { setverdict(pass); } else { setverdict(fail); };

  vt_MyRec := { f1 := 5, f2 := * };

  if ( isvalue(vt_MyRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(vt_MyRec.f2) ) { setverdict(fail); } else { setverdict(pass); };

  vt_MyRec := { f1 := ?, f2 := * };

  if ( isvalue(vt_MyRec) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(vt_MyRec.f2) ) { setverdict(fail); } else { setverdict(pass); };

  if ( isvalue(pt_MyRec) ) { setverdict(pass); } else { setverdict(fail); }; // the fields are omit, but the record is bound
  if ( isvalue(pt_MyRec.f1) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(pt_MyRec.f2) ) { setverdict(fail); } else { setverdict(pass); };

  //so here it is expanded instead
  if ( isvalue(modifies vt_MyRec := { f1:=1, f2:="2" }) ) { setverdict(pass); } else {setverdict(fail, modifies vt_MyRec := { f1:=1, f2:="2" }, " should be bound"); };

  if ( isvalue(t_MyRec) ) { setverdict(fail); } else { setverdict(pass); };

  //testing ifpresent
  if ( isvalue(ti) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(rrr1) ) { setverdict(pass); } else { setverdict(fail); };
  if ( isvalue(rrr2) ) { setverdict(fail); } else { setverdict(pass); };
  if ( isvalue(rrr3) ) { setverdict(fail); } else { setverdict(pass); };
}

testcase tc_recordIsvalue2() runs on Mycomp
{
  var Myrec8 x1_MyRec := { f1 := 5, f2 := omit };
  var Myrec8 x2_MyRec := { f1 := omit, f2 := "omit" };
  var template Myrec8 xt_MyRec := { f1 := omit, f2 := omit };
  var AllRec x_AllRec := { r1 := x1_MyRec, r2 := x2_MyRec }
  f_isvalue_record(x1_MyRec, x2_MyRec, x_AllRec, xt_MyRec) ;
}

    type record of integer IntegerList
    type record Ctx{
      IntegerList appData
    }

testcase tc_CR_TR00016681() runs on Mycomp
{
  var Ctx vu;
  // appData field: Unbound record of
  // isvalue:false, isbound:false
  if (isvalue(vu.appData)) { setverdict(fail); } else { setverdict(pass); }
  if (isbound(vu.appData)) { setverdict(fail); } else { setverdict(pass); }
  //lengthof(v1.appData) -> Dynamic Testcase Error

  // The enclosing record: isbound === isvalue
  if (isvalue(vu)) { setverdict (fail); } else { setverdict(pass); }
  if (isbound(vu)) { setverdict (fail); } else { setverdict(pass); }

  var Ctx v0 := {{}}
  // appData field: 0-length record of
  // isvalue: true, isbound:true
  if (not isvalue(v0.appData)) { setverdict (fail); }
  if (isbound(v0.appData)) { setverdict (pass); }
  else { setverdict(fail); }

  // The enclosing record: isbound === isvalue
  if (isvalue(v0)) { setverdict (pass); } else { setverdict(fail); }
  if (isbound(v0)) { setverdict (pass); } else { setverdict(fail); }

  if (lengthof(v0.appData) == 0) { setverdict(pass); }
  else { setverdict(fail); }

  // appData field: 3-length with gaps
  // isvalue: false, isbound:true
  var Ctx v3 := { appData := { 1, -, 2 } }
  if (isvalue(v3.appData)) { setverdict (fail); }
  if (isbound(v3.appData)) { setverdict (pass); }
  else { setverdict(fail); }

  if (lengthof(v3.appData) == 3) { setverdict(pass); }
  else { setverdict(fail); }

  var integer i;
  if (isbound(i)) { setverdict (fail); } else { setverdict(pass); }
  if (isvalue(i)) { setverdict (fail); } else { setverdict(pass); }
  i := 42;
  if (isvalue(i)) { setverdict (pass); } else { setverdict(fail); }
  if (isbound(i)) { setverdict (pass); } else { setverdict(fail); }
}

const Myrec12 c_myrec2_part:={ 
  roc:={},
  roi:={10,9,8},
  u:={ r:={ /*i:=1,*/ x:=1.0, c:="one"}},
  r:={ i:=1, x:=1.0, c:="one"}
}  

const Myrec12 c_myrec2_1:={ 
  roc:=omit,
  roi:={},
  u:={r:={ i:=1, x:=1.0, c:="one"}},
  r:={ i:=1, x:=1.0, c:="one"}
}

type record Myrec12{
  ROC roc optional,
  ROI roi optional,
  MyUnion1 u optional, 
  MyRecord1 r optional
}

type record of charstring ROC;
type record of integer  ROI;
type record MyRecord1 {
  integer       i optional,
  float         x optional,
  charstring    c
}

type union MyUnion1 {
  ROC roc,
  integer i,
  ROI roi,
  MyRecord1 r
}

testcase tc_record_completelyInit() runs on Mycomp {
  var Myrec12 vl_r1:=c_myrec2_1;
  if(isbound(vl_r1)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r2:=c_myrec2_part;
  if(isbound(vl_r2)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r3:=c_myrec2_part;
  if(isbound(vl_r3)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r4:=c_myrec2_part;
  if(isbound(vl_r4.roc)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r5:=c_myrec2_part;
  if(isbound(vl_r5.roi)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r6:=c_myrec2_part;
  if(isbound(vl_r6.u)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r7:=c_myrec2_part;
  if(isbound(vl_r7.u.r)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r8:=c_myrec2_part;
  if(isbound(vl_r8.u.r.i)){setverdict(fail)}else {setverdict(pass)};
  var Myrec12 vl_r9:=c_myrec2_part;
  if(isbound(vl_r9.u.r.x)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r10:=c_myrec2_part;
  if(isbound(vl_r10.u.r.c)){setverdict(pass)}else {setverdict(fail)};
  var Myrec12 vl_r11:=c_myrec2_part;
  if(isbound(vl_r11.u.i)){setverdict(fail)}else {setverdict(pass)};
}

testcase tc_record_partiallyInit12() runs on Mycomp {
  var Myrec12 vl_r:={ r:={i:=5}}
  if(isbound(vl_r.r)){setverdict(pass)}else {setverdict(fail)};
  if(isbound(vl_r.r.i)){setverdict(pass)}else {setverdict(fail)};
}

testcase tc_record_partiallyInit13() runs on Mycomp {
  var Myrec12 vl_r:={ r:={i:=5,x:=-,c:= -}} 
  if(isbound(vl_r)){setverdict(pass)}else {setverdict(fail)}; 
  if(isbound(vl_r.r)){setverdict(pass)}else {setverdict(fail)};
  if(isbound(vl_r.r.i)){setverdict(pass)}else {setverdict(fail)};
}

  testcase tc_record_unbound() runs on Mycomp {
    var template Myrec12 vtl_rec2;
    if(ispresent(vtl_rec2)) {setverdict(fail)}else {setverdict(pass)};
  }

  testcase tc_record_completelyInit_ispresent() runs on Mycomp {
    var Myrec12 vl_r1:=c_myrec2_1;
    if(ispresent(vl_r1)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r2:=c_myrec2_part;
    if(ispresent(vl_r2)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r3:=c_myrec2_part;
    if(ispresent(vl_r3.roc)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r4:=c_myrec2_part;
    if(ispresent(vl_r4.roi)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r5:=c_myrec2_part;
    if(ispresent(vl_r5.u)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r6:=c_myrec2_part;
    if(ispresent(vl_r6.u.r)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r7:=c_myrec2_part;
    if(ispresent(vl_r7.u.r.i)){setverdict(fail)}else {setverdict(pass)};
    var Myrec12 vl_r8:=c_myrec2_part;
    if(ispresent(vl_r8.u.r.x)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r9:=c_myrec2_part;
    if(ispresent(vl_r9.u.r.c)){setverdict(pass)}else {setverdict(fail)};
    var Myrec12 vl_r10:=c_myrec2_part;
    if(ispresent(vl_r10.u.i)){setverdict(fail)}else {setverdict(pass)};
  }

  testcase tc_record_partiallyInit12_ispresent() runs on Mycomp {
    var Myrec12 vl_r:={ r:={i:=5}}
    if(ispresent(vl_r.r)){setverdict(pass)}else {setverdict(fail)};
    if(ispresent(vl_r.r.i)){setverdict(pass)}else {setverdict(fail)};
  }

  testcase tc_record_partiallyInit13_ispresent() runs on Mycomp {
    var Myrec12 vl_r:={ r:={i:=5,x:=-,c:= -}} 
    if(ispresent(vl_r)){setverdict(pass)}else {setverdict(fail)}; 
    if(ispresent(vl_r.r)){setverdict(pass)}else {setverdict(fail)};
    if(ispresent(vl_r.r.i)){setverdict(pass)}else {setverdict(fail)};
  }

  testcase tc_record_omit() runs on Mycomp {
    var Myrec12 vl_r:={omit, omit, omit, omit} 
    if(ispresent(vl_r)){setverdict(pass)}else {setverdict(fail)}; 
    if(ispresent(vl_r.roc)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.roi)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.i)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.x)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.c)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.i)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.x)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.c)){setverdict(fail)}else {setverdict(pass)};
  }

  testcase tc_record_omit2() runs on Mycomp {
    var Myrec12 vl_r:={roc:=omit, roi:=omit,u:= omit,r:= omit} 
    if(ispresent(vl_r)){setverdict(pass)}else {setverdict(fail)}; 
    if(ispresent(vl_r.roc)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.roi)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.i)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.x)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.u.r.c)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.i)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.x)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.r.c)){setverdict(fail)}else {setverdict(pass)};
  }

  testcase tc_record_omit_HQ51693() runs on Mycomp {
    var Myrec9 r1 := {omit, omit};
    r1.f1 := r1.f2;
    if(ispresent(r1.f1) or ispresent(r1.f2)){setverdict(fail)}else {setverdict(pass)}; 
  }

  testcase tc_recordOf_omit() runs on Mycomp {
    var Myrec12 vl_r:=c_myrec2_1;
    if(ispresent(vl_r.roc)){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.roc[0])){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.roi)){setverdict(pass)}else {setverdict(fail)};
    if(ispresent(vl_r.roi[0])){setverdict(fail)}else {setverdict(pass)};
    if(ispresent(vl_r.roi[90])){setverdict(fail)}else {setverdict(pass)};
  }


  


 //##########################################################################//

   type record ExampleType {
    integer a,
    boolean b 
  }  

  template ExampleType exampleTemplate1 := {
    a := 4,
    b := false
  }

  testcase tc_rec_template() runs on Mycomp {

    if (isbound(exampleTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate1.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate1.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

  template ExampleType exampleTemplate2(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) := {
    a := MyintTemplate, 
    b := MyBoolTemplate
  }

  testcase tc_rec_template_param() runs on Mycomp {

    if (isbound(exampleTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate2.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate2(true).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2(true).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate2(true, 3).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate2(true, 3).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

  template ExampleType exampleTemplate3(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) modifies exampleTemplate2 := {
    a := MyintTemplate,
    b := MyBoolTemplate
  }

    testcase tc_rec_template_param_modifies() runs on Mycomp {

    if (isbound(exampleTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate3.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate3(true).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3(true).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleTemplate3(true, 3).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleTemplate3(true, 3).a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

  type record ExampleType2 {
    integer a,
    ExampleType t
  }


  template ExampleType2 exampleEmbTemplate1 := {
    a := 4,
    t := {3, true}
  }

  testcase tc_emb_rec_template() runs on Mycomp {

    if (isbound(exampleEmbTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate1.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate1.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate1.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate1.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

  template ExampleType2 exampleEmbTemplate2(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) := {
    a := MyintTemplate, 
    t := {MyintTemplate, MyBoolTemplate}
  }

  testcase tc_emb_rec_template_param() runs on Mycomp {

    if (isbound(exampleEmbTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true, 3).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true, 3).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate2(true, 3).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate2(true, 3).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

  template ExampleType2 exampleEmbTemplate3(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) modifies exampleEmbTemplate2 := {
    a := MyintTemplate,
    t := {MyintTemplate, MyBoolTemplate}
  }

  testcase tc_emb_rec_template_param_modifies() runs on Mycomp {

    if (isbound(exampleEmbTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3.t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3.t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true, 3).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true, 3).t)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleEmbTemplate3(true, 3).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleEmbTemplate3(true, 3).t.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

//###########################################################################//

template anytype exampleAnyTypeTemplate1 := {
  ExampleType := {2, false}
}

testcase tc_anytype_rec_template() runs on Mycomp {

    if (isbound(exampleAnyTypeTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate1)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate1.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate1.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate1.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate1.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

  template anytype exampleAnyTypeTemplate2(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) := {
    ExampleType := {MyintTemplate, MyBoolTemplate}
  }

  testcase tc_anytype_rec_template_param() runs on Mycomp {

    if (isbound(exampleAnyTypeTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true, 3).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true, 3).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate2(true, 3).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate2(true, 3).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

  template anytype exampleAnyTypeTemplate3(template boolean MyBoolTemplate := false, template integer MyintTemplate := 1) modifies exampleAnyTypeTemplate2 := {
    ExampleType := {MyintTemplate, MyBoolTemplate}
  }

  testcase tc_anytype_rec_template_param_modifies() runs on Mycomp {

    if (isbound(exampleAnyTypeTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3.ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3.ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true, 3))) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true, 3).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true, 3).ExampleType)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (isbound(exampleAnyTypeTemplate3(true, 3).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }

    if (ispresent(exampleAnyTypeTemplate3(true, 3).ExampleType.a)) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }


//###########################################################################//

testcase tc_record_equality() runs on Mycomp {
  var MyRec0 vl_rec_partial1 := { x1 := 1 };
  var MyRec0 vl_rec_partial2 := { x1 := 1 };
  @try {
    if (vl_rec_partial1 == vl_rec_partial2) {
      setverdict(fail, "Equal.");
    }
    else {
      setverdict(fail, "Not equal.");
    }
  }
  @catch (vl_msg) {
    if (match(vl_msg, pattern "*Unbound left operand of float comparison*")) {
      setverdict(pass);
    }
    else {
      setverdict(fail, "Invalid error caught: ", vl_msg);
    }
  }
}

//###########################################################################//
    
control {
 const MyRec0 cl_temp1:={ x1:=omit, x2:=3.4 }; // can constants be declared in the control part
 const recordOper_trecof cl_temp2:={ 'AF12'O };
 const recordOper_tset cl_temp3:={ x1:=234, x2:=1.9};
 const recordOper_tsetof cl_temp4:={"f","8"};
 const MyUnion cl_temp5:={ x2:=1.3 };
 const typedefrecordComp_myrec cl_const14 := {  // complex record
  x1 := { x1:=omit, x2:=3.4 },
  x2 := { 'AF12'O },
  x3 := { x1:=234, x2:=1.9},
  x4 := {"f","8"},
  x5 := { x2:=1.3 },
  x6 := {1,2,3}
 }
 var MyRec0 vl_temp1; // can variables be declared in the control part
 var recordOper_trecof vl_temp2;
 var recordOper_tset vl_temp3;
 var recordOper_tsetof vl_temp4;
 var MyUnion vl_temp5;
 var typedefrecordComp_myrec vl_const14;

 execute(tc_recordAssign());
 execute(tc_recordAssignIncomplete());
 execute(tc_recordAssignOpt());
 execute(tc_recordAssignRec());
 execute(tc_recordAssignRecof());
 execute(tc_recordAssignSet());
 execute(tc_recordAssignSetof());
 execute(tc_recordAssignUnion());
 execute(tc_recordAssignElem());
 execute(tc_recordAssignElemOpt());
 execute(tc_recordAssignElemRec());
 execute(tc_recordAssignElemRecof());
 execute(tc_recordAssignElemSet());
 execute(tc_recordAssignElemSetof());
 execute(tc_recordAssignElemUnion());
 execute(tc_recordSizeof());
 execute(tc_recordConst());
 execute(tc_recordConstOpt());
 execute(tc_recordConstRec());
 execute(tc_recordConstRecof());
 execute(tc_recordConstSet());
 execute(tc_recordConstSetof());
 execute(tc_recordConstUnion());
 execute(tc_recordComp());
 execute(tc_recordCompOpt());
 execute(tc_recordCompOptField());
 execute(tc_recordCompRec());
 execute(tc_recordCompRecof());
 execute(tc_recordCompSet());
 execute(tc_recordCompSetof());
 execute(tc_recordCompUnion());
 execute(tc_recordSubtypes());
 execute(tc_recordIsvalue());
 execute(tc_recordIsbound());
 execute(tc_recordIsvalue2());

 execute(tc_CR_TR00016681());
 
 execute(tc_record_completelyInit());
 execute(tc_record_partiallyInit12());
 execute(tc_record_partiallyInit13());
 execute(tc_record_unbound());
 execute(tc_record_completelyInit_ispresent());
 execute(tc_record_partiallyInit12_ispresent());
 execute(tc_record_partiallyInit13_ispresent());
 execute(tc_record_omit());
 execute(tc_record_omit2());
 execute(tc_record_omit_HQ51693());
 execute(tc_recordOf_omit());

 execute(tc_rec_template());
 execute(tc_rec_template_param());
 execute(tc_rec_template_param_modifies());

 execute(tc_emb_rec_template());
 execute(tc_emb_rec_template_param());
 execute(tc_emb_rec_template_param_modifies());

 execute(tc_anytype_rec_template());
 execute(tc_anytype_rec_template_param());
 execute(tc_anytype_rec_template_param_modifies());
 
 execute(tc_record_equality());
}
}
with {
  extension "anytype ExampleType"
}
