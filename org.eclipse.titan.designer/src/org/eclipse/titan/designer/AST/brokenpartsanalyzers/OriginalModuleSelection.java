/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
package org.eclipse.titan.designer.AST.brokenpartsanalyzers;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.runtime.Platform;
import org.eclipse.titan.designer.AST.Module;
import org.eclipse.titan.designer.AST.TTCN3.definitions.ImportModule;
import org.eclipse.titan.designer.AST.TTCN3.definitions.TTCN3Module;
import org.eclipse.titan.designer.consoles.TITANDebugConsole;
import org.eclipse.titan.designer.preferences.PreferenceConstants;
import org.eclipse.titan.designer.productUtilities.ProductConstants;
import org.eclipse.ui.console.MessageConsoleStream;

/**
 * Original solution wrapped into class.
 * 
 */
public final class OriginalModuleSelection extends SelectionMethodBase implements IBaseAnalyzer {
	private final boolean doIncrementalParsing;

	public OriginalModuleSelection() {
		super(SelectionAlgorithm.MODULESELECTIONORIGINAL);
		doIncrementalParsing = Platform.getPreferencesService().getBoolean(ProductConstants.PRODUCT_ID_DESIGNER, PreferenceConstants.USEINCREMENTALPARSING, false, null);		
		header = "\n**Selection with Original algorithm is started at:";
		footer = "**Selection with Original algorithm is started at:";
	}

	@Override
	public void execute() {
		if (writeDebugInfo){			
			TITANDebugConsole.println(String.format(format, header, simpleDateFormat.format(new Date())));			
		}
		start = System.nanoTime();
		
		boolean foundSkippable = true;
		while (foundSkippable) {
			foundSkippable = calculateModulesToSkip(allModules, modulesToSkip);
		}
		
		modulesToCheck.addAll(allModules);
		
		//TODO check if this can be removed
		if (doIncrementalParsing) {
			incrementalParsing();
		}
		
		end = System.nanoTime() - start;
		if (writeDebugInfo) {
			TITANDebugConsole.println(String.format(format, footer, simpleDateFormat.format(new Date())));
			infoAfterExecute();
		}
	}

	/**
	 * Calculates the list of modules that can be skipped when analyzing this project semantically.
	 * <p>
	 * This function might not be able to detect all modules that can be skipped at once. It should be run as long as it reports that it could remove new modules from the list of modules to be
	 * checked.
	 * 
	 * @param modulesToCheck
	 *            the list of modules to be check. Initially all modules, but the function will remove those that can be skipped.
	 * @param modulesToSkip
	 *            the list of modules that can be skipped, to be generated by the function.
	 * 
	 * @return true if there were modules found that can be skipped from analyzing, false otherwise.
	 */
	private boolean calculateModulesToSkip(final List<Module> modulesToCheck, final List<Module> modulesToSkip) {
		if (modulesToCheck.isEmpty()) {
			return false;
		}

		boolean foundSkippable = false;
		// proven to need checking
		final List<Module> failed = new ArrayList<Module>();
		final List<Module> modulesToCheckCopy = new ArrayList<Module>();
		modulesToCheckCopy.addAll(modulesToCheck);
		final MessageConsoleStream stream = TITANDebugConsole.getConsole().newMessageStream();

		for (Iterator<Module> iterator = modulesToCheckCopy.iterator(); iterator.hasNext();) {
			final Module module = iterator.next();
			if (module == null) {
				continue;
			}
			if (failed.contains(module) || modulesToSkip.contains(module)) {
				continue;
			}

			if (module.getLastCompilationTimeStamp() == null || !semanticallyChecked.contains(module.getName())) {
				if (writeDebugInfo) {
					TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it was not yet analyzed.", stream);
				}
				failed.add(module);
				continue;
			}

			/**
			 * The modules that are reachable from the starting one.
			 */
			final List<Module> reachableModules = new ArrayList<Module>();
			reachableModules.add(module);

			boolean valid = true;
			for (int i = 0; i < reachableModules.size() && valid; i++) {
				final Module module2 = reachableModules.get(i);
				if (module2 == null) {
					valid = false;
					TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it reaches a module that could not be parsed.", stream);
					continue;
				}
				if (failed.contains(module2)) {
					valid = false;
					continue;
				}
				if (module2.getLastCompilationTimeStamp() != null || !semanticallyChecked.contains(module2.getName())) {
					if (module2.hasUnhandledImportChanges()) {
						valid = false;
						failed.add(module2);
						if (writeDebugInfo) {
							TITANDebugConsole.println("  ** Module " + module2.getName() + " can not be skipped as it has unhandled import changes.", stream);
							if (module != module2) {
								TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it depends on " + module2.getName() + " which has unhandled import changes.", stream);
							}
						}
						continue;
					}

					final List<Module> importedModules = module2.getImportedModules();
					if (!importedModules.isEmpty()) {
						boolean allElements = true;
						Module module3;
						for (int j = 0; j < importedModules.size() && allElements; j++) {
							module3 = importedModules.get(j);
							if (module3 == null) {
								// erroneous
								// import
								allElements = false;
								if (writeDebugInfo) {
									if (module2 instanceof TTCN3Module) {
										final List<ImportModule> impModules = ((TTCN3Module) module2).getImports();
										if (j < impModules.size()) {
											TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it imports `" + impModules.get(j).getName() + "' that could not be parsed.", stream);
										}
									}
									TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it imports a module that could not be parsed.", stream);
								}
							} else if (failed.contains(module3)) {
								allElements = false;
								if (writeDebugInfo) {
									TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it depends on " + module3.getName() + " which needs to be checked.", stream);
								}
							} else if (modulesToSkip.contains(module3)) {
								// already decided, that it can be skipped
							} else if (module3.getLastCompilationTimeStamp() == null|| !semanticallyChecked.contains(module3.getName())) {
								// imports a module that was not checked, so
								// this must also be re-checked
								allElements = false;
								if (writeDebugInfo) {
									TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it depends on " + module3.getName() + " which was not yet analyzed.", stream);
								}
							} else {
								if (!reachableModules.contains(module3)) {
									reachableModules.add(module3);
								}
							}
						}

						if (!allElements) {
							valid = false;
						}
					}
				} else {
					// The module was not yet checked.
					valid = false;
					TITANDebugConsole.println("  ** Module " + module.getName() + " can not be skipped as it depends on " + module2.getName() + " which was not yet checked.", stream);
				}
			}

			if (valid) {
				modulesToSkip.addAll(reachableModules);
				modulesToCheck.removeAll(reachableModules);
				foundSkippable = true;
			} else {
				failed.add(module);
			}
		}

		if (writeDebugInfo) {
			TITANDebugConsole.println("  ** Found " + modulesToCheck.size() + " modules that needs to be checked and " + modulesToSkip.size() + " modules to skip.", stream);
		}

		return foundSkippable;
	}
	
	// original solution 
	public void incrementalParsing() {
		// the modules that can be reached directly must
		// be checked as the used state of the
		// definitions might have changed
		final List<Module> modulesToCheck2 = new ArrayList<Module>();
		for (Module module2 : modulesToCheck) {
			if (module2.getLastCompilationTimeStamp() != null && semanticallyChecked.contains(module2.getName())) {
				final List<Module> importedModules = module2.getImportedModules();
				if (importedModules != null && !importedModules.isEmpty()) {
					for (Module module3 : importedModules) {
						if (module3 != null && !modulesToCheck.contains(module3) && !modulesToCheck2.contains(module3)) {
							modulesToCheck2.add(module3);
						}
					}
				}
			}
		}

		modulesToCheck.addAll(modulesToCheck2);
		modulesToSkip.removeAll(modulesToCheck2);	
	}
}
