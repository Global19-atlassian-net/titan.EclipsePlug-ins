/******************************************************************************
 * Copyright (c) 2000-2019 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 ******************************************************************************/
package org.eclipse.titan.runtime.core;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.titan.runtime.core.Base_Type.TTCN_Typedescriptor;
import org.eclipse.titan.runtime.core.JSON_Tokenizer.json_token_t;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Any;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_AnyOrNone;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Assignment_List;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_ComplementList_Template;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_List_Template;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Name;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Omit;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Unbound;
import org.eclipse.titan.runtime.core.Param_Types.Module_Parameter;
import org.eclipse.titan.runtime.core.RAW.RAW_Force_Omit;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tr_pos;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tree;
import org.eclipse.titan.runtime.core.RAW.ext_bit_t;
import org.eclipse.titan.runtime.core.RAW.top_bit_order_t;
import org.eclipse.titan.runtime.core.RecordOf_Match.compare_function_t;
import org.eclipse.titan.runtime.core.RecordOf_Match.log_function_t;
import org.eclipse.titan.runtime.core.RecordOf_Match.match_function_t;
import org.eclipse.titan.runtime.core.TTCN_EncDec.coding_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.error_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.raw_order_t;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location.entity_type_t;

/**
 * Generated from PreGenRecordOf.ttcn
 *
 * @author Kristof Szabados
 */
public final class PreGenRecordOf extends TTCN_Module {

	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BOOLEAN_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BOOLEAN_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.oftype", RAW.TitanBoolean_raw_, JSON.TitanBoolean_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__INTEGER_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__INTEGER_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.oftype", RAW.TitanInteger_raw_, JSON.TitanInteger_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__FLOAT_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__FLOAT_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.oftype", RAW.TitanFloat_raw_, JSON.TitanFloat_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BITSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BITSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.oftype", RAW.TitanBitString_raw_, JSON.TitanBitString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__HEXSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__HEXSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.oftype", RAW.TitanHexString_raw_, JSON.TitanHexString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__OCTETSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__OCTETSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.oftype", RAW.TitanOctetString_raw_, JSON.TitanOctetString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__CHARSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__CHARSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.oftype", RAW.TitanCharString_raw_, JSON.TitanCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.oftype", RAW.TitanUniversalCharString_raw_, JSON.TitanUniversalCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.oftype", RAW.TitanBoolean_raw_, JSON.TitanBoolean_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__INTEGER__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__INTEGER__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.oftype", RAW.TitanInteger_raw_, JSON.TitanInteger_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__FLOAT__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__FLOAT__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.oftype", RAW.TitanFloat_raw_, JSON.TitanFloat_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.oftype", RAW.TitanBitString_raw_, JSON.TitanBitString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.oftype", RAW.TitanHexString_raw_, JSON.TitanHexString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.oftype", RAW.TitanOctetString_raw_, JSON.TitanOctetString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.oftype", RAW.TitanCharString_raw_, JSON.TitanCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.oftype", RAW.TitanUniversalCharString_raw_, JSON.TitanUniversalCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BOOLEAN_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BOOLEAN_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.oftype", RAW.TitanBoolean_raw_, JSON.TitanBoolean_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__INTEGER_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_INTEGER", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__INTEGER_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_INTEGER.oftype", RAW.TitanInteger_raw_, JSON.TitanInteger_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__FLOAT_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_FLOAT", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__FLOAT_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_FLOAT.oftype", RAW.TitanFloat_raw_, JSON.TitanFloat_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BITSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BITSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BITSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BITSTRING.oftype", RAW.TitanBitString_raw_, JSON.TitanBitString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__HEXSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__HEXSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.oftype", RAW.TitanHexString_raw_, JSON.TitanHexString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__OCTETSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__OCTETSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.oftype", RAW.TitanOctetString_raw_, JSON.TitanOctetString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__CHARSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__CHARSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.oftype", RAW.TitanCharString_raw_, JSON.TitanCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__UNIVERSAL__CHARSTRING_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__UNIVERSAL__CHARSTRING_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.oftype", RAW.TitanUniversalCharString_raw_, JSON.TitanUniversalCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BOOLEAN__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BOOLEAN__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.oftype", RAW.TitanBoolean_raw_, JSON.TitanBoolean_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__INTEGER__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__INTEGER__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.oftype", RAW.TitanInteger_raw_, JSON.TitanInteger_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__FLOAT__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__FLOAT__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.oftype", RAW.TitanFloat_raw_, JSON.TitanFloat_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BITSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__BITSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.oftype", RAW.TitanBitString_raw_, JSON.TitanBitString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__HEXSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__HEXSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.oftype", RAW.TitanHexString_raw_, JSON.TitanHexString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.oftype", RAW.TitanOctetString_raw_, JSON.TitanOctetString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__CHARSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__CHARSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.oftype", RAW.TitanCharString_raw_, JSON.TitanCharString_json_, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED", null, null, null);
	public static final TTCN_Typedescriptor PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_0_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.oftype", RAW.TitanUniversalCharString_raw_, JSON.TitanUniversalCharString_json_, null);
	public static final TTCN_Typedescriptor anytype_descr_ = new TTCN_Typedescriptor("@PreGenRecordOf.anytype", null, null, null);

	public PreGenRecordOf() {
		super("PreGenRecordOf", module_type_enum.TTCN3_MODULE, new byte[] {(byte)2, (byte)172, (byte)107, (byte)74, (byte)67, (byte)37, (byte)48, (byte)47, (byte)113, (byte)216, (byte)134, (byte)12, (byte)12, (byte)157, (byte)70, (byte)204});
	}

	public static class PREGEN__RECORD__OF__INTEGER__OPTIMIZED extends Record_Of_Type {

		protected List<TitanInteger> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
		}

		private static final List<TitanInteger> copy_list( final List<TitanInteger> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanInteger> newList = new ArrayList<TitanInteger>( srcList.size() );
			for (final TitanInteger srcElem : srcList) {
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanInteger> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanInteger> newList = new ArrayList<TitanInteger>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanInteger leftElem = valueElements.get( i );
				final TitanInteger rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanInteger leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanInteger elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanInteger get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanInteger temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanInteger get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanInteger constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanInteger elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanInteger constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanInteger elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanInteger>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanInteger() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanInteger get_unbound_elem() {
			return new TitanInteger();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED","element");
			final PREGEN__RECORD__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanInteger(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED","element");
			final PREGEN__RECORD__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanInteger elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanInteger elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanInteger temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanInteger>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanInteger temp2 = new TitanInteger();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanInteger>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanInteger val = new TitanInteger();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanInteger_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__INTEGER__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanInteger_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanInteger_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanInteger_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanInteger_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template temp = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template temp = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__INTEGER__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanInteger_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanInteger_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanInteger_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanInteger_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanInteger_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanInteger_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__INTEGER__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__INTEGER__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__INTEGER__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanInteger_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanInteger_template temp2 = new TitanInteger_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__INTEGER__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__UNIVERSAL__CHARSTRING extends Record_Of_Type {

		protected List<TitanUniversalCharString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)left_ptr, left_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
		}

		private static final List<TitanUniversalCharString> copy_list( final List<TitanUniversalCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( srcList.size() );
			for (final TitanUniversalCharString srcElem : srcList) {
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanUniversalCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING) {
				return operator_equals((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING left_ptr, final int left_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			final TitanUniversalCharString temp_left = left_ptr.valueElements.get(left_index);
			final TitanUniversalCharString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_concatenate(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING concatenation.");
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanUniversalCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(this);
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanUniversalCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanUniversalCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanUniversalCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanUniversalCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanUniversalCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanUniversalCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanUniversalCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanUniversalCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanUniversalCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanUniversalCharString get_unbound_elem() {
			return new TitanUniversalCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING","element");
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING","element");
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanUniversalCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanUniversalCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final int index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanUniversalCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanUniversalCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanUniversalCharString temp2 = new TitanUniversalCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanUniversalCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanUniversalCharString val = new TitanUniversalCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanUniversalCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)value_ptr, value_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanUniversalCharString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)value_ptr, value_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template( final Optional<PREGEN__SET__OF__UNIVERSAL__CHARSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanUniversalCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING with an unbound value.");
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanUniversalCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template temp = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanUniversalCharString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template temp = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanUniversalCharString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING value_ptr, final int value_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING value_ptr, final int value_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING) {
				return match((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign( final Optional<PREGEN__SET__OF__UNIVERSAL__CHARSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanUniversalCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return set_items.size();
		}
		@Override
		public TitanUniversalCharString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanUniversalCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanUniversalCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanUniversalCharString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanUniversalCharString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanUniversalCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING) {
				log_match((PREGEN__SET__OF__UNIVERSAL__CHARSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
				}
				value_elements = new ArrayList<TitanUniversalCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanUniversalCharString_template temp2 = new TitanUniversalCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template temp2 = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanOctetString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
		}

		private static final List<TitanOctetString> copy_list( final List<TitanOctetString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( srcList.size() );
			for (final TitanOctetString srcElem : srcList) {
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanOctetString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanOctetString leftElem = valueElements.get( i );
				final TitanOctetString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanOctetString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanOctetString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanOctetString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanOctetString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanOctetString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanOctetString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanOctetString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanOctetString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanOctetString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanOctetString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanOctetString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanOctetString get_unbound_elem() {
			return new TitanOctetString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanOctetString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanOctetString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanOctetString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanOctetString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanOctetString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanOctetString temp2 = new TitanOctetString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanOctetString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanOctetString val = new TitanOctetString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanOctetString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanOctetString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanOctetString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanOctetString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanOctetString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanOctetString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanOctetString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanOctetString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanOctetString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanOctetString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanOctetString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanOctetString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanOctetString_template temp2 = new TitanOctetString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__FLOAT extends Record_Of_Type {

		protected List<TitanFloat> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__FLOAT() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT( final PREGEN__RECORD__OF__FLOAT otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
		}

		private static final List<TitanFloat> copy_list( final List<TitanFloat> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanFloat> newList = new ArrayList<TitanFloat>( srcList.size() );
			for (final TitanFloat srcElem : srcList) {
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanFloat> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanFloat> newList = new ArrayList<TitanFloat>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__FLOAT) {
				return operator_equals((PREGEN__RECORD__OF__FLOAT)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__FLOAT.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__FLOAT other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanFloat leftElem = valueElements.get( i );
				final TitanFloat rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanFloat leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__FLOAT otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__FLOAT operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__FLOAT) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT.");
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__FLOAT operator_assign( final PREGEN__RECORD__OF__FLOAT otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__FLOAT operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__FLOAT operator_concatenate(final PREGEN__RECORD__OF__FLOAT other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT concatenation.");
			}
			final PREGEN__RECORD__OF__FLOAT ret_val = new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanFloat elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__FLOAT operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__FLOAT(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.
		 * */
		public PREGEN__RECORD__OF__FLOAT rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.
		 * */
		public PREGEN__RECORD__OF__FLOAT rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.
		 * */
		public PREGEN__RECORD__OF__FLOAT rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.
		 * */
		public PREGEN__RECORD__OF__FLOAT rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__FLOAT(this);
			}
			final PREGEN__RECORD__OF__FLOAT ret_val = new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanFloat get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanFloat temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanFloat get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanFloat constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanFloat elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanFloat constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanFloat elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanFloat>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanFloat() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanFloat get_unbound_elem() {
			return new TitanFloat();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT","element");
			final PREGEN__RECORD__OF__FLOAT ret_val = new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanFloat(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT","element");
			final PREGEN__RECORD__OF__FLOAT ret_val = new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanFloat elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanFloat elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanFloat temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanFloat>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanFloat temp2 = new TitanFloat();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanFloat>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanFloat val = new TitanFloat();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__FLOAT_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanFloat_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__FLOAT_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__FLOAT)value_ptr, value_index, (PREGEN__RECORD__OF__FLOAT_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template( final PREGEN__RECORD__OF__FLOAT otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template( final PREGEN__RECORD__OF__FLOAT_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__FLOAT_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template( final Optional<PREGEN__RECORD__OF__FLOAT> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanFloat_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__FLOAT other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT with an unbound value.");
			value_elements = new ArrayList<TitanFloat_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanFloat_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__FLOAT_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanFloat_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__FLOAT_template temp = new PREGEN__RECORD__OF__FLOAT_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__FLOAT_template temp = new PREGEN__RECORD__OF__FLOAT_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__FLOAT other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__FLOAT other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__FLOAT value_ptr, final int value_index, final PREGEN__RECORD__OF__FLOAT_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT) {
				return match((PREGEN__RECORD__OF__FLOAT)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT_template operator_assign( final PREGEN__RECORD__OF__FLOAT otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT_template operator_assign( final PREGEN__RECORD__OF__FLOAT_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__FLOAT_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT.");
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT_template) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT_template operator_assign( final Optional<PREGEN__RECORD__OF__FLOAT> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanFloat_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanFloat_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanFloat_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanFloat_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__FLOAT.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanFloat_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__FLOAT containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__FLOAT.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__FLOAT_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__FLOAT_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__FLOAT_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
			final PREGEN__RECORD__OF__FLOAT ret_val = new PREGEN__RECORD__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanFloat_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__FLOAT match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__FLOAT) {
				log_match((PREGEN__RECORD__OF__FLOAT)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__FLOAT match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
				}
				value_elements = new ArrayList<TitanFloat_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanFloat_template temp2 = new TitanFloat_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__FLOAT_template temp2 = new PREGEN__RECORD__OF__FLOAT_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT" : name));
		}
	}
	public static class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING extends Record_Of_Type {

		protected List<TitanUniversalCharString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
		}

		private static final List<TitanUniversalCharString> copy_list( final List<TitanUniversalCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( srcList.size() );
			for (final TitanUniversalCharString srcElem : srcList) {
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanUniversalCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING) {
				return operator_equals((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanUniversalCharString leftElem = valueElements.get( i );
				final TitanUniversalCharString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanUniversalCharString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_concatenate(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING concatenation.");
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanUniversalCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(this);
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanUniversalCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanUniversalCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanUniversalCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanUniversalCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanUniversalCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanUniversalCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanUniversalCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanUniversalCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanUniversalCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanUniversalCharString get_unbound_elem() {
			return new TitanUniversalCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING","element");
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING","element");
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanUniversalCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanUniversalCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanUniversalCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanUniversalCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanUniversalCharString temp2 = new TitanUniversalCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanUniversalCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanUniversalCharString val = new TitanUniversalCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanUniversalCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)value_ptr, value_index, (PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template( final Optional<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanUniversalCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING with an unbound value.");
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanUniversalCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template temp = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template temp = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING value_ptr, final int value_index, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING) {
				return match((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign( final Optional<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanUniversalCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanUniversalCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanUniversalCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanUniversalCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING) {
				log_match((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
				}
				value_elements = new ArrayList<TitanUniversalCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanUniversalCharString_template temp2 = new TitanUniversalCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template temp2 = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__BITSTRING extends Record_Of_Type {

		protected List<TitanBitString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING( final PREGEN__RECORD__OF__BITSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
		}

		private static final List<TitanBitString> copy_list( final List<TitanBitString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBitString> newList = new ArrayList<TitanBitString>( srcList.size() );
			for (final TitanBitString srcElem : srcList) {
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBitString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBitString> newList = new ArrayList<TitanBitString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BITSTRING) {
				return operator_equals((PREGEN__RECORD__OF__BITSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__BITSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__BITSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBitString leftElem = valueElements.get( i );
				final TitanBitString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBitString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__BITSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__BITSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BITSTRING) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BITSTRING operator_assign( final PREGEN__RECORD__OF__BITSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BITSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING operator_concatenate(final PREGEN__RECORD__OF__BITSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING concatenation.");
			}
			final PREGEN__RECORD__OF__BITSTRING ret_val = new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBitString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__BITSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.
		 * */
		public PREGEN__RECORD__OF__BITSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.
		 * */
		public PREGEN__RECORD__OF__BITSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.
		 * */
		public PREGEN__RECORD__OF__BITSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.
		 * */
		public PREGEN__RECORD__OF__BITSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__BITSTRING(this);
			}
			final PREGEN__RECORD__OF__BITSTRING ret_val = new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBitString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBitString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBitString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBitString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBitString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBitString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBitString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBitString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBitString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBitString get_unbound_elem() {
			return new TitanBitString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING","element");
			final PREGEN__RECORD__OF__BITSTRING ret_val = new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBitString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING","element");
			final PREGEN__RECORD__OF__BITSTRING ret_val = new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBitString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBitString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBitString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBitString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBitString temp2 = new TitanBitString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBitString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBitString val = new TitanBitString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__BITSTRING_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBitString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__BITSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__BITSTRING)value_ptr, value_index, (PREGEN__RECORD__OF__BITSTRING_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template( final PREGEN__RECORD__OF__BITSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template( final PREGEN__RECORD__OF__BITSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__BITSTRING_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template( final Optional<PREGEN__RECORD__OF__BITSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBitString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__BITSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING with an unbound value.");
			value_elements = new ArrayList<TitanBitString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBitString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__BITSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBitString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__BITSTRING_template temp = new PREGEN__RECORD__OF__BITSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__BITSTRING_template temp = new PREGEN__RECORD__OF__BITSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BITSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BITSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__BITSTRING value_ptr, final int value_index, final PREGEN__RECORD__OF__BITSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING) {
				return match((PREGEN__RECORD__OF__BITSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign( final PREGEN__RECORD__OF__BITSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign( final PREGEN__RECORD__OF__BITSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__BITSTRING_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING_template) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign( final Optional<PREGEN__RECORD__OF__BITSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBitString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBitString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBitString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBitString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BITSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBitString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__BITSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BITSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__BITSTRING_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__BITSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__BITSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
			final PREGEN__RECORD__OF__BITSTRING ret_val = new PREGEN__RECORD__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBitString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BITSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__BITSTRING) {
				log_match((PREGEN__RECORD__OF__BITSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BITSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
				}
				value_elements = new ArrayList<TitanBitString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBitString_template temp2 = new TitanBitString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__BITSTRING_template temp2 = new PREGEN__RECORD__OF__BITSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED extends Record_Of_Type {

		protected List<TitanBoolean> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
		}

		private static final List<TitanBoolean> copy_list( final List<TitanBoolean> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( srcList.size() );
			for (final TitanBoolean srcElem : srcList) {
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBoolean> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBoolean leftElem = valueElements.get( i );
				final TitanBoolean rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBoolean leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBoolean elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBoolean get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBoolean temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBoolean get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBoolean constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBoolean elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBoolean constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBoolean elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBoolean>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBoolean() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBoolean get_unbound_elem() {
			return new TitanBoolean();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED","element");
			final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBoolean(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED","element");
			final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBoolean elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBoolean elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBoolean temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBoolean>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBoolean temp2 = new TitanBoolean();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBoolean>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBoolean val = new TitanBoolean();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBoolean_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBoolean_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanBoolean_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBoolean_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBoolean_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template temp = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template temp = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBoolean_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBoolean_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBoolean_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBoolean_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBoolean_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBoolean_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanBoolean_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBoolean_template temp2 = new TitanBoolean_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__CHARSTRING extends Record_Of_Type {

		protected List<TitanCharString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING( final PREGEN__RECORD__OF__CHARSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copy_list( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanCharString> newList = new ArrayList<TitanCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__CHARSTRING) {
				return operator_equals((PREGEN__RECORD__OF__CHARSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__CHARSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__CHARSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final TitanCharString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__CHARSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__CHARSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__CHARSTRING) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING operator_assign( final PREGEN__RECORD__OF__CHARSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING operator_concatenate(final PREGEN__RECORD__OF__CHARSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING concatenation.");
			}
			final PREGEN__RECORD__OF__CHARSTRING ret_val = new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__CHARSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__CHARSTRING(this);
			}
			final PREGEN__RECORD__OF__CHARSTRING ret_val = new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString get_unbound_elem() {
			return new TitanCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING","element");
			final PREGEN__RECORD__OF__CHARSTRING ret_val = new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING","element");
			final PREGEN__RECORD__OF__CHARSTRING ret_val = new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanCharString val = new TitanCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__CHARSTRING_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__CHARSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__CHARSTRING)value_ptr, value_index, (PREGEN__RECORD__OF__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template( final PREGEN__RECORD__OF__CHARSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template( final PREGEN__RECORD__OF__CHARSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__CHARSTRING_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template( final Optional<PREGEN__RECORD__OF__CHARSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__CHARSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING with an unbound value.");
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__CHARSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__CHARSTRING_template temp = new PREGEN__RECORD__OF__CHARSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__CHARSTRING_template temp = new PREGEN__RECORD__OF__CHARSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__CHARSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__CHARSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__CHARSTRING value_ptr, final int value_index, final PREGEN__RECORD__OF__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING) {
				return match((PREGEN__RECORD__OF__CHARSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign( final PREGEN__RECORD__OF__CHARSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign( final PREGEN__RECORD__OF__CHARSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING_template) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign( final Optional<PREGEN__RECORD__OF__CHARSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__CHARSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__CHARSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__CHARSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__CHARSTRING_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__CHARSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
			final PREGEN__RECORD__OF__CHARSTRING ret_val = new PREGEN__RECORD__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__CHARSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__CHARSTRING) {
				log_match((PREGEN__RECORD__OF__CHARSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__CHARSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__CHARSTRING_template temp2 = new PREGEN__RECORD__OF__CHARSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__BOOLEAN extends Record_Of_Type {

		protected List<TitanBoolean> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN( final PREGEN__RECORD__OF__BOOLEAN otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
		}

		private static final List<TitanBoolean> copy_list( final List<TitanBoolean> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( srcList.size() );
			for (final TitanBoolean srcElem : srcList) {
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBoolean> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BOOLEAN) {
				return operator_equals((PREGEN__RECORD__OF__BOOLEAN)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__BOOLEAN.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__BOOLEAN other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBoolean leftElem = valueElements.get( i );
				final TitanBoolean rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBoolean leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__BOOLEAN otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__BOOLEAN operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BOOLEAN) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN.");
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN operator_assign( final PREGEN__RECORD__OF__BOOLEAN otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN operator_concatenate(final PREGEN__RECORD__OF__BOOLEAN other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN concatenation.");
			}
			final PREGEN__RECORD__OF__BOOLEAN ret_val = new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBoolean elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__BOOLEAN(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__BOOLEAN(this);
			}
			final PREGEN__RECORD__OF__BOOLEAN ret_val = new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBoolean get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBoolean temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBoolean get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBoolean constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBoolean elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBoolean constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBoolean elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBoolean>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBoolean() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBoolean get_unbound_elem() {
			return new TitanBoolean();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN","element");
			final PREGEN__RECORD__OF__BOOLEAN ret_val = new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBoolean(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN","element");
			final PREGEN__RECORD__OF__BOOLEAN ret_val = new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBoolean elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBoolean elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBoolean temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBoolean>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBoolean temp2 = new TitanBoolean();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBoolean>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBoolean val = new TitanBoolean();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__BOOLEAN_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBoolean_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__BOOLEAN_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__BOOLEAN)value_ptr, value_index, (PREGEN__RECORD__OF__BOOLEAN_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template( final PREGEN__RECORD__OF__BOOLEAN otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template( final PREGEN__RECORD__OF__BOOLEAN_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__BOOLEAN_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template( final Optional<PREGEN__RECORD__OF__BOOLEAN> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBoolean_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__BOOLEAN other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN with an unbound value.");
			value_elements = new ArrayList<TitanBoolean_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBoolean_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__BOOLEAN_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBoolean_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__BOOLEAN_template temp = new PREGEN__RECORD__OF__BOOLEAN_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__BOOLEAN_template temp = new PREGEN__RECORD__OF__BOOLEAN_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BOOLEAN other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BOOLEAN other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__BOOLEAN value_ptr, final int value_index, final PREGEN__RECORD__OF__BOOLEAN_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN) {
				return match((PREGEN__RECORD__OF__BOOLEAN)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign( final PREGEN__RECORD__OF__BOOLEAN otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign( final PREGEN__RECORD__OF__BOOLEAN_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN.");
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BOOLEAN_template) {
				return operator_assign((PREGEN__RECORD__OF__BOOLEAN_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BOOLEAN_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign( final Optional<PREGEN__RECORD__OF__BOOLEAN> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BOOLEAN_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBoolean_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final int index, final int len, final PREGEN__RECORD__OF__BOOLEAN repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BOOLEAN repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBoolean_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBoolean_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBoolean_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BOOLEAN.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBoolean_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__BOOLEAN containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BOOLEAN.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__BOOLEAN_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__BOOLEAN_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__BOOLEAN valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
			final PREGEN__RECORD__OF__BOOLEAN ret_val = new PREGEN__RECORD__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBoolean_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BOOLEAN substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BOOLEAN match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__BOOLEAN) {
				log_match((PREGEN__RECORD__OF__BOOLEAN)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BOOLEAN match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
				}
				value_elements = new ArrayList<TitanBoolean_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBoolean_template temp2 = new TitanBoolean_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__BOOLEAN_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__BOOLEAN_template temp2 = new PREGEN__RECORD__OF__BOOLEAN_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BOOLEAN" : name));
		}
	}
	public static class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanBitString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
		}

		private static final List<TitanBitString> copy_list( final List<TitanBitString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBitString> newList = new ArrayList<TitanBitString>( srcList.size() );
			for (final TitanBitString srcElem : srcList) {
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBitString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBitString> newList = new ArrayList<TitanBitString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBitString leftElem = valueElements.get( i );
				final TitanBitString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanBitString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBitString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBitString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBitString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBitString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBitString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBitString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBitString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBitString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBitString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBitString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBitString get_unbound_elem() {
			return new TitanBitString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBitString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBitString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBitString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBitString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBitString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBitString temp2 = new TitanBitString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBitString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBitString val = new TitanBitString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBitString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBitString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanBitString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBitString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBitString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBitString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBitString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBitString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBitString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBitString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBitString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__BITSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__BITSTRING__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__BITSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanBitString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBitString_template temp2 = new TitanBitString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_BITSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__INTEGER extends Record_Of_Type {

		protected List<TitanInteger> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__INTEGER() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER( final PREGEN__RECORD__OF__INTEGER otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
		}

		private static final List<TitanInteger> copy_list( final List<TitanInteger> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanInteger> newList = new ArrayList<TitanInteger>( srcList.size() );
			for (final TitanInteger srcElem : srcList) {
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanInteger> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanInteger> newList = new ArrayList<TitanInteger>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__INTEGER) {
				return operator_equals((PREGEN__RECORD__OF__INTEGER)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__INTEGER.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__INTEGER other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanInteger leftElem = valueElements.get( i );
				final TitanInteger rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanInteger leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__INTEGER otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__INTEGER operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__INTEGER) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER.");
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__INTEGER operator_assign( final PREGEN__RECORD__OF__INTEGER otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__INTEGER operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__INTEGER operator_concatenate(final PREGEN__RECORD__OF__INTEGER other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER concatenation.");
			}
			final PREGEN__RECORD__OF__INTEGER ret_val = new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanInteger elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__INTEGER operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__INTEGER(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.
		 * */
		public PREGEN__RECORD__OF__INTEGER rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.
		 * */
		public PREGEN__RECORD__OF__INTEGER rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.
		 * */
		public PREGEN__RECORD__OF__INTEGER rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.
		 * */
		public PREGEN__RECORD__OF__INTEGER rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__INTEGER(this);
			}
			final PREGEN__RECORD__OF__INTEGER ret_val = new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanInteger get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanInteger temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanInteger get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanInteger constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanInteger elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanInteger constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanInteger elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanInteger>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanInteger() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanInteger get_unbound_elem() {
			return new TitanInteger();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER","element");
			final PREGEN__RECORD__OF__INTEGER ret_val = new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanInteger(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER","element");
			final PREGEN__RECORD__OF__INTEGER ret_val = new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanInteger elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanInteger elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanInteger temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanInteger>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanInteger temp2 = new TitanInteger();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanInteger>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanInteger val = new TitanInteger();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__INTEGER_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanInteger_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__INTEGER_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__INTEGER)value_ptr, value_index, (PREGEN__RECORD__OF__INTEGER_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template( final PREGEN__RECORD__OF__INTEGER otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template( final PREGEN__RECORD__OF__INTEGER_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__INTEGER_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template( final Optional<PREGEN__RECORD__OF__INTEGER> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanInteger_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__INTEGER other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER with an unbound value.");
			value_elements = new ArrayList<TitanInteger_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanInteger_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__INTEGER_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanInteger_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__INTEGER_template temp = new PREGEN__RECORD__OF__INTEGER_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__INTEGER_template temp = new PREGEN__RECORD__OF__INTEGER_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__INTEGER other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__INTEGER other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__INTEGER value_ptr, final int value_index, final PREGEN__RECORD__OF__INTEGER_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER) {
				return match((PREGEN__RECORD__OF__INTEGER)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER_template operator_assign( final PREGEN__RECORD__OF__INTEGER otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER_template operator_assign( final PREGEN__RECORD__OF__INTEGER_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__INTEGER_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER.");
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__INTEGER_template) {
				return operator_assign((PREGEN__RECORD__OF__INTEGER_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__INTEGER_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER_template operator_assign( final Optional<PREGEN__RECORD__OF__INTEGER> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__INTEGER_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanInteger_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final int index, final int len, final PREGEN__RECORD__OF__INTEGER repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__INTEGER repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanInteger_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanInteger_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanInteger_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__INTEGER.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanInteger_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__INTEGER containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__INTEGER.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__INTEGER_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__INTEGER_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__INTEGER_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__INTEGER valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
			final PREGEN__RECORD__OF__INTEGER ret_val = new PREGEN__RECORD__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanInteger_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__INTEGER substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__INTEGER match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__INTEGER) {
				log_match((PREGEN__RECORD__OF__INTEGER)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__INTEGER match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
				}
				value_elements = new ArrayList<TitanInteger_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanInteger_template temp2 = new TitanInteger_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__INTEGER_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__INTEGER_template temp2 = new PREGEN__RECORD__OF__INTEGER_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_INTEGER" : name));
		}
	}
	public static class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanUniversalCharString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
		}

		private static final List<TitanUniversalCharString> copy_list( final List<TitanUniversalCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( srcList.size() );
			for (final TitanUniversalCharString srcElem : srcList) {
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanUniversalCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			final TitanUniversalCharString temp_left = left_ptr.valueElements.get(left_index);
			final TitanUniversalCharString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanUniversalCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanUniversalCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanUniversalCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanUniversalCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanUniversalCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanUniversalCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanUniversalCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanUniversalCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanUniversalCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanUniversalCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanUniversalCharString get_unbound_elem() {
			return new TitanUniversalCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanUniversalCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanUniversalCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanUniversalCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanUniversalCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanUniversalCharString temp2 = new TitanUniversalCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanUniversalCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanUniversalCharString val = new TitanUniversalCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanUniversalCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanUniversalCharString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final Optional<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanUniversalCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanUniversalCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanUniversalCharString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanUniversalCharString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return match((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanUniversalCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanUniversalCharString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanUniversalCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanUniversalCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanUniversalCharString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanUniversalCharString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanUniversalCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				log_match((PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanUniversalCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanUniversalCharString_template temp2 = new TitanUniversalCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp2 = new PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_UNIVERSAL_CHARSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__BOOLEAN extends Record_Of_Type {

		protected List<TitanBoolean> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__BOOLEAN)left_ptr, left_index, (PREGEN__SET__OF__BOOLEAN)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__BOOLEAN() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN( final PREGEN__SET__OF__BOOLEAN otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
		}

		private static final List<TitanBoolean> copy_list( final List<TitanBoolean> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( srcList.size() );
			for (final TitanBoolean srcElem : srcList) {
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBoolean> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BOOLEAN) {
				return operator_equals((PREGEN__SET__OF__BOOLEAN)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__BOOLEAN.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__BOOLEAN other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__BOOLEAN left_ptr, final int left_index, final PREGEN__SET__OF__BOOLEAN right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			final TitanBoolean temp_left = left_ptr.valueElements.get(left_index);
			final TitanBoolean temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__BOOLEAN otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__BOOLEAN operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BOOLEAN) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN.");
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BOOLEAN operator_assign( final PREGEN__SET__OF__BOOLEAN otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BOOLEAN operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BOOLEAN operator_concatenate(final PREGEN__SET__OF__BOOLEAN other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN concatenation.");
			}
			final PREGEN__SET__OF__BOOLEAN ret_val = new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBoolean elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BOOLEAN operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__BOOLEAN(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.
		 * */
		public PREGEN__SET__OF__BOOLEAN rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.
		 * */
		public PREGEN__SET__OF__BOOLEAN rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.
		 * */
		public PREGEN__SET__OF__BOOLEAN rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.
		 * */
		public PREGEN__SET__OF__BOOLEAN rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__BOOLEAN(this);
			}
			final PREGEN__SET__OF__BOOLEAN ret_val = new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBoolean get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBoolean temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBoolean get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBoolean constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBoolean elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBoolean constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBoolean elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBoolean>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBoolean() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBoolean get_unbound_elem() {
			return new TitanBoolean();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN","element");
			final PREGEN__SET__OF__BOOLEAN ret_val = new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBoolean(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN","element");
			final PREGEN__SET__OF__BOOLEAN ret_val = new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBoolean elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBoolean elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final int index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final TitanInteger index, final int len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBoolean temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBoolean>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBoolean temp2 = new TitanBoolean();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBoolean>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBoolean val = new TitanBoolean();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__BOOLEAN_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBoolean_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__BOOLEAN_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__BOOLEAN)value_ptr, value_index, (PREGEN__SET__OF__BOOLEAN_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanBoolean_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__BOOLEAN)value_ptr, value_index, (PREGEN__SET__OF__BOOLEAN_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__BOOLEAN_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__BOOLEAN)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__BOOLEAN_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__BOOLEAN)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template( final PREGEN__SET__OF__BOOLEAN otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template( final PREGEN__SET__OF__BOOLEAN_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__BOOLEAN_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template( final Optional<PREGEN__SET__OF__BOOLEAN> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBoolean_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__BOOLEAN other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN with an unbound value.");
			value_elements = new ArrayList<TitanBoolean_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBoolean_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__BOOLEAN_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBoolean_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__BOOLEAN_template temp = new PREGEN__SET__OF__BOOLEAN_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBoolean_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__BOOLEAN_template temp = new PREGEN__SET__OF__BOOLEAN_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanBoolean_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__BOOLEAN other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__BOOLEAN other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__BOOLEAN value_ptr, final int value_index, final PREGEN__SET__OF__BOOLEAN_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__BOOLEAN value_ptr, final int value_index, final PREGEN__SET__OF__BOOLEAN_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN) {
				return match((PREGEN__SET__OF__BOOLEAN)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN_template operator_assign( final PREGEN__SET__OF__BOOLEAN otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN_template operator_assign( final PREGEN__SET__OF__BOOLEAN_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__BOOLEAN_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN.");
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN_template) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN_template operator_assign( final Optional<PREGEN__SET__OF__BOOLEAN> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBoolean_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBoolean_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBoolean_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return set_items.size();
		}
		@Override
		public TitanBoolean_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBoolean_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BOOLEAN.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBoolean_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__BOOLEAN containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BOOLEAN.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__BOOLEAN_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBoolean_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanBoolean_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__BOOLEAN_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__BOOLEAN_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
			final PREGEN__SET__OF__BOOLEAN ret_val = new PREGEN__SET__OF__BOOLEAN(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBoolean_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__BOOLEAN match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__BOOLEAN) {
				log_match((PREGEN__SET__OF__BOOLEAN)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__BOOLEAN match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
				}
				value_elements = new ArrayList<TitanBoolean_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBoolean_template temp2 = new TitanBoolean_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__BOOLEAN_template temp2 = new PREGEN__SET__OF__BOOLEAN_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN" : name));
		}
	}
	public static class PREGEN__SET__OF__FLOAT__OPTIMIZED extends Record_Of_Type {

		protected List<TitanFloat> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__FLOAT__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__FLOAT__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED( final PREGEN__SET__OF__FLOAT__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
		}

		private static final List<TitanFloat> copy_list( final List<TitanFloat> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanFloat> newList = new ArrayList<TitanFloat>( srcList.size() );
			for (final TitanFloat srcElem : srcList) {
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanFloat> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanFloat> newList = new ArrayList<TitanFloat>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__FLOAT__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__FLOAT__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__FLOAT__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__FLOAT__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__FLOAT__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			final TitanFloat temp_left = left_ptr.valueElements.get(left_index);
			final TitanFloat temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__FLOAT__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__FLOAT__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_assign( final PREGEN__SET__OF__FLOAT__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__FLOAT__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanFloat elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__FLOAT__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__FLOAT__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanFloat get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanFloat temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanFloat get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanFloat constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanFloat elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanFloat constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanFloat elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanFloat>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanFloat() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanFloat get_unbound_elem() {
			return new TitanFloat();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED","element");
			final PREGEN__SET__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanFloat(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__FLOAT__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED","element");
			final PREGEN__SET__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanFloat elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanFloat elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanFloat temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanFloat>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanFloat temp2 = new TitanFloat();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanFloat>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanFloat val = new TitanFloat();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__FLOAT__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanFloat_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__FLOAT__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__FLOAT__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__FLOAT__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanFloat_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__FLOAT__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__FLOAT__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__FLOAT__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__FLOAT__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__FLOAT__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__FLOAT__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template( final PREGEN__SET__OF__FLOAT__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template( final PREGEN__SET__OF__FLOAT__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template( final Optional<PREGEN__SET__OF__FLOAT__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanFloat_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__FLOAT__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanFloat_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanFloat_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__FLOAT__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanFloat_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__FLOAT__OPTIMIZED_template temp = new PREGEN__SET__OF__FLOAT__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanFloat_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanFloat_template temp = new TitanFloat_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__FLOAT__OPTIMIZED_template temp = new PREGEN__SET__OF__FLOAT__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanFloat_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__FLOAT__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__FLOAT__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__FLOAT__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__FLOAT__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED) {
				return match((PREGEN__SET__OF__FLOAT__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__FLOAT__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__FLOAT__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__FLOAT__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__FLOAT__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__FLOAT__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanFloat_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__FLOAT__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanFloat_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanFloat_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanFloat_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanFloat_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__FLOAT__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanFloat_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__FLOAT__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__FLOAT__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanFloat_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanFloat_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__FLOAT__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
			final PREGEN__SET__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__SET__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanFloat_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__FLOAT__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__FLOAT__OPTIMIZED) {
				log_match((PREGEN__SET__OF__FLOAT__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__FLOAT__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanFloat_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanFloat_template temp2 = new TitanFloat_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__FLOAT__OPTIMIZED_template temp2 = new PREGEN__SET__OF__FLOAT__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_FLOAT_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__INTEGER extends Record_Of_Type {

		protected List<TitanInteger> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__INTEGER)left_ptr, left_index, (PREGEN__SET__OF__INTEGER)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__INTEGER() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER( final PREGEN__SET__OF__INTEGER otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
		}

		private static final List<TitanInteger> copy_list( final List<TitanInteger> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanInteger> newList = new ArrayList<TitanInteger>( srcList.size() );
			for (final TitanInteger srcElem : srcList) {
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanInteger> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanInteger> newList = new ArrayList<TitanInteger>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__INTEGER) {
				return operator_equals((PREGEN__SET__OF__INTEGER)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__INTEGER.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__INTEGER other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__INTEGER left_ptr, final int left_index, final PREGEN__SET__OF__INTEGER right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			final TitanInteger temp_left = left_ptr.valueElements.get(left_index);
			final TitanInteger temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__INTEGER otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__INTEGER operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__INTEGER) {
				return operator_assign((PREGEN__SET__OF__INTEGER)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER.");
		}

		@Override
		public PREGEN__SET__OF__INTEGER operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__INTEGER operator_assign( final PREGEN__SET__OF__INTEGER otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__INTEGER operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__INTEGER operator_concatenate(final PREGEN__SET__OF__INTEGER other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_INTEGER concatenation.");
			}
			final PREGEN__SET__OF__INTEGER ret_val = new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanInteger elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__INTEGER operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__INTEGER(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER.
		 * */
		public PREGEN__SET__OF__INTEGER rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER.
		 * */
		public PREGEN__SET__OF__INTEGER rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER.
		 * */
		public PREGEN__SET__OF__INTEGER rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER.
		 * */
		public PREGEN__SET__OF__INTEGER rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__INTEGER(this);
			}
			final PREGEN__SET__OF__INTEGER ret_val = new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanInteger get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanInteger temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanInteger get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanInteger constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanInteger elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanInteger constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanInteger elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanInteger>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanInteger() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanInteger get_unbound_elem() {
			return new TitanInteger();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_INTEGER","element");
			final PREGEN__SET__OF__INTEGER ret_val = new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanInteger(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final int index, final int len, final PREGEN__SET__OF__INTEGER repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_INTEGER","element");
			final PREGEN__SET__OF__INTEGER ret_val = new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanInteger elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanInteger elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final int index, final int len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final int index, final TitanInteger len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final TitanInteger index, final int len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanInteger temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanInteger>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanInteger temp2 = new TitanInteger();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanInteger>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanInteger val = new TitanInteger();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__INTEGER_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanInteger_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__INTEGER_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__INTEGER)value_ptr, value_index, (PREGEN__SET__OF__INTEGER_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanInteger_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__INTEGER)value_ptr, value_index, (PREGEN__SET__OF__INTEGER_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__INTEGER_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__INTEGER)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__INTEGER_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__INTEGER)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__INTEGER_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER_template( final PREGEN__SET__OF__INTEGER otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER_template( final PREGEN__SET__OF__INTEGER_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__INTEGER_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER_template( final Optional<PREGEN__SET__OF__INTEGER> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__INTEGER_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanInteger_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__INTEGER other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER with an unbound value.");
			value_elements = new ArrayList<TitanInteger_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanInteger_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__INTEGER_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanInteger_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__INTEGER_template temp = new PREGEN__SET__OF__INTEGER_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanInteger_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanInteger_template temp = new TitanInteger_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__INTEGER_template temp = new PREGEN__SET__OF__INTEGER_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanInteger_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__INTEGER other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__INTEGER other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__INTEGER value_ptr, final int value_index, final PREGEN__SET__OF__INTEGER_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__INTEGER value_ptr, final int value_index, final PREGEN__SET__OF__INTEGER_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER) {
				return match((PREGEN__SET__OF__INTEGER)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__INTEGER_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER_template operator_assign( final PREGEN__SET__OF__INTEGER otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER_template operator_assign( final PREGEN__SET__OF__INTEGER_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__INTEGER_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__INTEGER_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER) {
				return operator_assign((PREGEN__SET__OF__INTEGER)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER.");
		}

		@Override
		public PREGEN__SET__OF__INTEGER_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER_template) {
				return operator_assign((PREGEN__SET__OF__INTEGER_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER_template operator_assign( final Optional<PREGEN__SET__OF__INTEGER> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanInteger_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final int index, final int len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final int index, final int len, final PREGEN__SET__OF__INTEGER repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanInteger_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanInteger_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return set_items.size();
		}
		@Override
		public TitanInteger_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanInteger_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__INTEGER.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanInteger_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__INTEGER containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__INTEGER.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__INTEGER_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanInteger_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanInteger_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__INTEGER_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__INTEGER_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__INTEGER valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
			final PREGEN__SET__OF__INTEGER ret_val = new PREGEN__SET__OF__INTEGER(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanInteger_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__INTEGER match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__INTEGER) {
				log_match((PREGEN__SET__OF__INTEGER)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__INTEGER match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
				}
				value_elements = new ArrayList<TitanInteger_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanInteger_template temp2 = new TitanInteger_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__INTEGER_template temp2 = new PREGEN__SET__OF__INTEGER_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_INTEGER" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_INTEGER" : name));
		}
	}
	public static class PREGEN__SET__OF__CHARSTRING extends Record_Of_Type {

		protected List<TitanCharString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__CHARSTRING)left_ptr, left_index, (PREGEN__SET__OF__CHARSTRING)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__CHARSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING( final PREGEN__SET__OF__CHARSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copy_list( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanCharString> newList = new ArrayList<TitanCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__CHARSTRING) {
				return operator_equals((PREGEN__SET__OF__CHARSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__CHARSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__CHARSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__CHARSTRING left_ptr, final int left_index, final PREGEN__SET__OF__CHARSTRING right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			final TitanCharString temp_left = left_ptr.valueElements.get(left_index);
			final TitanCharString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__CHARSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__CHARSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__CHARSTRING) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING.");
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__CHARSTRING operator_assign( final PREGEN__SET__OF__CHARSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__CHARSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__CHARSTRING operator_concatenate(final PREGEN__SET__OF__CHARSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING concatenation.");
			}
			final PREGEN__SET__OF__CHARSTRING ret_val = new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__CHARSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__CHARSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.
		 * */
		public PREGEN__SET__OF__CHARSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.
		 * */
		public PREGEN__SET__OF__CHARSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.
		 * */
		public PREGEN__SET__OF__CHARSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.
		 * */
		public PREGEN__SET__OF__CHARSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__CHARSTRING(this);
			}
			final PREGEN__SET__OF__CHARSTRING ret_val = new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString get_unbound_elem() {
			return new TitanCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING","element");
			final PREGEN__SET__OF__CHARSTRING ret_val = new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING","element");
			final PREGEN__SET__OF__CHARSTRING ret_val = new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final int index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final TitanInteger index, final int len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanCharString val = new TitanCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__CHARSTRING_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__CHARSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__CHARSTRING)value_ptr, value_index, (PREGEN__SET__OF__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanCharString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__CHARSTRING)value_ptr, value_index, (PREGEN__SET__OF__CHARSTRING_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__CHARSTRING_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__CHARSTRING)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__CHARSTRING_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__CHARSTRING)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template( final PREGEN__SET__OF__CHARSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template( final PREGEN__SET__OF__CHARSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__CHARSTRING_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template( final Optional<PREGEN__SET__OF__CHARSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__CHARSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING with an unbound value.");
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__CHARSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__CHARSTRING_template temp = new PREGEN__SET__OF__CHARSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanCharString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanCharString_template temp = new TitanCharString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__CHARSTRING_template temp = new PREGEN__SET__OF__CHARSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanCharString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__CHARSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__CHARSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__CHARSTRING value_ptr, final int value_index, final PREGEN__SET__OF__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__CHARSTRING value_ptr, final int value_index, final PREGEN__SET__OF__CHARSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING) {
				return match((PREGEN__SET__OF__CHARSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING_template operator_assign( final PREGEN__SET__OF__CHARSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING_template operator_assign( final PREGEN__SET__OF__CHARSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__CHARSTRING_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING.");
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING_template) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING_template operator_assign( final Optional<PREGEN__SET__OF__CHARSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return set_items.size();
		}
		@Override
		public TitanCharString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__CHARSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__CHARSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__CHARSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__CHARSTRING_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanCharString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanCharString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__CHARSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__CHARSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
			final PREGEN__SET__OF__CHARSTRING ret_val = new PREGEN__SET__OF__CHARSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__CHARSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__CHARSTRING) {
				log_match((PREGEN__SET__OF__CHARSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__CHARSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__CHARSTRING_template temp2 = new PREGEN__SET__OF__CHARSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanUniversalCharString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
		}

		private static final List<TitanUniversalCharString> copy_list( final List<TitanUniversalCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( srcList.size() );
			for (final TitanUniversalCharString srcElem : srcList) {
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanUniversalCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanUniversalCharString> newList = new ArrayList<TitanUniversalCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanUniversalCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanUniversalCharString leftElem = valueElements.get( i );
				final TitanUniversalCharString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanUniversalCharString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanUniversalCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanUniversalCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanUniversalCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanUniversalCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanUniversalCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanUniversalCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanUniversalCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanUniversalCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanUniversalCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanUniversalCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanUniversalCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanUniversalCharString get_unbound_elem() {
			return new TitanUniversalCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanUniversalCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanUniversalCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanUniversalCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanUniversalCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanUniversalCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanUniversalCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanUniversalCharString temp2 = new TitanUniversalCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanUniversalCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanUniversalCharString val = new TitanUniversalCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanUniversalCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanUniversalCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanUniversalCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanUniversalCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanUniversalCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanUniversalCharString_template temp = new TitanUniversalCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanUniversalCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanUniversalCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanUniversalCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanUniversalCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanUniversalCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanUniversalCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanUniversalCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanUniversalCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanUniversalCharString_template temp2 = new TitanUniversalCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_UNIVERSAL_CHARSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__HEXSTRING extends Record_Of_Type {

		protected List<TitanHexString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__HEXSTRING)left_ptr, left_index, (PREGEN__SET__OF__HEXSTRING)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__HEXSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING( final PREGEN__SET__OF__HEXSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
		}

		private static final List<TitanHexString> copy_list( final List<TitanHexString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanHexString> newList = new ArrayList<TitanHexString>( srcList.size() );
			for (final TitanHexString srcElem : srcList) {
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanHexString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanHexString> newList = new ArrayList<TitanHexString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__HEXSTRING) {
				return operator_equals((PREGEN__SET__OF__HEXSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__HEXSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__HEXSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__HEXSTRING left_ptr, final int left_index, final PREGEN__SET__OF__HEXSTRING right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			final TitanHexString temp_left = left_ptr.valueElements.get(left_index);
			final TitanHexString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__HEXSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__HEXSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__HEXSTRING) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING.");
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__HEXSTRING operator_assign( final PREGEN__SET__OF__HEXSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__HEXSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__HEXSTRING operator_concatenate(final PREGEN__SET__OF__HEXSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING concatenation.");
			}
			final PREGEN__SET__OF__HEXSTRING ret_val = new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanHexString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__HEXSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__HEXSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.
		 * */
		public PREGEN__SET__OF__HEXSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.
		 * */
		public PREGEN__SET__OF__HEXSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.
		 * */
		public PREGEN__SET__OF__HEXSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.
		 * */
		public PREGEN__SET__OF__HEXSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__HEXSTRING(this);
			}
			final PREGEN__SET__OF__HEXSTRING ret_val = new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanHexString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanHexString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanHexString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanHexString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanHexString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanHexString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanHexString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanHexString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanHexString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanHexString get_unbound_elem() {
			return new TitanHexString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING","element");
			final PREGEN__SET__OF__HEXSTRING ret_val = new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanHexString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING","element");
			final PREGEN__SET__OF__HEXSTRING ret_val = new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanHexString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanHexString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final int index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final TitanInteger index, final int len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanHexString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanHexString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanHexString temp2 = new TitanHexString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanHexString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanHexString val = new TitanHexString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__HEXSTRING_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanHexString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__HEXSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__HEXSTRING)value_ptr, value_index, (PREGEN__SET__OF__HEXSTRING_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanHexString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__HEXSTRING)value_ptr, value_index, (PREGEN__SET__OF__HEXSTRING_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__HEXSTRING_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__HEXSTRING)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__HEXSTRING_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__HEXSTRING)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template( final PREGEN__SET__OF__HEXSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template( final PREGEN__SET__OF__HEXSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__HEXSTRING_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template( final Optional<PREGEN__SET__OF__HEXSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanHexString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__HEXSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING with an unbound value.");
			value_elements = new ArrayList<TitanHexString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanHexString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__HEXSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanHexString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__HEXSTRING_template temp = new PREGEN__SET__OF__HEXSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanHexString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanHexString_template temp = new TitanHexString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__HEXSTRING_template temp = new PREGEN__SET__OF__HEXSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanHexString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__HEXSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__HEXSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__HEXSTRING value_ptr, final int value_index, final PREGEN__SET__OF__HEXSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__HEXSTRING value_ptr, final int value_index, final PREGEN__SET__OF__HEXSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING) {
				return match((PREGEN__SET__OF__HEXSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING_template operator_assign( final PREGEN__SET__OF__HEXSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING_template operator_assign( final PREGEN__SET__OF__HEXSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__HEXSTRING_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING.");
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING_template) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING_template operator_assign( final Optional<PREGEN__SET__OF__HEXSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanHexString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanHexString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanHexString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return set_items.size();
		}
		@Override
		public TitanHexString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanHexString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__HEXSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanHexString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__HEXSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__HEXSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__HEXSTRING_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanHexString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanHexString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__HEXSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__HEXSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
			final PREGEN__SET__OF__HEXSTRING ret_val = new PREGEN__SET__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanHexString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__HEXSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__HEXSTRING) {
				log_match((PREGEN__SET__OF__HEXSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__HEXSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
				}
				value_elements = new ArrayList<TitanHexString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanHexString_template temp2 = new TitanHexString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__HEXSTRING_template temp2 = new PREGEN__SET__OF__HEXSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING" : name));
		}
	}
	public static class PREGEN__SET__OF__HEXSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanHexString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__HEXSTRING__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
		}

		private static final List<TitanHexString> copy_list( final List<TitanHexString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanHexString> newList = new ArrayList<TitanHexString>( srcList.size() );
			for (final TitanHexString srcElem : srcList) {
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanHexString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanHexString> newList = new ArrayList<TitanHexString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			final TitanHexString temp_left = left_ptr.valueElements.get(left_index);
			final TitanHexString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_assign( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanHexString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanHexString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanHexString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanHexString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanHexString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanHexString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanHexString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanHexString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanHexString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanHexString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanHexString get_unbound_elem() {
			return new TitanHexString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanHexString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanHexString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanHexString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanHexString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanHexString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanHexString temp2 = new TitanHexString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanHexString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanHexString val = new TitanHexString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanHexString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanHexString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template( final Optional<PREGEN__SET__OF__HEXSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanHexString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanHexString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanHexString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanHexString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanHexString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanHexString_template temp = new TitanHexString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanHexString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED) {
				return match((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__HEXSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanHexString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__HEXSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanHexString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanHexString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanHexString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanHexString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanHexString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanHexString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanHexString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
			final PREGEN__SET__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanHexString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__HEXSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__HEXSTRING__OPTIMIZED) {
				log_match((PREGEN__SET__OF__HEXSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__HEXSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanHexString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanHexString_template temp2 = new TitanHexString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template temp2 = new PREGEN__SET__OF__HEXSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_HEXSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__OCTETSTRING extends Record_Of_Type {

		protected List<TitanOctetString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__OCTETSTRING)left_ptr, left_index, (PREGEN__SET__OF__OCTETSTRING)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING( final PREGEN__SET__OF__OCTETSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
		}

		private static final List<TitanOctetString> copy_list( final List<TitanOctetString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( srcList.size() );
			for (final TitanOctetString srcElem : srcList) {
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanOctetString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__OCTETSTRING) {
				return operator_equals((PREGEN__SET__OF__OCTETSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__OCTETSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__OCTETSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__OCTETSTRING left_ptr, final int left_index, final PREGEN__SET__OF__OCTETSTRING right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			final TitanOctetString temp_left = left_ptr.valueElements.get(left_index);
			final TitanOctetString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__OCTETSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__OCTETSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__OCTETSTRING) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING.");
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__OCTETSTRING operator_assign( final PREGEN__SET__OF__OCTETSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__OCTETSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING operator_concatenate(final PREGEN__SET__OF__OCTETSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING concatenation.");
			}
			final PREGEN__SET__OF__OCTETSTRING ret_val = new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanOctetString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__OCTETSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.
		 * */
		public PREGEN__SET__OF__OCTETSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.
		 * */
		public PREGEN__SET__OF__OCTETSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.
		 * */
		public PREGEN__SET__OF__OCTETSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.
		 * */
		public PREGEN__SET__OF__OCTETSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__OCTETSTRING(this);
			}
			final PREGEN__SET__OF__OCTETSTRING ret_val = new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanOctetString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanOctetString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanOctetString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanOctetString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanOctetString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanOctetString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanOctetString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanOctetString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanOctetString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanOctetString get_unbound_elem() {
			return new TitanOctetString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING","element");
			final PREGEN__SET__OF__OCTETSTRING ret_val = new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanOctetString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING","element");
			final PREGEN__SET__OF__OCTETSTRING ret_val = new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanOctetString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanOctetString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final int index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final TitanInteger index, final int len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanOctetString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanOctetString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanOctetString temp2 = new TitanOctetString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanOctetString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanOctetString val = new TitanOctetString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__OCTETSTRING_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanOctetString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__OCTETSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__OCTETSTRING)value_ptr, value_index, (PREGEN__SET__OF__OCTETSTRING_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanOctetString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__OCTETSTRING)value_ptr, value_index, (PREGEN__SET__OF__OCTETSTRING_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__OCTETSTRING_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__OCTETSTRING)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__OCTETSTRING_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__OCTETSTRING)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template( final PREGEN__SET__OF__OCTETSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template( final PREGEN__SET__OF__OCTETSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__OCTETSTRING_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template( final Optional<PREGEN__SET__OF__OCTETSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanOctetString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__OCTETSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING with an unbound value.");
			value_elements = new ArrayList<TitanOctetString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanOctetString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__OCTETSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanOctetString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__OCTETSTRING_template temp = new PREGEN__SET__OF__OCTETSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanOctetString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__OCTETSTRING_template temp = new PREGEN__SET__OF__OCTETSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanOctetString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__OCTETSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__OCTETSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__OCTETSTRING value_ptr, final int value_index, final PREGEN__SET__OF__OCTETSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__OCTETSTRING value_ptr, final int value_index, final PREGEN__SET__OF__OCTETSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING) {
				return match((PREGEN__SET__OF__OCTETSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign( final PREGEN__SET__OF__OCTETSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign( final PREGEN__SET__OF__OCTETSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__OCTETSTRING_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING.");
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING_template) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign( final Optional<PREGEN__SET__OF__OCTETSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanOctetString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanOctetString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanOctetString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return set_items.size();
		}
		@Override
		public TitanOctetString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanOctetString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__OCTETSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanOctetString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__OCTETSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__OCTETSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__OCTETSTRING_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanOctetString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanOctetString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__OCTETSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__OCTETSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
			final PREGEN__SET__OF__OCTETSTRING ret_val = new PREGEN__SET__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanOctetString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__OCTETSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__OCTETSTRING) {
				log_match((PREGEN__SET__OF__OCTETSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__OCTETSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
				}
				value_elements = new ArrayList<TitanOctetString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanOctetString_template temp2 = new TitanOctetString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__OCTETSTRING_template temp2 = new PREGEN__SET__OF__OCTETSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING" : name));
		}
	}
	public static class PREGEN__SET__OF__FLOAT extends Record_Of_Type {

		protected List<TitanFloat> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__FLOAT)left_ptr, left_index, (PREGEN__SET__OF__FLOAT)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__FLOAT() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT( final PREGEN__SET__OF__FLOAT otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
		}

		private static final List<TitanFloat> copy_list( final List<TitanFloat> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanFloat> newList = new ArrayList<TitanFloat>( srcList.size() );
			for (final TitanFloat srcElem : srcList) {
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanFloat> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanFloat> newList = new ArrayList<TitanFloat>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__FLOAT) {
				return operator_equals((PREGEN__SET__OF__FLOAT)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__FLOAT.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__FLOAT other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__FLOAT left_ptr, final int left_index, final PREGEN__SET__OF__FLOAT right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			final TitanFloat temp_left = left_ptr.valueElements.get(left_index);
			final TitanFloat temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__FLOAT otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__FLOAT operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__FLOAT) {
				return operator_assign((PREGEN__SET__OF__FLOAT)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT.");
		}

		@Override
		public PREGEN__SET__OF__FLOAT operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__FLOAT operator_assign( final PREGEN__SET__OF__FLOAT otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__FLOAT operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__FLOAT operator_concatenate(final PREGEN__SET__OF__FLOAT other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_FLOAT concatenation.");
			}
			final PREGEN__SET__OF__FLOAT ret_val = new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanFloat elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__FLOAT operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__FLOAT(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT.
		 * */
		public PREGEN__SET__OF__FLOAT rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT.
		 * */
		public PREGEN__SET__OF__FLOAT rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT.
		 * */
		public PREGEN__SET__OF__FLOAT rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_FLOAT, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_FLOAT.
		 * */
		public PREGEN__SET__OF__FLOAT rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__FLOAT(this);
			}
			final PREGEN__SET__OF__FLOAT ret_val = new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanFloat get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanFloat temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanFloat get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanFloat constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanFloat elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanFloat constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanFloat elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanFloat>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanFloat() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanFloat get_unbound_elem() {
			return new TitanFloat();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_FLOAT","element");
			final PREGEN__SET__OF__FLOAT ret_val = new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanFloat(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final int index, final int len, final PREGEN__SET__OF__FLOAT repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_FLOAT","element");
			final PREGEN__SET__OF__FLOAT ret_val = new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanFloat elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanFloat elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final int index, final int len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final int index, final TitanInteger len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final TitanInteger index, final int len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanFloat temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanFloat>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanFloat temp2 = new TitanFloat();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanFloat>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanFloat val = new TitanFloat();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__FLOAT_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanFloat_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__FLOAT_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__FLOAT)value_ptr, value_index, (PREGEN__SET__OF__FLOAT_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanFloat_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__FLOAT)value_ptr, value_index, (PREGEN__SET__OF__FLOAT_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__FLOAT_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__FLOAT)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__FLOAT_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__FLOAT)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__FLOAT_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT_template( final PREGEN__SET__OF__FLOAT otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT_template( final PREGEN__SET__OF__FLOAT_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__FLOAT_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__FLOAT_template( final Optional<PREGEN__SET__OF__FLOAT> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__FLOAT_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanFloat_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__FLOAT other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT with an unbound value.");
			value_elements = new ArrayList<TitanFloat_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanFloat_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__FLOAT_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanFloat_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__FLOAT_template temp = new PREGEN__SET__OF__FLOAT_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanFloat_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanFloat_template temp = new TitanFloat_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__FLOAT_template temp = new PREGEN__SET__OF__FLOAT_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanFloat_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__FLOAT other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__FLOAT other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__FLOAT value_ptr, final int value_index, final PREGEN__SET__OF__FLOAT_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__FLOAT value_ptr, final int value_index, final PREGEN__SET__OF__FLOAT_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT) {
				return match((PREGEN__SET__OF__FLOAT)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__FLOAT_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT_template operator_assign( final PREGEN__SET__OF__FLOAT otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT_template operator_assign( final PREGEN__SET__OF__FLOAT_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__FLOAT_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__FLOAT_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT) {
				return operator_assign((PREGEN__SET__OF__FLOAT)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT.");
		}

		@Override
		public PREGEN__SET__OF__FLOAT_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__FLOAT_template) {
				return operator_assign((PREGEN__SET__OF__FLOAT_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__FLOAT_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT_template operator_assign( final Optional<PREGEN__SET__OF__FLOAT> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__FLOAT_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanFloat_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final int index, final int len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final int index, final int len, final PREGEN__SET__OF__FLOAT repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__FLOAT repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanFloat_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanFloat_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return set_items.size();
		}
		@Override
		public TitanFloat_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanFloat_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__FLOAT.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanFloat_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__FLOAT containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__FLOAT.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__FLOAT_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanFloat_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanFloat_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__FLOAT_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__FLOAT_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__FLOAT valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
			final PREGEN__SET__OF__FLOAT ret_val = new PREGEN__SET__OF__FLOAT(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanFloat_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__FLOAT substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__FLOAT match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__FLOAT) {
				log_match((PREGEN__SET__OF__FLOAT)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__FLOAT match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
				}
				value_elements = new ArrayList<TitanFloat_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanFloat_template temp2 = new TitanFloat_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__FLOAT_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__FLOAT_template temp2 = new PREGEN__SET__OF__FLOAT_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_FLOAT.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_FLOAT");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_FLOAT" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_FLOAT" : name));
		}
	}
	public static class PREGEN__SET__OF__INTEGER__OPTIMIZED extends Record_Of_Type {

		protected List<TitanInteger> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__INTEGER__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__INTEGER__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED( final PREGEN__SET__OF__INTEGER__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
		}

		private static final List<TitanInteger> copy_list( final List<TitanInteger> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanInteger> newList = new ArrayList<TitanInteger>( srcList.size() );
			for (final TitanInteger srcElem : srcList) {
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanInteger> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanInteger> newList = new ArrayList<TitanInteger>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanInteger newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__INTEGER__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__INTEGER__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__INTEGER__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__INTEGER__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__INTEGER__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			final TitanInteger temp_left = left_ptr.valueElements.get(left_index);
			final TitanInteger temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__INTEGER__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__INTEGER__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_assign( final PREGEN__SET__OF__INTEGER__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanInteger>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__INTEGER__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanInteger elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__INTEGER__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__INTEGER__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanInteger get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanInteger temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanInteger get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanInteger constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanInteger elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanInteger constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanInteger elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanInteger>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanInteger() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanInteger get_unbound_elem() {
			return new TitanInteger();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED","element");
			final PREGEN__SET__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanInteger(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__INTEGER__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED","element");
			final PREGEN__SET__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanInteger elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanInteger elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanInteger elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanInteger(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanInteger temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanInteger>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanInteger temp2 = new TitanInteger();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanInteger>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanInteger val = new TitanInteger();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__INTEGER__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanInteger_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__INTEGER__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__INTEGER__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__INTEGER__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanInteger_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__INTEGER__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__INTEGER__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__INTEGER__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__INTEGER__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__INTEGER__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__INTEGER__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template( final PREGEN__SET__OF__INTEGER__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template( final PREGEN__SET__OF__INTEGER__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template( final Optional<PREGEN__SET__OF__INTEGER__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanInteger_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__INTEGER__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanInteger_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanInteger_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__INTEGER__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanInteger_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanInteger_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__INTEGER__OPTIMIZED_template temp = new PREGEN__SET__OF__INTEGER__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanInteger_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanInteger_template temp = new TitanInteger_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanInteger_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__INTEGER__OPTIMIZED_template temp = new PREGEN__SET__OF__INTEGER__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanInteger_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanInteger_template temp = new TitanInteger_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__INTEGER__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__INTEGER__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__INTEGER__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__INTEGER__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED) {
				return match((PREGEN__SET__OF__INTEGER__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__INTEGER__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__INTEGER__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__INTEGER__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__INTEGER__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__INTEGER__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__INTEGER__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanInteger_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__INTEGER__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__INTEGER__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanInteger_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanInteger_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanInteger_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanInteger_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanInteger_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanInteger_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__INTEGER__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanInteger_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__INTEGER__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__INTEGER__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__INTEGER__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanInteger_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanInteger_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__INTEGER__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
			final PREGEN__SET__OF__INTEGER__OPTIMIZED ret_val = new PREGEN__SET__OF__INTEGER__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanInteger_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__INTEGER__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__INTEGER__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__INTEGER__OPTIMIZED) {
				log_match((PREGEN__SET__OF__INTEGER__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__INTEGER__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanInteger_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanInteger_template temp2 = new TitanInteger_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__INTEGER__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__INTEGER__OPTIMIZED_template temp2 = new PREGEN__SET__OF__INTEGER__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_INTEGER_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanOctetString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
		}

		private static final List<TitanOctetString> copy_list( final List<TitanOctetString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( srcList.size() );
			for (final TitanOctetString srcElem : srcList) {
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanOctetString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			final TitanOctetString temp_left = left_ptr.valueElements.get(left_index);
			final TitanOctetString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_assign( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanOctetString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanOctetString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanOctetString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanOctetString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanOctetString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanOctetString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanOctetString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanOctetString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanOctetString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanOctetString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanOctetString get_unbound_elem() {
			return new TitanOctetString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanOctetString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanOctetString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanOctetString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanOctetString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanOctetString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanOctetString temp2 = new TitanOctetString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanOctetString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanOctetString val = new TitanOctetString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanOctetString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanOctetString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template( final Optional<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanOctetString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanOctetString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanOctetString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanOctetString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanOctetString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanOctetString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED) {
				return match((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanOctetString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanOctetString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanOctetString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanOctetString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanOctetString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanOctetString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__OCTETSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanOctetString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanOctetString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
			final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanOctetString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__OCTETSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__OCTETSTRING__OPTIMIZED) {
				log_match((PREGEN__SET__OF__OCTETSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanOctetString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanOctetString_template temp2 = new TitanOctetString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template temp2 = new PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_OCTETSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__OCTETSTRING extends Record_Of_Type {

		protected List<TitanOctetString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING( final PREGEN__RECORD__OF__OCTETSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
		}

		private static final List<TitanOctetString> copy_list( final List<TitanOctetString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( srcList.size() );
			for (final TitanOctetString srcElem : srcList) {
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanOctetString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanOctetString> newList = new ArrayList<TitanOctetString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanOctetString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__OCTETSTRING) {
				return operator_equals((PREGEN__RECORD__OF__OCTETSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__OCTETSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__OCTETSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanOctetString leftElem = valueElements.get( i );
				final TitanOctetString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanOctetString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__OCTETSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__OCTETSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__OCTETSTRING) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING operator_assign( final PREGEN__RECORD__OF__OCTETSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanOctetString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING operator_concatenate(final PREGEN__RECORD__OF__OCTETSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING concatenation.");
			}
			final PREGEN__RECORD__OF__OCTETSTRING ret_val = new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanOctetString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__OCTETSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__OCTETSTRING(this);
			}
			final PREGEN__RECORD__OF__OCTETSTRING ret_val = new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanOctetString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanOctetString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanOctetString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanOctetString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanOctetString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanOctetString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanOctetString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanOctetString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanOctetString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanOctetString get_unbound_elem() {
			return new TitanOctetString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING","element");
			final PREGEN__RECORD__OF__OCTETSTRING ret_val = new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanOctetString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING","element");
			final PREGEN__RECORD__OF__OCTETSTRING ret_val = new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanOctetString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanOctetString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanOctetString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanOctetString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanOctetString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanOctetString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanOctetString temp2 = new TitanOctetString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanOctetString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanOctetString val = new TitanOctetString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__OCTETSTRING_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanOctetString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__OCTETSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__OCTETSTRING)value_ptr, value_index, (PREGEN__RECORD__OF__OCTETSTRING_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template( final PREGEN__RECORD__OF__OCTETSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template( final PREGEN__RECORD__OF__OCTETSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__OCTETSTRING_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template( final Optional<PREGEN__RECORD__OF__OCTETSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanOctetString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__OCTETSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING with an unbound value.");
			value_elements = new ArrayList<TitanOctetString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanOctetString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__OCTETSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanOctetString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanOctetString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__OCTETSTRING_template temp = new PREGEN__RECORD__OF__OCTETSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanOctetString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanOctetString_template temp = new TitanOctetString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__OCTETSTRING_template temp = new PREGEN__RECORD__OF__OCTETSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__OCTETSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__OCTETSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__OCTETSTRING value_ptr, final int value_index, final PREGEN__RECORD__OF__OCTETSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING) {
				return match((PREGEN__RECORD__OF__OCTETSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign( final PREGEN__RECORD__OF__OCTETSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign( final PREGEN__RECORD__OF__OCTETSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__OCTETSTRING_template) {
				return operator_assign((PREGEN__RECORD__OF__OCTETSTRING_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__OCTETSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign( final Optional<PREGEN__RECORD__OF__OCTETSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__OCTETSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanOctetString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__OCTETSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__OCTETSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanOctetString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanOctetString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanOctetString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanOctetString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanOctetString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__OCTETSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanOctetString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__OCTETSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__OCTETSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__OCTETSTRING_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__OCTETSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__OCTETSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
			final PREGEN__RECORD__OF__OCTETSTRING ret_val = new PREGEN__RECORD__OF__OCTETSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanOctetString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__OCTETSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__OCTETSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__OCTETSTRING) {
				log_match((PREGEN__RECORD__OF__OCTETSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__OCTETSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
				}
				value_elements = new ArrayList<TitanOctetString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanOctetString_template temp2 = new TitanOctetString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__OCTETSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__OCTETSTRING_template temp2 = new PREGEN__RECORD__OF__OCTETSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_OCTETSTRING" : name));
		}
	}
	public static class PREGEN__RECORD__OF__HEXSTRING extends Record_Of_Type {

		protected List<TitanHexString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING( final PREGEN__RECORD__OF__HEXSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
		}

		private static final List<TitanHexString> copy_list( final List<TitanHexString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanHexString> newList = new ArrayList<TitanHexString>( srcList.size() );
			for (final TitanHexString srcElem : srcList) {
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanHexString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanHexString> newList = new ArrayList<TitanHexString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__HEXSTRING) {
				return operator_equals((PREGEN__RECORD__OF__HEXSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__HEXSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__HEXSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanHexString leftElem = valueElements.get( i );
				final TitanHexString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanHexString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__HEXSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__HEXSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__HEXSTRING) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING operator_assign( final PREGEN__RECORD__OF__HEXSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING operator_concatenate(final PREGEN__RECORD__OF__HEXSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING concatenation.");
			}
			final PREGEN__RECORD__OF__HEXSTRING ret_val = new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanHexString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__HEXSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__HEXSTRING(this);
			}
			final PREGEN__RECORD__OF__HEXSTRING ret_val = new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanHexString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanHexString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanHexString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanHexString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanHexString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanHexString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanHexString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanHexString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanHexString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanHexString get_unbound_elem() {
			return new TitanHexString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING","element");
			final PREGEN__RECORD__OF__HEXSTRING ret_val = new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanHexString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING","element");
			final PREGEN__RECORD__OF__HEXSTRING ret_val = new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanHexString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanHexString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanHexString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanHexString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanHexString temp2 = new TitanHexString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanHexString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanHexString val = new TitanHexString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__HEXSTRING_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanHexString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__HEXSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__HEXSTRING)value_ptr, value_index, (PREGEN__RECORD__OF__HEXSTRING_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template( final PREGEN__RECORD__OF__HEXSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template( final PREGEN__RECORD__OF__HEXSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__HEXSTRING_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template( final Optional<PREGEN__RECORD__OF__HEXSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanHexString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__HEXSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING with an unbound value.");
			value_elements = new ArrayList<TitanHexString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanHexString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__HEXSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanHexString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__HEXSTRING_template temp = new PREGEN__RECORD__OF__HEXSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__HEXSTRING_template temp = new PREGEN__RECORD__OF__HEXSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__HEXSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__HEXSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__HEXSTRING value_ptr, final int value_index, final PREGEN__RECORD__OF__HEXSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING) {
				return match((PREGEN__RECORD__OF__HEXSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign( final PREGEN__RECORD__OF__HEXSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign( final PREGEN__RECORD__OF__HEXSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING.");
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING_template) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign( final Optional<PREGEN__RECORD__OF__HEXSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanHexString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanHexString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanHexString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanHexString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__HEXSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanHexString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__HEXSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__HEXSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__HEXSTRING_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__HEXSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
			final PREGEN__RECORD__OF__HEXSTRING ret_val = new PREGEN__RECORD__OF__HEXSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanHexString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__HEXSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__HEXSTRING) {
				log_match((PREGEN__RECORD__OF__HEXSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__HEXSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
				}
				value_elements = new ArrayList<TitanHexString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanHexString_template temp2 = new TitanHexString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__HEXSTRING_template temp2 = new PREGEN__RECORD__OF__HEXSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING" : name));
		}
	}
	public static class PREGEN__SET__OF__CHARSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanCharString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__CHARSTRING__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copy_list( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanCharString> newList = new ArrayList<TitanCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			final TitanCharString temp_left = left_ptr.valueElements.get(left_index);
			final TitanCharString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_assign( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString get_unbound_elem() {
			return new TitanCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanCharString val = new TitanCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanCharString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template( final Optional<PREGEN__SET__OF__CHARSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanCharString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanCharString_template temp = new TitanCharString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanCharString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED) {
				return match((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__CHARSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanCharString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanCharString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanCharString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
			final PREGEN__SET__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__CHARSTRING__OPTIMIZED) {
				log_match((PREGEN__SET__OF__CHARSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__CHARSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template temp2 = new PREGEN__SET__OF__CHARSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_CHARSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__BITSTRING extends Record_Of_Type {

		protected List<TitanBitString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__BITSTRING)left_ptr, left_index, (PREGEN__SET__OF__BITSTRING)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__BITSTRING() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING( final PREGEN__SET__OF__BITSTRING otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
		}

		private static final List<TitanBitString> copy_list( final List<TitanBitString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBitString> newList = new ArrayList<TitanBitString>( srcList.size() );
			for (final TitanBitString srcElem : srcList) {
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBitString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBitString> newList = new ArrayList<TitanBitString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BITSTRING) {
				return operator_equals((PREGEN__SET__OF__BITSTRING)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__BITSTRING.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__BITSTRING other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__BITSTRING left_ptr, final int left_index, final PREGEN__SET__OF__BITSTRING right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			final TitanBitString temp_left = left_ptr.valueElements.get(left_index);
			final TitanBitString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__BITSTRING otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__BITSTRING operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BITSTRING) {
				return operator_assign((PREGEN__SET__OF__BITSTRING)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING.");
		}

		@Override
		public PREGEN__SET__OF__BITSTRING operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BITSTRING operator_assign( final PREGEN__SET__OF__BITSTRING otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BITSTRING operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BITSTRING operator_concatenate(final PREGEN__SET__OF__BITSTRING other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_BITSTRING concatenation.");
			}
			final PREGEN__SET__OF__BITSTRING ret_val = new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBitString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BITSTRING operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__BITSTRING(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.
		 * */
		public PREGEN__SET__OF__BITSTRING rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.
		 * */
		public PREGEN__SET__OF__BITSTRING rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.
		 * */
		public PREGEN__SET__OF__BITSTRING rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.
		 * */
		public PREGEN__SET__OF__BITSTRING rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__BITSTRING(this);
			}
			final PREGEN__SET__OF__BITSTRING ret_val = new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBitString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBitString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBitString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBitString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBitString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBitString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBitString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBitString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBitString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBitString get_unbound_elem() {
			return new TitanBitString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING","element");
			final PREGEN__SET__OF__BITSTRING ret_val = new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBitString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING","element");
			final PREGEN__SET__OF__BITSTRING ret_val = new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBitString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBitString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final int index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final TitanInteger index, final int len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBitString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBitString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBitString temp2 = new TitanBitString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBitString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBitString val = new TitanBitString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__BITSTRING_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBitString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__BITSTRING_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__BITSTRING)value_ptr, value_index, (PREGEN__SET__OF__BITSTRING_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanBitString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__BITSTRING)value_ptr, value_index, (PREGEN__SET__OF__BITSTRING_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__BITSTRING_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__BITSTRING)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__BITSTRING_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__BITSTRING)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__BITSTRING_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING_template( final PREGEN__SET__OF__BITSTRING otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING_template( final PREGEN__SET__OF__BITSTRING_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__BITSTRING_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING_template( final Optional<PREGEN__SET__OF__BITSTRING> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__BITSTRING_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBitString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__BITSTRING other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING with an unbound value.");
			value_elements = new ArrayList<TitanBitString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBitString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__BITSTRING_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBitString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__BITSTRING_template temp = new PREGEN__SET__OF__BITSTRING_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBitString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanBitString_template temp = new TitanBitString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__BITSTRING_template temp = new PREGEN__SET__OF__BITSTRING_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanBitString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__BITSTRING other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__BITSTRING other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__BITSTRING value_ptr, final int value_index, final PREGEN__SET__OF__BITSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__BITSTRING value_ptr, final int value_index, final PREGEN__SET__OF__BITSTRING_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING) {
				return match((PREGEN__SET__OF__BITSTRING)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__BITSTRING_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING_template operator_assign( final PREGEN__SET__OF__BITSTRING otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING_template operator_assign( final PREGEN__SET__OF__BITSTRING_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__BITSTRING_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__BITSTRING_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING) {
				return operator_assign((PREGEN__SET__OF__BITSTRING)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING.");
		}

		@Override
		public PREGEN__SET__OF__BITSTRING_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING_template) {
				return operator_assign((PREGEN__SET__OF__BITSTRING_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING_template operator_assign( final Optional<PREGEN__SET__OF__BITSTRING> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBitString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBitString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBitString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return set_items.size();
		}
		@Override
		public TitanBitString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBitString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BITSTRING.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBitString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__BITSTRING containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BITSTRING.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__BITSTRING_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBitString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanBitString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__BITSTRING_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__BITSTRING_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__BITSTRING valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
			final PREGEN__SET__OF__BITSTRING ret_val = new PREGEN__SET__OF__BITSTRING(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBitString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__BITSTRING match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__BITSTRING) {
				log_match((PREGEN__SET__OF__BITSTRING)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__BITSTRING match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
				}
				value_elements = new ArrayList<TitanBitString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBitString_template temp2 = new TitanBitString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__BITSTRING_template temp2 = new PREGEN__SET__OF__BITSTRING_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING" : name));
		}
	}
	public static class PREGEN__SET__OF__BOOLEAN__OPTIMIZED extends Record_Of_Type {

		protected List<TitanBoolean> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__BOOLEAN__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
		}

		private static final List<TitanBoolean> copy_list( final List<TitanBoolean> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( srcList.size() );
			for (final TitanBoolean srcElem : srcList) {
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBoolean> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBoolean> newList = new ArrayList<TitanBoolean>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBoolean newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			final TitanBoolean temp_left = left_ptr.valueElements.get(left_index);
			final TitanBoolean temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_assign( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBoolean>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBoolean elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBoolean get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBoolean temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBoolean get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBoolean constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBoolean elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBoolean constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBoolean elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBoolean>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBoolean() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBoolean get_unbound_elem() {
			return new TitanBoolean();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED","element");
			final PREGEN__SET__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBoolean(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED","element");
			final PREGEN__SET__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBoolean elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBoolean elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBoolean elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBoolean(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBoolean temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBoolean>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBoolean temp2 = new TitanBoolean();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBoolean>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBoolean val = new TitanBoolean();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBoolean_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanBoolean_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template( final Optional<PREGEN__SET__OF__BOOLEAN__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBoolean_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanBoolean_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBoolean_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBoolean_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBoolean_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template temp = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBoolean_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBoolean_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template temp = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanBoolean_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanBoolean_template temp = new TitanBoolean_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED) {
				return match((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__BOOLEAN__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBoolean_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BOOLEAN__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBoolean_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBoolean_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBoolean_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanBoolean_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBoolean_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBoolean_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBoolean_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BOOLEAN__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBoolean_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanBoolean_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
			final PREGEN__SET__OF__BOOLEAN__OPTIMIZED ret_val = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBoolean_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BOOLEAN__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__BOOLEAN__OPTIMIZED) {
				log_match((PREGEN__SET__OF__BOOLEAN__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__BOOLEAN__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanBoolean_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBoolean_template temp2 = new TitanBoolean_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template temp2 = new PREGEN__SET__OF__BOOLEAN__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BOOLEAN_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanCharString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copy_list( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanCharString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanCharString> newList = new ArrayList<TitanCharString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanCharString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final TitanCharString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanCharString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanCharString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanCharString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanCharString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanCharString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString get_unbound_elem() {
			return new TitanCharString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanCharString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanCharString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanCharString val = new TitanCharString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanCharString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanCharString_template temp = new TitanCharString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanCharString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanCharString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanCharString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanCharString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanCharString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_CHARSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__FLOAT__OPTIMIZED extends Record_Of_Type {

		protected List<TitanFloat> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
		}

		private static final List<TitanFloat> copy_list( final List<TitanFloat> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanFloat> newList = new ArrayList<TitanFloat>( srcList.size() );
			for (final TitanFloat srcElem : srcList) {
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanFloat> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanFloat> newList = new ArrayList<TitanFloat>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanFloat newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanFloat leftElem = valueElements.get( i );
				final TitanFloat rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanFloat leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanFloat>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanFloat elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanFloat get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanFloat temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanFloat get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanFloat constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanFloat elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanFloat constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanFloat elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanFloat>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanFloat() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanFloat get_unbound_elem() {
			return new TitanFloat();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED","element");
			final PREGEN__RECORD__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanFloat(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED","element");
			final PREGEN__RECORD__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanFloat elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanFloat elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanFloat elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanFloat(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanFloat temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanFloat>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanFloat temp2 = new TitanFloat();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanFloat>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanFloat val = new TitanFloat();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanFloat_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__FLOAT__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanFloat_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanFloat_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanFloat_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanFloat_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanFloat_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template temp = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanFloat_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanFloat_template temp = new TitanFloat_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template temp = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__FLOAT__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanFloat_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__FLOAT__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanFloat_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanFloat_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanFloat_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanFloat_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanFloat_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanFloat_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__FLOAT__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__FLOAT__OPTIMIZED ret_val = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanFloat_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__FLOAT__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__FLOAT__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__FLOAT__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__FLOAT__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanFloat_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanFloat_template temp2 = new TitanFloat_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__FLOAT__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_FLOAT_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__SET__OF__BITSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanBitString> valueElements;

		private final compare_function_t compare_function_set = new compare_function_t() {
			@Override
			public boolean compare(final Base_Type left_ptr, final int left_index, final Base_Type right_ptr, final int right_index) {
				return compare_set((PREGEN__SET__OF__BITSTRING__OPTIMIZED)left_ptr, left_index, (PREGEN__SET__OF__BITSTRING__OPTIMIZED)right_ptr, right_index);
			}
		};

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED( final PREGEN__SET__OF__BITSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
		}

		private static final List<TitanBitString> copy_list( final List<TitanBitString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanBitString> newList = new ArrayList<TitanBitString>( srcList.size() );
			for (final TitanBitString srcElem : srcList) {
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanBitString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanBitString> newList = new ArrayList<TitanBitString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanBitString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__SET__OF__BITSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__SET__OF__BITSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.valueElements.size(), compare_function_set);
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			return RecordOf_Match.compare_set_of(this, valueElements.size(), other_value, other_value.n_elem(), compare_function_set);
		}

		private boolean compare_set(final PREGEN__SET__OF__BITSTRING__OPTIMIZED left_ptr, final int left_index, final PREGEN__SET__OF__BITSTRING__OPTIMIZED right_ptr, final int right_index) {
			if (left_ptr.valueElements == null) {
				throw new TtcnError( "The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			if (right_ptr.valueElements == null) {
				throw new TtcnError( "The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			final TitanBitString temp_left = left_ptr.valueElements.get(left_index);
			final TitanBitString temp_right = right_ptr.valueElements.get(right_index);
			if (temp_left.is_bound()) {
				if (temp_right.is_bound()){
					return temp_left.operator_equals( temp_right );
				} else  {
					return false;
				}
			} else {
				return !temp_right.is_bound();
			}
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__SET__OF__BITSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__BITSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_assign( final PREGEN__SET__OF__BITSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanBitString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_concatenate(final PREGEN__SET__OF__BITSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__SET__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanBitString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__SET__OF__BITSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__SET__OF__BITSTRING__OPTIMIZED(this);
			}
			final PREGEN__SET__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanBitString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanBitString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanBitString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanBitString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanBitString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanBitString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanBitString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanBitString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanBitString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanBitString get_unbound_elem() {
			return new TitanBitString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanBitString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED","element");
			final PREGEN__SET__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanBitString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanBitString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanBitString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanBitString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("set of value", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanBitString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanBitString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanBitString temp2 = new TitanBitString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanBitString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanBitString val = new TitanBitString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__SET__OF__BITSTRING__OPTIMIZED_template extends Set_Of_Template {

		//originally single_value/value_elements
		protected List<TitanBitString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__SET__OF__BITSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__BITSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		//ONLY for set of
		//originally value_set/set_items
		protected List<TitanBitString_template> set_items;

		private final match_function_t match_function_set = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_set((PREGEN__SET__OF__BITSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__SET__OF__BITSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		private final log_function_t log_function = new log_function_t() {
			@Override
			public void log(final Base_Type value_ptr, final Restricted_Length_Template template_ptr, final int index_value, final int index_template, final boolean legacy) {
				if (value_ptr == null) {
					if (template_ptr != null) {
						((PREGEN__SET__OF__BITSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log();
					}
				} else if (template_ptr == null) {
					((PREGEN__SET__OF__BITSTRING__OPTIMIZED)value_ptr).constGet_at(index_value).log();
				} else {
					((PREGEN__SET__OF__BITSTRING__OPTIMIZED_template)template_ptr).value_elements.get(index_template).log_match(((PREGEN__SET__OF__BITSTRING__OPTIMIZED)value_ptr).constGet_at(index_value), legacy);
				}
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template( final PREGEN__SET__OF__BITSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template( final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template( final Set_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template( final Optional<PREGEN__SET__OF__BITSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanBitString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__SET__OF__BITSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanBitString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanBitString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanBitString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanBitString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__BITSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBitString_template>(other_value.set_items.size());
				for (int set_count = 0; set_count < other_value.set_items.size(); set_count++) {
					final TitanBitString_template temp = new TitanBitString_template(other_value.set_items.get(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Set_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanBitString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template temp = new PREGEN__SET__OF__BITSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				final int otherSetSize = other_value.n_set_items();
				set_items = new ArrayList<TitanBitString_template>(otherSetSize);
				for (int set_count = 0; set_count < otherSetSize; set_count++) {
					final TitanBitString_template temp = new TitanBitString_template();
					temp.operator_assign(other_value.set_item(set_count));
					set_items.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__SET__OF__BITSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__SET__OF__BITSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_set_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				return RecordOf_Match.match_set_of(other_value, value_length, this, set_items.size(), match_function_set, legacy);
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__SET__OF__BITSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		private boolean match_set(final PREGEN__SET__OF__BITSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.set_items.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.set_items.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED) {
				return match((PREGEN__SET__OF__BITSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__BITSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign( final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign( final Set_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__SET__OF__BITSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__SET__OF__BITSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Set_Of_Template) {
				return operator_assign((Set_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__SET__OF__BITSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__SET__OF__BITSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanBitString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__SET__OF__BITSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanBitString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanBitString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanBitString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		public int n_set_items() {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return set_items.size();
		}
		@Override
		public TitanBitString_template set_item(final int set_index) {
			if (template_selection != template_sel.SUPERSET_MATCH && template_selection != template_sel.SUBSET_MATCH) {
				throw new TtcnError("Internal error: Accessing a set element of a non-set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			if (set_index >= set_items.size() ) {
				throw new TtcnError("Internal error: Index overflow in a set template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return set_items.get(set_index);
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanBitString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanBitString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			{
				min_size = 0;
				has_any_or_none = false;
				int elem_count = set_items.size();
				if (!is_size) {
					while (elem_count>0 && !set_items.get(elem_count-1).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++) {
					switch (set_items.get(i).get_selection()) {
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
				if (template_selection == template_sel.SUPERSET_MATCH) {
					has_any_or_none = true;
				} else {
					final int max_size = min_size;
					min_size = 0;
					if (!has_any_or_none) { // [0,max_size]
						switch (length_restriction_type) {
						case NO_LENGTH_RESTRICTION:
							if (max_size==0) {
								return new TitanInteger(0);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED with no exact size.", op_name ) );
						case SINGLE_LENGTH_RESTRICTION:
							if (single_length <= max_size) {
								return new TitanInteger(single_length);
							}
							throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED. The maximum size ({1}) contradicts the length restriction ({2}).", op_name, max_size, single_length ) );
						case RANGE_LENGTH_RESTRICTION:
							if (max_size == range_length_min_length) {
								return new TitanInteger(max_size);
							} else if (max_size > range_length_min_length) {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED with no exact size.", op_name ) );
							} else {
								throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an invalid template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED. Maximum size ({1}) contradicts the length restriction ({2}..{3}).", op_name, max_size, range_length_min_length, range_length_max_length ) );
							}
						default:
							throw new TtcnError("Internal error: Template has invalid length restriction type.");
						}
					}
				}
			}
			break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanBitString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__SET__OF__BITSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__SET__OF__BITSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__SET__OF__BITSTRING__OPTIMIZED_template() );
				}
				break;
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				set_items = new ArrayList<TitanBitString_template>(list_length);
				for( int i = 0; i < list_length; i++ ) {
					set_items.add( new TitanBitString_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
			final PREGEN__SET__OF__BITSTRING__OPTIMIZED ret_val = new PREGEN__SET__OF__BITSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanBitString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__SET__OF__BITSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						value_elements.get(elem_count).log();
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
				TTCN_Logger.log_event("%s(", template_selection == template_sel.SUPERSET_MATCH ? "superset" : "subset");
				for (int set_count = 0; set_count < set_items.size(); set_count++) {
					if (set_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					set_items.get(set_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__SET__OF__BITSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__SET__OF__BITSTRING__OPTIMIZED) {
				log_match((PREGEN__SET__OF__BITSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__SET__OF__BITSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					if (template_selection == template_sel.SPECIFIC_VALUE) {
						RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
					} else {
						if(previous_size != 0) {
							TTCN_Logger.print_logmatch_buffer();
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
							TTCN_Logger.log_event_str(":=");
						}
					}
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
				return;
			}
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
				if (template_selection == template_sel.SPECIFIC_VALUE) {
					RecordOf_Match.log_match_heuristics(match_value, match_value.size_of().get_int(), this, value_elements.size(), match_function_specific, log_function, legacy);
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_restricted(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanBitString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanBitString_template temp2 = new TitanBitString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__SET__OF__BITSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__SET__OF__BITSTRING__OPTIMIZED_template temp2 = new PREGEN__SET__OF__BITSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "set of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				set_size(param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					if (param.get_elem(i).get_type() != Module_Parameter.type_t.MP_NotUsed) {
						get_at(i).set_param(param.get_elem(i));
					}
				}
				break;
			}
			case MP_Superset_Template:
			case MP_Subset_Template:
				set_type(param.get_type() == Module_Parameter.type_t.MP_Superset_Template ? template_sel.SUPERSET_MATCH : template_sel.SUBSET_MATCH, param.get_size());
				for (int i = 0; i < param.get_size(); i++) {
					set_item(i).set_param(param.get_elem(i));
				}
				break;
			default:
				param.type_error("set of template", "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return false;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_SET_OF_BITSTRING_OPTIMIZED" : name));
		}
	}
	public static class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED extends Record_Of_Type {

		protected List<TitanHexString> valueElements;

		/**
		 * Initializes to unbound value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED() {
			// do nothing
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue.valueElements );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED( final Record_Of_Type otherValue ) {
			otherValue.must_bound("Copying an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			valueElements = copy_list( otherValue );
		}

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
		}

		private static final List<TitanHexString> copy_list( final List<TitanHexString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanHexString> newList = new ArrayList<TitanHexString>( srcList.size() );
			for (final TitanHexString srcElem : srcList) {
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}

		private static final List<TitanHexString> copy_list( final Record_Of_Type otherValue ) {
			final List<TitanHexString> newList = new ArrayList<TitanHexString>( otherValue.n_elem() );
			for (int i = 0; i < otherValue.n_elem(); i++) {
				final Base_Type srcElem = otherValue.constGet_at(i);
				final TitanHexString newElem = get_unbound_elem();
				if (srcElem.is_bound()) {
					newElem.operator_assign( srcElem );
				}
				newList.add( newElem );
			}
			return newList;
		}


		@Override
		public boolean is_present() {
			return is_bound();
		}

		@Override
		public boolean is_bound() {
			return valueElements != null;
		}


		@Override
		public boolean is_value() {
			if (valueElements == null) {
				return false;
			}
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem == null || !elem.is_value()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operator_equals(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED) {
				return operator_equals((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)other_value);
			}
			if (other_value instanceof Record_Of_Type) {
				return operator_equals((Record_Of_Type)other_value);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.");
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final TitanNull_Type nullValue) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			return valueElements.isEmpty();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param other_value
		 *                the other value to check against.
		 * @return true if the values are equivalent.
		 */
		public boolean operator_equals( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanHexString leftElem = valueElements.get( i );
				final TitanHexString rightElem = other_value.valueElements.get( i );
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public boolean operator_equals( final Record_Of_Type other_value ) {
			must_bound("The left operand of comparison is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			other_value.must_bound("The right operand of comparison is an unbound value.");
			if (this == other_value) {
				return true;
			}

			final int size = valueElements.size();
			if ( size != other_value.n_elem() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanHexString leftElem = valueElements.get( i );
				final Base_Type rightElem = other_value.constGet_at(i);
				if (leftElem.is_bound()) {
					if (rightElem.is_bound()) {
						if ( !leftElem.operator_equals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.is_bound()) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final TitanNull_Type nullValue) {
			return !operator_equals(nullValue);
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return true if the values are not equivalent.
		 */
		public boolean operator_not_equals( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED otherValue ) {
			return !operator_equals(otherValue);
		}

		public boolean operator_not_equals( final Record_Of_Type otherValue ) {
			return !operator_equals(otherValue);
		}


		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_assign(final Base_Type other_value) {
			if (other_value instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)other_value);
			}

			if (other_value instanceof Record_Of_Type) {
				return operator_assign((Record_Of_Type)other_value);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_assign( final Record_Of_Type other_value ) {
			other_value.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED." );
			if (this == other_value) {
				return this;
			}

			valueElements = copy_list( other_value );
			return this;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_assign( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED otherValue ) {
			otherValue.must_bound( "Assigning an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED." );
			if (this == otherValue) {
				return this;
			}

			valueElements = copy_list( otherValue.valueElements );
			return this;
		}

		/**
		 * Sets the current value to unbound.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new value object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanHexString>();
			return this;
		}

		/**
		 * Concatenates the current record/set of with the other received as a
		 * parameter.
		 *
		 * operator+ in the core.
		 *
		 * @param other_value
		 *                the other value to concatenate with.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_concatenate(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED concatenation.");
			}
			final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = valueElements.size();
			for (int i=0; i < elements_size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int other_elements_size = other_value.valueElements.size();
			for (int i = 0; i < other_elements_size; i++) {
				final TitanHexString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Concatenates the current record/set of with a zero length list.
		 * Effectively creates a copy of the actual record/set of value.
		 *
		 * operator+ in the core.
		 *
		 * @param null_value
		 *                used only to indicate concatenation with an empty list.
		 * @return the new record/set of representing the concatenated value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED operator_concatenate(final TitanNull_Type null_value) {
			return new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(this);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED rotate_left(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate left operator.");
			return rotate_left(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the left with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate left.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED rotate_left(final int rotate_count) {
			return rotate_right(-rotate_count);
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED rotate_right(final TitanInteger rotate_count) {
			rotate_count.must_bound("Unbound integer operand of rotate right operator.");
			return rotate_right(rotate_count.get_int());
		}

		/**
		 * Creates a new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED, that is the equivalent of the
		 * current one with its elements rotated to the right with the provided
		 * amount.
		 *
		 * operator<<= in the core.
		 *
		 * @param rotate_count
		 *                the number of characters to rotate right.
		 * @return the new @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED rotate_right(final int rotate_count) {
			must_bound("Performing rotation operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			final int size = valueElements.size();
			if (size == 0) {
				return new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(this);
			}
			final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		@Override
		public void clean_up() {
			valueElements = null;
		}

		@Override
		public TitanHexString get_at( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				set_size(index_value + 1);
			}

			TitanHexString temp = valueElements.get( index_value );
			if ( temp == null ) {
				temp = get_unbound_elem();
				valueElements.set( index_value, temp );
			}
			return temp;
		}

		@Override
		public TitanHexString get_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED." );
			return get_at( index_value.get_int() );
		}

		@Override
		public TitanHexString constGet_at( final int index_value ) {
			must_bound( "Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED." );
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index: "+index_value+".");
			}
			final int nofElements = valueElements.size();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanHexString elem = valueElements.get( index_value );
			return ( elem == null ) ? get_unbound_elem(): elem ;
		}

		@Override
		public TitanHexString constGet_at(final TitanInteger index_value) {
			index_value.must_bound( "Using an unbound integer value for indexing a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED." );
			return constGet_at( index_value.get_int() );
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			must_bound("Performing sizeof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			return new TitanInteger(valueElements.size());
		}

		@Override
		public int n_elem() {
			return size_of().get_int();
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			must_bound("Performing lengthof operation on an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanHexString elem = valueElements.get( i );
				if ( elem != null && elem.is_bound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		/**
		 * Sets the new size of the value.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanHexString>(newSize);
			}
			final int elements_size = valueElements.size();
			if (newSize > elements_size) {
				for ( int i = elements_size; i < newSize; i++ ) {
					valueElements.add( new TitanHexString() );
				}
			} else if (newSize < elements_size) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanHexString get_unbound_elem() {
			return new TitanHexString();
		}

		/**
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice.
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		@Override
		public String toString() {
			if (!is_bound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(final int index, final int returncount) {
			must_bound("The first argument of substr() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanHexString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED repl) {
			must_bound("The first argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			repl.must_bound("The fourth argument of replace() is an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED","element");
			final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanHexString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanHexString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size - index - len; i++) {
				final TitanHexString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanHexString(elem));
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final int index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final int len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.get_int(), len.get_int(), repl.valueof());
		}
		@Override
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				if (valueElements.get(i) != null) {
					valueElements.get(i).log();
				}
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					operator_assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					set_size(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(i).set_param(current);
							if (!constGet_at(i).is_bound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						get_at(current.get_id().get_index()).set_param(current);
						if (!constGet_at(current.get_id().get_index()).is_bound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED");
					break;
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!is_bound()) {
						operator_assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthof().get_int();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							get_at(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED");
					break;
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			final int elements_size = valueElements.size();
			for (int i = 0; i < elements_size; i++) {
				final TitanHexString temp = valueElements.get(i);
				if (temp != null && temp.is_bound()) {
					temp.set_implicit_omit();
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			must_bound("Text encoder: Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			final int elements_size = valueElements.size();
			text_buf.push_int(elements_size);
			for (int i = 0; i < elements_size; i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			final int temp = text_buf.pull_int().get_int();
			valueElements = new ArrayList<TitanHexString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanHexString temp2 = new TitanHexString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(false, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_encode(final TTCN_Typedescriptor p_td, final RAW_enc_tree myleaf) {
			int encoded_length = 0;
			final int encoded_num_of_records = p_td.raw.fieldlength == 0 ? valueElements.size() : Math.min(valueElements.size(), p_td.raw.fieldlength);
			myleaf.isleaf = false;
			myleaf.rec_of = true;
			myleaf.num_of_nodes = encoded_num_of_records;
			myleaf.nodes = new RAW_enc_tree[encoded_num_of_records];
			for (int a = 0; a < encoded_num_of_records; a++) {
				myleaf.nodes[a] = new RAW_enc_tree(true, myleaf, myleaf.curr_pos, a, p_td.oftype_descr.raw);
				encoded_length += valueElements.get(a).RAW_encode(p_td.oftype_descr, myleaf.nodes[a]);
			}
			return myleaf.length = encoded_length;
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, final int limit, final raw_order_t top_bit_ord) {
			return RAW_decode(p_td, buff, limit, top_bit_ord, false, -1, true, null);
		}

		@Override
		/** {@inheritDoc} */
		public int RAW_decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer buff, int limit, final raw_order_t top_bit_ord, final boolean no_err, int sel_field, final boolean first_call, final RAW_Force_Omit force_omit) {
			final int prepaddlength = buff.increase_pos_padd(p_td.raw.prepadding);
			limit -= prepaddlength;
			int decoded_length = 0;
			int decoded_field_length = 0;
			int start_of_field = 0;
			if (first_call) {
				clean_up();
				valueElements = new ArrayList<TitanHexString>();
			}
			final int start_field = valueElements.size();
			if (p_td.raw.fieldlength > 0 || sel_field != -1) {
				int a = 0;
				if (sel_field == -1) {
					sel_field = p_td.raw.fieldlength;
				}
				for (a = 0; a < sel_field; a++) {
					decoded_field_length = get_at(a + start_field).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						return decoded_field_length;
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
				}
				if (a == 0) {
					valueElements.clear();
				}
			} else {
				if (limit == 0) {
					if (!first_call) {
						return -1;
					}
					valueElements.clear();
					return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
				}
				int a = start_field;
				while (limit > 0) {
					start_of_field = buff.get_pos_bit();
					decoded_field_length = get_at(a).RAW_decode(p_td.oftype_descr, buff, limit, top_bit_ord, true, -1, true, null);
					if (decoded_field_length < 0) {
						valueElements.remove(a);
						buff.set_pos_bit(start_of_field);
						if (a > start_field) {
							return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
						} else {
							return -1;
						}
					}
					decoded_length += decoded_field_length;
					limit -= decoded_field_length;
					a++;
					if (ext_bit_t.EXT_BIT_NO != p_td.raw.extension_bit && ((ext_bit_t.EXT_BIT_YES != p_td.raw.extension_bit) ^ buff.get_last_bit())) {
						return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
					}
				}
			}
			return decoded_length + buff.increase_pos_padd(p_td.raw.padding) + prepaddlength;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_encode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok) {
			if (!is_bound()) {
				TTCN_EncDec_ErrorContext.error(error_type.ET_UNBOUND,
						"Encoding an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
				return -1;
			}

			int enc_len = p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_START : json_token_t.JSON_TOKEN_ARRAY_START, null);
			for (int i = 0; i < valueElements.size(); ++i) {
				if (p_td.json.isMetainfo_unbound() && !(get_at(i).is_bound())) {
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_START, null);
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_NAME, "metainfo []");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_STRING, "\"unbound\"");
					enc_len += p_tok.put_next_token(json_token_t.JSON_TOKEN_OBJECT_END, null);
				}
				else {
					final int ret_val = get_at(i).JSON_encode(p_td.oftype_descr, p_tok);
					if (0 > ret_val) break;
					enc_len += ret_val;
				}
			}
			enc_len += p_tok.put_next_token(p_td.json.isAs_map() ? json_token_t.JSON_TOKEN_OBJECT_END : json_token_t.JSON_TOKEN_ARRAY_END, null);
			return enc_len;
		}

		@Override
		/** {@inheritDoc} */
		public int JSON_decode(final TTCN_Typedescriptor p_td, final JSON_Tokenizer p_tok, final boolean p_silent, final int p_chosen_field) {
			if (null != p_td.json.getDefault_value() && 0 == p_tok.get_buffer_length()) {
				set_size(0);
				return p_td.json.getDefault_value().length();
			}
			final AtomicReference<json_token_t> token = new AtomicReference<json_token_t>(json_token_t.JSON_TOKEN_NONE);
			int dec_len = p_tok.get_next_token(token, null, null);
			if (json_token_t.JSON_TOKEN_ERROR == token.get()) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_BAD_TOKEN_ERROR, "");
				}
				return JSON.JSON_ERROR_FATAL;
			}
			else if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_START != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_START != token.get())) {
				return JSON.JSON_ERROR_INVALID_TOKEN;
			}

			set_size(0);
			while (true) {
				final int buf_pos = p_tok.get_buf_pos();
				int ret_val;
				if (p_td.json.isMetainfo_unbound()) {
					ret_val = p_tok.get_next_token(token, null, null);
					if (json_token_t.JSON_TOKEN_OBJECT_START == token.get()) {
						final StringBuilder value = new StringBuilder();
						final AtomicInteger value_len = new AtomicInteger(0);
						ret_val += p_tok.get_next_token(token, value, value_len);
						if (json_token_t.JSON_TOKEN_NAME == token.get() && 11 == value_len.get() && "metainfo []".equals(value.toString())) {
							ret_val += p_tok.get_next_token(token, value, value_len);
							if (json_token_t.JSON_TOKEN_STRING == token.get() && 9 == value_len.get() && "\"unbound\"".equals(value.toString())) {
								ret_val = p_tok.get_next_token(token, null, null);
								if (json_token_t.JSON_TOKEN_OBJECT_END == token.get()) {
									dec_len += ret_val;
									continue;
								}
							}
						}
					}
					p_tok.set_buf_pos(buf_pos);
				}
				final TitanHexString val = new TitanHexString();
				final int ret_val2 = val.JSON_decode(p_td.oftype_descr, p_tok, p_silent);
				if (JSON.JSON_ERROR_INVALID_TOKEN == ret_val2) {
					p_tok.set_buf_pos(buf_pos);
					break;
				}
				else if (JSON.JSON_ERROR_FATAL == ret_val2) {
					if (p_silent) {
						clean_up();
					}
					return JSON.JSON_ERROR_FATAL;
				}
				valueElements.add(val);
				dec_len += ret_val2;
			}

			dec_len += p_tok.get_next_token(token, null, null);
			if ((!p_td.json.isAs_map() && json_token_t.JSON_TOKEN_ARRAY_END != token.get()) ||
					(p_td.json.isAs_map() && json_token_t.JSON_TOKEN_OBJECT_END != token.get())) {
				if (!p_silent) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, JSON.JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
				}
				if (p_silent) {
					clean_up();
				}
				return JSON.JSON_ERROR_FATAL;
			}

			return dec_len;
		}

	}
	public static class PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template extends Record_Of_Template {

		//originally single_value/value_elements
		protected List<TitanHexString_template> value_elements;

		//originally value_list/list_value
		protected List<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)value_ptr, value_index, (PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template)template_ptr, template_index, legacy);
			}
		};

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template() {
			// do nothing
		}

		/**
		 * Initializes to a given template kind.
		 *
		 * @param otherValue
		 *                the template kind to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(final template_sel otherValue ) {
			super( otherValue );
			check_single_selection( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED otherValue ) {
			copy_value( otherValue );
		}

		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template otherValue ) {
			copy_template( otherValue );
		}

		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template( final Record_Of_Template otherValue ) {
			copy_template( otherValue );
		}

		/**
		 * Initializes to a given value.
		 * The template becomes a specific template with the provided value.
		 * Causes a dynamic testcase error if the value is neither present nor optional.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template( final Optional<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED> otherValue ) {
			switch (otherValue.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(otherValue.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED from an unbound optional field.");
			}
		}

		/**
		 * Initializes to an empty specific value template.
		 *
		 * @param nullValue
		 *                the null value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanHexString_template>();
		}

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		protected void copy_value(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED other_value) {
			other_value.must_bound("Initialization of a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED with an unbound value.");
			value_elements = new ArrayList<TitanHexString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGet_at(elem_count).is_bound()) {
					value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
				} else {
					value_elements.add( new TitanHexString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGet_at(elem_count).is_bound()) {
						value_elements.add( new TitanHexString_template(other_value.constGet_at(elem_count)) );
					} else {
						value_elements.add( new TitanHexString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		private void copy_template(final Record_Of_Template other_value) {
			switch (other_value.get_selection()) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanHexString_template>();
				final int otherSize = other_value.n_elem();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					final TitanHexString_template temp = new TitanHexString_template();
					if (other_value.constGet_at(elem_count).is_bound()) {
						temp.operator_assign(other_value.constGet_at(elem_count));
					}
					value_elements.add( temp );
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				final int otherListSize = other_value.n_list_elem();
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template>(otherListSize);
				for(int i = 0; i < otherListSize; i++) {
					final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template temp = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template();
					temp.operator_assign(other_value.list_item(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(other_value);
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			final int value_length = other_value.size_of().get_int();
			if (!match_length(value_length)) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOf_Match.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = list_value.size();
				for(int i = 0 ; i < list_size; i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		private boolean match_index(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED value_ptr, final int value_index, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED) {
				return match((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = list_value.size();
					for (int i = 0 ; i < list_size; i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign( final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign( final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign( final Record_Of_Template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign(final Base_Type otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign(final Base_Template otherValue) {
			if (otherValue instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template) {
				return operator_assign((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template)otherValue);
			}

			if (otherValue instanceof Record_Of_Template) {
				return operator_assign((Record_Of_Template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template.");
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign( final Optional<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED> other_value ) {
			clean_up();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			return this;
		}
		/**
		 * Sets the current template to empty.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param nullValue
		 *                the null value.
		 * @return the new template object.
		 */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template operator_assign(final TitanNull_Type nullValue) {
			clean_up();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = new ArrayList<TitanHexString_template>();
			return this;
		}


		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.is_value()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl.valueof());
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final int index, final int len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index, len, repl);
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the parts from the provided index at the provided length
		 * being replaced by the provided values.
		 *
		 * @param index
		 *                the index to start replacing at.
		 * @param len
		 *                the number of elements to replace.
		 * @param repl
		 *                the values to insert.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED replace(final TitanInteger index, final TitanInteger len, final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED repl) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueof().replace(index.get_int(), len.get_int(), repl);
		}

		@Override
		public TitanHexString_template get_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			switch (template_selection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				set_size(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template get_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");

			return get_at(index_value.get_int());
		}

		@Override
		public TitanHexString_template constGet_at(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index: {0}.", index_value ) );
			}

			if (template_selection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		@Override
		public TitanHexString_template constGet_at(final TitanInteger index_value) {
			index_value.must_bound("Using an unbound integer value for indexing a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");

			return constGet_at(index_value.get_int());
		}

		/**
		 * Sets the new size of the template.
		 * Also makes turns it into a specific value template if not already.
		 * If the new size is bigger than actual, unbound elements are added to the end.
		 * If the new size is smaller than actual, excess elements are removed.
		 *
		 * @param newSize the new size to be used.
		 * */
		public void set_size(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			final template_sel old_selection = template_selection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				clean_up();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanHexString_template>(new_size);
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanHexString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				while(value_elements.size() > new_size) {
					value_elements.remove(value_elements.size()-1);
				}
			}
		}

		/**
		 * Returns the number of elements.
		 * The value to be returned is the maximum of the minimal length restriction value of the type,
		 *  or 0 for types with no minimal length restriction,
		 *  and the index of the last initialized element plus 1.
		 *
		 * size_of in the core.
		 * deprecated by the standard.
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger size_of() {
			return sizeOf(true);
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * lengthof in the core
		 *
		 * @return the number of elements.
		 * */
		public TitanInteger lengthof() {
			return sizeOf(false);
		}

		/**
		 * A helper function to reduce code. Based on the parameter it
		 * can operate as size_of or lengthof.
		 *
		 * @param is_size
		 *                {@code true} to operate as size_of,
		 *                {@code false} otherwise.
		 * @return the appriopriate number based on the operation mode
		 *         selected.
		 * */
		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (template_selection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).is_bound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.isEmpty()) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).get_int();
				final int list_size = list_value.size();
				for (int i = 1; i < list_size; i++) {
					if (list_value.get(i).sizeOf(is_size).get_int()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanHexString_template"));
		}

		/**
		 * Returns the number of elements, that is, the largest used index plus
		 * one and zero for the empty value.
		 *
		 * n_elem in the core
		 *
		 * @return the number of elements.
		 * */
		public int n_elem() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED.");
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				if (!value_elements.get(elem_count).is_value()) {
					return false;
				}
			}
			return true;
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			clean_up();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			set_selection(template_type);
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.size();
		}
		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.get(list_index);
		}

		/**
		 * Accessor for list items of value list and complemented list
		 * templates.
		 *
		 * Underflow and overflow results in dynamic testcase
		 * error. list_item in the core.
		 *
		 * @param list_index
		 *                the index of the list item.
		 * @return the list item at the provided index.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template get_list_item(final int list_index) {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED using a negative index ({0}).", list_index));
			} else if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			return list_value.get( list_index );
		}

		@Override
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
			final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED ret_val = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED(TitanNull_Type.NULL_VALUE);
			final int elements_size = value_elements.size();
			for (int elem_count = 0; elem_count < elements_size; elem_count++) {
				final TitanHexString_template temp = value_elements.get(elem_count);
				if (temp.is_bound()) {
					ret_val.valueElements.add( temp.valueof() );
				}
			}
			return ret_val;
		}

		/**
		 * Creates a new record/set of value from the current value,
		 * with the elements from the provided index at the provided length.
		 *
		 * @param index
		 *                the index to start at.
		 * @param returncount
		 *                the number of elements to copy.
		 * @return the new value.
		 * */
		public PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED substr(final int index, final int returncount) {
			if (!is_value()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueof().substr(index, returncount);
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (value_elements.isEmpty()) {
					TTCN_Logger.log_event_str("{ }");
				} else {
					TTCN_Logger.log_event_str("{ ");
					final int elements_size = value_elements.size();
					for (int elem_count = 0; elem_count < elements_size; elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = list_value.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * */
		public void log_match(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED) {
				log_match((PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						final int elements_size = value_elements.size();
						for (int elem_count = 0; elem_count < elements_size; elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGet_at(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(elements_size);
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && !value_elements.isEmpty() && get_number_of_permutations() == 0 && value_elements.size() == match_value.size_of().get_int()) {
				TTCN_Logger.log_event_str("{ ");
				final int elements_size = value_elements.size();
				for (int elem_count = 0; elem_count < elements_size; elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGet_at(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(elements_size);
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int elements_size = value_elements.size();
				text_buf.push_int(elements_size);
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:{
				final int list_size = value_elements.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_permutation(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().get_int();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
				}
				value_elements = new ArrayList<TitanHexString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanHexString_template temp2 = new TitanHexString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				list_value = new ArrayList<PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template>(size);
				for (int i = 0; i < size; i++) {
					final PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template temp2 = new PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue() | Module_Parameter.basic_check_bits_t.BC_LIST.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					set_size(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					get_at(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				remove_all_permutations();
				set_size(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							get_at(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						get_at(current_index).set_param(param.get_elem(i));
						current_index++;
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED");
				break;
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (template_selection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE: {
				if (template_selection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				final int elements_size = value_elements.size();
				for (int i = 0; i < elements_size; i++) {
					value_elements.get(i).check_restriction(restriction, name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED" : name, false);
				}
				return;
			}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.PREGEN_RECORD_OF_HEXSTRING_OPTIMIZED" : name));
		}
	}
	public static class anytype extends Base_Type {
		/**
		 * Indicates the state/selection of this union kind.
		 * When union_selection is UNBOUND_VALUE, the union is unbound.
		 * When union_selection is any other enumeration,
		 * the appropriate field is selected.
		 * */
		public enum union_selection_type { UNBOUND_VALUE };
		private union_selection_type union_selection;

		/**
		 * Initializes to unbound value.
		 * */
		public anytype() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};

		/**
		 * Initializes to a given value.
		 *
		 * @param otherValue
		 *                the value to initialize to.
		 * */
		public anytype(final anytype otherValue) {
			copy_value(otherValue);
		};

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_value(final anytype other_value) {
			union_selection = other_value.union_selection;
		}

		/**
		 * Assigns the other value to this value.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new value object.
		 */
		public anytype operator_assign( final anytype otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_value(otherValue);
			}

			return this;
		}

		@Override
		public anytype operator_assign( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.anytype.");
		}

		@Override
		public void clean_up() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		/**
		 * Checks and reports whether the union has the provided alternative active or not.
		 *
		 * ischosen in the core.
		 *
		 * @param checked_selection the selection to check for.
		 *
		 * @return {@code true} if the unions has the provided selection active.
		 */
		public boolean ischosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @PreGenRecordOf.anytype.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean is_bound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean is_value() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean is_present() {
			return is_bound();
		}

		/**
		 * Checks if the current value is equivalent to the provided one.
		 *
		 * operator== in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return {@code true} if the selections and field values are equivalent.
		 */
		public boolean operator_equals( final anytype otherValue ) {
			must_bound( "The left operand of comparison is an unbound value of union type @PreGenRecordOf.anytype." );
			otherValue.must_bound( "The right operand of comparison is an unbound value of union type @PreGenRecordOf.anytype." );
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			default:
				return false;
			}
		}

		@Override
		public boolean operator_equals( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_equals((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.anytype.");
		}

		/**
		 * Checks if the current value is not equivalent to the provided one.
		 *
		 * operator!= in the core
		 *
		 * @param otherValue
		 *                the other value to check against.
		 * @return {@code true} if either the selections or the field
		 *         values are not equivalent.
		 */
		public boolean operator_not_equals( final anytype otherValue ) {
			return !operator_equals(otherValue);
		}

		/**
		 * Returns the current selection.
		 * It will return anytype.union_selection_type.UNBOUND_VALUE if the value is unbound,
		 *
		 * @return the current selection.
		 * */
		public union_selection_type get_selection() {
			return union_selection;
		}

		@Override
		public void log() {
			switch (union_selection) {
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(Module_Parameter param) {
			if (param.get_id() != null && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union type `@PreGenRecordOf.anytype'");
				}
				else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `@PreGenRecordOf.anytype'", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if (param.get_type() == Module_Parameter.type_t.MP_Reference) {
				param = param.get_referenced_param().get();
			}
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @PreGenRecordOf.anytype.", last_name));
		}

		@Override
		public Module_Parameter get_param(final Module_Param_Name param_name) {
			if (!is_bound()) {
				return new Module_Param_Unbound();
			}
			if (param_name.next_name()) {
				final String param_field = param_name.get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					throw new TtcnError("Unexpected array index in module parameter, expected a valid field name for union type `@PreGenRecordOf.anytype'");
				}
				{
					throw new TtcnError(MessageFormat.format("Field `{0}' not found in union type `@PreGenRecordOf.anytype'", param_field));
				}
			}
			Module_Parameter mp_field;
			switch(union_selection) {
			default:
				mp_field = null;
			}
			final Module_Param_Assignment_List mp = new Module_Param_Assignment_List();
			mp.add_elem(mp_field);
			return mp;
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().get_int();
			switch (temp) {
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final RAW_enc_tr_pos tree_position = new RAW_enc_tr_pos(0, null);
					final RAW_enc_tree root = new RAW_enc_tree(true, null, tree_position, 1, p_td.raw);
					RAW_encode(p_td, root);
					root.put_to_buf(p_buf);
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(flavour != 0);
				JSON_encode(p_td, tok);
				p_buf.put_s(tok.get_buffer().toString().getBytes());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				try{
					if (p_td.raw == null) {
						TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
					}
					final raw_order_t order = p_td.raw.top_bit_order == top_bit_order_t.TOP_BIT_LEFT ? raw_order_t.ORDER_LSB : raw_order_t.ORDER_MSB;
					final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
					if (rawr < 0) {
						final error_type temp = error_type.values()[-rawr];
						switch (temp) {
						case ET_INCOMPL_MSG:
						case ET_LEN_ERR:
							TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						case ET_UNBOUND:
						default:
							TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
							break;
						}
					}
				} finally {
					errorContext.leave_context();
				}
				break;
			}
			case CT_JSON: {
				if(p_td.json == null) {
					TTCN_EncDec_ErrorContext.error_internal("No JSON descriptor available for type '%s'.", p_td.name);
				}
				final JSON_Tokenizer tok = new JSON_Tokenizer(new String(p_buf.get_data()), p_buf.get_len());
				if(JSON_decode(p_td, tok, false) < 0) {
					TTCN_EncDec_ErrorContext.error(error_type.ET_INCOMPL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
				}
				p_buf.set_pos(tok.get_buf_pos());
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class anytype_template extends Base_Template {
		//if single value which value?
		private anytype.union_selection_type single_value_union_selection;
		// value_list part
		private ArrayList<anytype_template> value_list;

		/**
		 * Internal function to copy the provided value into this template.
		 * The template becomes a specific value template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_value(final anytype other_value) {
			single_value_union_selection = other_value.get_selection();
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		/**
		 * Internal function to copy the provided template into this template.
		 * The already existing content is overwritten.
		 *
		 * @param other_value the value to be copied.
		 * */
		private void copy_template(final anytype_template other_value) {
			switch (other_value.template_selection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<anytype_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final anytype_template temp = new anytype_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @PreGenRecordOf.anytype.");
			}
			set_selection(other_value);
		}

		/**
		 * Initializes to unbound/uninitialized template.
		 * */
		public anytype_template() {
			// do nothing
		}
		/**
		 * Initializes to a given template kind.
		 *
		 * @param other_value
		 *                the template kind to initialize to.
		 * */
		public anytype_template(final template_sel other_value) {
			super(other_value);
			check_single_selection(other_value);
		}
		/**
		 * Initializes to a given value.
		 * The template becomes a specific template.
		 * The elements of the provided value are copied.
		 *
		 * @param other_value
		 *                the value to initialize to.
		 * */
		public anytype_template(final anytype other_value) {
			copy_value(other_value);
		}
		/**
		 * Initializes to a given template.
		 * The elements of the provided template are copied.
		 *
		 * @param other_value
		 *                the value to initialize to.
		 * */
		public anytype_template(final anytype_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void clean_up() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			template_selection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		@Override
		public anytype_template operator_assign(final template_sel otherValue ) {
			check_single_selection(otherValue);
			clean_up();
			set_selection(otherValue);
			return this;
		}

		/**
		 * Assigns the other value to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public anytype_template operator_assign(final anytype otherValue ) {
			clean_up();
			copy_value(otherValue);
			return this;
		}

		/**
		 * Assigns the other template to this template.
		 * Overwriting the current content in the process.
		 *<p>
		 * operator= in the core.
		 *
		 * @param otherValue
		 *                the other value to assign.
		 * @return the new template object.
		 */
		public anytype_template operator_assign(final anytype_template otherValue ) {
			if (otherValue != this) {
				clean_up();
				copy_template(otherValue);
			}
			return this;
		}

		@Override
		public anytype_template operator_assign(final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operator_assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype.");
		}

		@Override
		public anytype_template operator_assign(final Base_Template otherValue ) {
			if (otherValue instanceof anytype_template) {
				return operator_assign((anytype_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype_template.");
		}

		/**
		 * Matches the provided value against this template.
		 *
		 * @param other_value the value to be matched.
		 * */
		public boolean match(final anytype other_value) {
			return match(other_value, false);
		}

		/**
		 * Matches the provided value against this template. In legacy mode
		 * omitted value fields are not matched against the template field.
		 *
		 * @param other_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public boolean match(final anytype other_value, final boolean legacy) {
			if(!other_value.is_bound()) {
				return false;
			}
			switch (template_selection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final anytype.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @PreGenRecordOf.anytype.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = value_list.size();
				for(int i = 0 ; i < list_size; i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return template_selection == template_sel.VALUE_LIST;
					}
				}
				return template_selection == template_sel.COMPLEMENTED_LIST;
			}
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof anytype) {
				return match((anytype)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type anytype.");
		}

		/**
		 * Checks and reports whether the union has the provided alternative active or not.
		 *
		 * ischosen in the core.
		 *
		 * @param checked_selection the selection to check for.
		 *
		 * @return {@code true} if the unions has the provided selection active.
		 */
		public boolean ischosen(final anytype.union_selection_type checked_selection) {
			if(checked_selection == anytype.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @PreGenRecordOf.anytype.");
			}
			switch (template_selection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @PreGenRecordOf.anytype.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST: {
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @PreGenRecordOf.anytype containing an empty list.");
				}
				final int list_size = value_list.size();
				for (int i = 0; i < list_size; i++) {
					if(!value_list.get(i).ischosen(checked_selection)) {
						return false;
					}
				}
				return true;
			}
			default:
				return false;
			}
		}

		@Override
		public boolean is_value() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public anytype valueof() {
			if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @PreGenRecordOf.anytype.");
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public void set_type(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @PreGenRecordOf.anytype.");
			}
			clean_up();
			set_selection(template_type);
			value_list = new ArrayList<anytype_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new anytype_template());
			}
		}

		@Override
		public int n_list_elem() {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.anytype.");
			}
			return value_list.size();
		}

		@Override
		public anytype_template list_item(final int list_index)  {
			if (template_selection != template_sel.VALUE_LIST && template_selection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @PreGenRecordOf.anytype.");
			}
			if (list_index < 0) {
				throw new TtcnError(MessageFormat.format("Internal error: Accessing a value list template of type @PreGenRecordOf.anytype using a negative index ({0}).", list_index));
			} else if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @PreGenRecordOf.anytype.");
			}
			return value_list.get(list_index);
		}

		@Override
		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					final int list_size = value_list.size();
					for (int i = 0 ; i < list_size; i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return template_selection == template_sel.VALUE_LIST;
						}
					}
					return template_selection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		@Override
		public void log() {
			switch (template_selection) {
			case SPECIFIC_VALUE:
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST: {
				TTCN_Logger.log_char('(');
				final int list_size = value_list.size();
				for (int list_count = 0; list_count < list_size; list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			}
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof anytype) {
				log_match((anytype)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @PreGenRecordOf.anytype.");
		}

		/**
		 * Logs the matching of the provided value to this template, to help
		 * identify the reason for mismatch. In legacy mode omitted value fields
		 * are not matched against the template field.
		 *
		 * @param match_value
		 *                the value to be matched.
		 * @param legacy
		 *                use legacy mode.
		 * */
		public void log_match(final anytype match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (template_selection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
					break;
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int list_size = value_list.size();
				text_buf.push_int(list_size);
				for (int i = 0; i < list_size; i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			}
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			clean_up();
			decode_text_base(text_buf);
			switch (template_selection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().get_int();
				single_value_union_selection = anytype.union_selection_type.values()[temp];
				switch (single_value_union_selection) {
				case UNBOUND_VALUE:
					throw new TtcnError("Text decoder: Unrecognized union selector was received for a template of type @PreGenRecordOf.anytype.");
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().get_int();
				value_list = new ArrayList<anytype_template>(size);
				for (int i = 0; i < size; i++) {
					final anytype_template temp2 = new anytype_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @PreGenRecordOf.anytype.");
			}
		}

		@Override
		public void set_param(Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@PreGenRecordOf.anytype'");
				}
				else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `@PreGenRecordOf.anytype'", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			if (param.get_type() == Module_Parameter.type_t.MP_Reference) {
				param = param.get_referenced_param().get();
			}
			switch (param.get_type()) {
			case MP_Omit:
				operator_assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				operator_assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				operator_assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				set_type(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					list_item(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@PreGenRecordOf.anytype");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @PreGenRecordOf.anytype.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@PreGenRecordOf.anytype");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public Module_Parameter get_param(final Module_Param_Name param_name) {
			if (param_name.next_name()) {
				final String param_field = param_name.get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					throw new TtcnError("Unexpected array index in module parameter reference, expected a valid field name for union template type `@PreGenRecordOf.anytype'");
				}
				{
					throw new TtcnError(MessageFormat.format("Field `{0}' not found in union type `@PreGenRecordOf.anytype'", param_field));
				}
			}
			Module_Parameter mp = null;
			switch (template_selection) {
			case UNINITIALIZED_TEMPLATE:
				mp = new Module_Param_Unbound();
				break;
			case OMIT_VALUE:
				mp = new Module_Param_Omit();
				break;
			case ANY_VALUE:
				mp = new Module_Param_Any();
				break;
			case ANY_OR_OMIT:
				mp = new Module_Param_AnyOrNone();
				break;
			case SPECIFIC_VALUE: {
				Module_Parameter mp_field = null;
				switch(single_value_union_selection) {
				default:
					break;
				}
				mp = new Module_Param_Assignment_List();
				mp.add_elem(mp_field);
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				if (template_selection == template_sel.VALUE_LIST) {
					mp = new Module_Param_List_Template();
				} else {
					mp = new Module_Param_ComplementList_Template();
				}
				for (int i_i = 0; i_i < value_list.size(); ++i_i) {
					mp.add_elem(value_list.get(i_i).get_param(param_name));
				}
				break;
			}
			default:
				break;
			}
			if (is_ifPresent) {
				mp.set_ifpresent();
			}
			return mp;
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (template_selection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (template_selection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (template_selection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @PreGenRecordOf.anytype.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", get_res_name(restriction), name == null ? "@PreGenRecordOf.anytype" : name));
		}
	}
	public void pre_init_module()
	{
		if (pre_init_called) {
			return;
		}
		pre_init_called = true;
		final TTCN_Location current_location = TTCN_Location.enter("PreGenRecordOf.ttcn", 0, entity_type_t.LOCATION_UNKNOWN, "PreGenRecordOf");
		PREGEN__RECORD__OF__BOOLEAN_descr_.oftype_descr = Base_Type.TitanBoolean_descr_;
		PREGEN__RECORD__OF__INTEGER_descr_.oftype_descr = Base_Type.TitanInteger_descr_;
		PREGEN__RECORD__OF__FLOAT_descr_.oftype_descr = Base_Type.TitanFloat_descr_;
		PREGEN__RECORD__OF__BITSTRING_descr_.oftype_descr = Base_Type.TitanBitString_descr_;
		PREGEN__RECORD__OF__HEXSTRING_descr_.oftype_descr = Base_Type.TitanHexString_descr_;
		PREGEN__RECORD__OF__OCTETSTRING_descr_.oftype_descr = Base_Type.TitanOctetString_descr_;
		PREGEN__RECORD__OF__CHARSTRING_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
		PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_descr_.oftype_descr = Base_Type.TitanUniversalCharString_descr_;
		PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanBoolean_descr_;
		PREGEN__RECORD__OF__INTEGER__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanInteger_descr_;
		PREGEN__RECORD__OF__FLOAT__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanFloat_descr_;
		PREGEN__RECORD__OF__BITSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanBitString_descr_;
		PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanHexString_descr_;
		PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanOctetString_descr_;
		PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
		PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanUniversalCharString_descr_;
		PREGEN__SET__OF__BOOLEAN_descr_.oftype_descr = Base_Type.TitanBoolean_descr_;
		PREGEN__SET__OF__INTEGER_descr_.oftype_descr = Base_Type.TitanInteger_descr_;
		PREGEN__SET__OF__FLOAT_descr_.oftype_descr = Base_Type.TitanFloat_descr_;
		PREGEN__SET__OF__BITSTRING_descr_.oftype_descr = Base_Type.TitanBitString_descr_;
		PREGEN__SET__OF__HEXSTRING_descr_.oftype_descr = Base_Type.TitanHexString_descr_;
		PREGEN__SET__OF__OCTETSTRING_descr_.oftype_descr = Base_Type.TitanOctetString_descr_;
		PREGEN__SET__OF__CHARSTRING_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
		PREGEN__SET__OF__UNIVERSAL__CHARSTRING_descr_.oftype_descr = Base_Type.TitanUniversalCharString_descr_;
		PREGEN__SET__OF__BOOLEAN__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanBoolean_descr_;
		PREGEN__SET__OF__INTEGER__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanInteger_descr_;
		PREGEN__SET__OF__FLOAT__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanFloat_descr_;
		PREGEN__SET__OF__BITSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanBitString_descr_;
		PREGEN__SET__OF__HEXSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanHexString_descr_;
		PREGEN__SET__OF__OCTETSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanOctetString_descr_;
		PREGEN__SET__OF__CHARSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanCharString_descr_;
		PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED_descr_.oftype_descr = Base_Type.TitanUniversalCharString_descr_;
		current_location.leave();
	}

}
