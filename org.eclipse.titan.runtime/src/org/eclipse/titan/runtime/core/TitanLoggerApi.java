/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 ******************************************************************************/
package org.eclipse.titan.runtime.core;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.titan.runtime.core.Base_Template.template_sel;
import org.eclipse.titan.runtime.core.Base_Type.TTCN_Typedescriptor;
import org.eclipse.titan.runtime.core.Optional.optional_sel;
import org.eclipse.titan.runtime.core.Param_Types.Module_Param_Name;
import org.eclipse.titan.runtime.core.Param_Types.Module_Parameter;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tr_pos;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tree;
import org.eclipse.titan.runtime.core.RAW.TTCN_RAWdescriptor;
import org.eclipse.titan.runtime.core.RAW.ext_bit_t;
import org.eclipse.titan.runtime.core.RAW.raw_sign_t;
import org.eclipse.titan.runtime.core.RAW.top_bit_order_t;
import org.eclipse.titan.runtime.core.RecordOfMatch.match_function_t;
import org.eclipse.titan.runtime.core.TTCN_EncDec.coding_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.error_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.raw_order_t;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location.entity_type_t;
import org.eclipse.titan.runtime.core.TitanCharString.CharCoding;

/**
 * Generated from TitanLoggerApi.xsd
 *
 * @author Kristof Szabados
 */
public final class TitanLoggerApi extends TTCN_Module {

	public static final TTCN_Typedescriptor TitanLog_descr_ = new TTCN_Typedescriptor("TitanLog", null, null);
	public static final TTCN_Typedescriptor TitanLog_sequence__list_0_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0", null, null);
	public static final TTCN_Typedescriptor ComponentIDType_descr_ = new TTCN_Typedescriptor("ComponentIDType", null, null);
	public static final TTCN_RAWdescriptor ComponentIDType_id_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ComponentIDType_id_descr_ = new TTCN_Typedescriptor("ComponentIDType_id", ComponentIDType_id_raw_, null);
	public static final TitanUniversalCharString ComponentIDType_id_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ComponentIDType_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ComponentIDType_name_descr_ = new TTCN_Typedescriptor("ComponentIDType_name", ComponentIDType_name_raw_, null);
	public static final TitanUniversalCharString ComponentIDType_name_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ComponentIDType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLog_sequence__list_0_entityId_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_entityId", null, null);
	public static final TitanUniversalCharString TitanLog_sequence__list_0_entityId_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLogEvent_descr_ = new TTCN_Typedescriptor("TitanLogEvent", null, null);
	public static final TTCN_Typedescriptor TimestampType_descr_ = new TTCN_Typedescriptor("TimestampType", null, null);
	public static final TTCN_RAWdescriptor TimestampType_seconds_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimestampType_seconds_descr_ = new TTCN_Typedescriptor("TimestampType_seconds", TimestampType_seconds_raw_, null);
	public static final TitanUniversalCharString TimestampType_seconds_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor TimestampType_microSeconds_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimestampType_microSeconds_descr_ = new TTCN_Typedescriptor("TimestampType_microSeconds", TimestampType_microSeconds_raw_, null);
	public static final TitanUniversalCharString TimestampType_microSeconds_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TimestampType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLogEvent_timestamp_descr_ = new TTCN_Typedescriptor("TitanLogEvent_timestamp", null, null);
	public static final TitanUniversalCharString TitanLogEvent_timestamp_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LocationInfo_descr_ = new TTCN_Typedescriptor("LocationInfo", null, null);
	public static final TTCN_RAWdescriptor LocationInfo_filename_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor LocationInfo_filename_descr_ = new TTCN_Typedescriptor("LocationInfo_filename", LocationInfo_filename_raw_, null);
	public static final TitanUniversalCharString LocationInfo_filename_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor LocationInfo_line_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor LocationInfo_line_descr_ = new TTCN_Typedescriptor("LocationInfo_line", LocationInfo_line_raw_, null);
	public static final TitanUniversalCharString LocationInfo_line_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor LocationInfo_ent__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor LocationInfo_ent__name_descr_ = new TTCN_Typedescriptor("LocationInfo_ent__name", LocationInfo_ent__name_raw_, null);
	public static final TitanUniversalCharString LocationInfo_ent__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LocationInfo_ent__type_descr_ = new TTCN_Typedescriptor("LocationInfo_ent__type", null, null);
	public static final TitanUniversalCharString LocationInfo_ent__type_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString LocationInfo_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLogEvent_sourceInfo__list_0_descr_ = new TTCN_Typedescriptor("TitanLogEvent_sourceInfo__list_0", null, null);
	public static final TitanUniversalCharString TitanLogEvent_sourceInfo__list_0_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLogEvent_sourceInfo__list_descr_ = new TTCN_Typedescriptor("TitanLogEvent_sourceInfo__list", null, null);
	public static final TitanUniversalCharString TitanLogEvent_sourceInfo__list_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor TitanLogEvent_severity_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TitanLogEvent_severity_descr_ = new TTCN_Typedescriptor("TitanLogEvent_severity", TitanLogEvent_severity_raw_, null);
	public static final TitanUniversalCharString TitanLogEvent_severity_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_descr_ = new TTCN_Typedescriptor("LogEventType", null, null);
	public static final TTCN_Typedescriptor LogEventType_choice_descr_ = new TTCN_Typedescriptor("LogEventType_choice", null, null);
	public static final TTCN_Typedescriptor Strings_descr_ = new TTCN_Typedescriptor("Strings", null, null);
	public static final TTCN_RAWdescriptor Strings_str__list_0_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Strings_str__list_0_descr_ = new TTCN_Typedescriptor("Strings_str__list_0", Strings_str__list_0_raw_, null);
	public static final TitanUniversalCharString Strings_str__list_0_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Strings_str__list_descr_ = new TTCN_Typedescriptor("Strings_str__list", null, null);
	public static final TitanUniversalCharString Strings_str__list_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Strings_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_actionEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_actionEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_actionEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultEvent_descr_ = new TTCN_Typedescriptor("DefaultEvent", null, null);
	public static final TTCN_Typedescriptor DefaultEvent_choice_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice", null, null);
	public static final TTCN_Typedescriptor DefaultOp_descr_ = new TTCN_Typedescriptor("DefaultOp", null, null);
	public static final TTCN_RAWdescriptor DefaultOp_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor DefaultOp_name_descr_ = new TTCN_Typedescriptor("DefaultOp_name", DefaultOp_name_raw_, null);
	public static final TitanUniversalCharString DefaultOp_name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor DefaultOp_id_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor DefaultOp_id_descr_ = new TTCN_Typedescriptor("DefaultOp_id", DefaultOp_id_raw_, null);
	public static final TitanUniversalCharString DefaultOp_id_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultEnd_descr_ = new TTCN_Typedescriptor("DefaultEnd", null, null);
	public static final TitanUniversalCharString DefaultEnd_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultOp_end_descr_ = new TTCN_Typedescriptor("DefaultOp_end", null, null);
	public static final TitanUniversalCharString DefaultOp_end_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString DefaultOp_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopActivate_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopActivate", null, null);
	public static final TitanUniversalCharString DefaultEvent_choice_defaultopActivate_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopDeactivate_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopDeactivate", null, null);
	public static final TitanUniversalCharString DefaultEvent_choice_defaultopDeactivate_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopExit_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopExit", null, null);
	public static final TitanUniversalCharString DefaultEvent_choice_defaultopExit_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString DefaultEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString DefaultEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_defaultEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_defaultEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_defaultEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Categorized_descr_ = new TTCN_Typedescriptor("Categorized", null, null);
	public static final TTCN_RAWdescriptor Categorized_category_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Categorized_category_descr_ = new TTCN_Typedescriptor("Categorized_category", Categorized_category_raw_, null);
	public static final TitanUniversalCharString Categorized_category_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Categorized_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Categorized_text_descr_ = new TTCN_Typedescriptor("Categorized_text", Categorized_text_raw_, null);
	public static final TitanUniversalCharString Categorized_text_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Categorized_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_errorLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_errorLog", null, null);
	public static final TitanUniversalCharString LogEventType_choice_errorLog_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorEvent_descr_ = new TTCN_Typedescriptor("ExecutorEvent", null, null);
	public static final TTCN_Typedescriptor ExecutorEvent_choice_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice", null, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_descr_ = new TTCN_Typedescriptor("ExecutorRuntime", null, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_reason_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_reason", null, null);
	public static final TitanUniversalCharString ExecutorRuntime_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorRuntime_module__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_module__name_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_module__name", ExecutorRuntime_module__name_raw_, null);
	public static final TitanUniversalCharString ExecutorRuntime_module__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorRuntime_testcase__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_testcase__name_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_testcase__name", ExecutorRuntime_testcase__name_raw_, null);
	public static final TitanUniversalCharString ExecutorRuntime_testcase__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorRuntime_pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_pid_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_pid", ExecutorRuntime_pid_raw_, null);
	public static final TitanUniversalCharString ExecutorRuntime_pid_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorRuntime_fd__setsize_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorRuntime_fd__setsize_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_fd__setsize", ExecutorRuntime_fd__setsize_raw_, null);
	public static final TitanUniversalCharString ExecutorRuntime_fd__setsize_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorRuntime_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorEvent_choice_executorRuntime_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorRuntime", null, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_executorRuntime_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorConfigdata_descr_ = new TTCN_Typedescriptor("ExecutorConfigdata", null, null);
	public static final TTCN_Typedescriptor ExecutorConfigdata_reason_descr_ = new TTCN_Typedescriptor("ExecutorConfigdata_reason", null, null);
	public static final TitanUniversalCharString ExecutorConfigdata_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorConfigdata_param___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorConfigdata_param___descr_ = new TTCN_Typedescriptor("ExecutorConfigdata_param__", ExecutorConfigdata_param___raw_, null);
	public static final TitanUniversalCharString ExecutorConfigdata_param___default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorConfigdata_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorEvent_choice_executorConfigdata_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorConfigdata", null, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_executorConfigdata_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorEvent_choice_extcommandStart_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorEvent_choice_extcommandStart_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_extcommandStart", ExecutorEvent_choice_extcommandStart_raw_, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_extcommandStart_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorEvent_choice_extcommandSuccess_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorEvent_choice_extcommandSuccess_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_extcommandSuccess", ExecutorEvent_choice_extcommandSuccess_raw_, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_extcommandSuccess_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorComponent_descr_ = new TTCN_Typedescriptor("ExecutorComponent", null, null);
	public static final TTCN_Typedescriptor ExecutorComponent_reason_descr_ = new TTCN_Typedescriptor("ExecutorComponent_reason", null, null);
	public static final TitanUniversalCharString ExecutorComponent_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorComponent_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorComponent_compref_descr_ = new TTCN_Typedescriptor("ExecutorComponent_compref", ExecutorComponent_compref_raw_, null);
	public static final TitanUniversalCharString ExecutorComponent_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorComponent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorEvent_choice_executorComponent_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorComponent", null, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_executorComponent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorEvent_choice_logOptions_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorEvent_choice_logOptions_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_logOptions", ExecutorEvent_choice_logOptions_raw_, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_logOptions_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorUnqualified_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified", null, null);
	public static final TTCN_Typedescriptor ExecutorUnqualified_reason_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_reason", null, null);
	public static final TitanUniversalCharString ExecutorUnqualified_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorUnqualified_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorUnqualified_name_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_name", ExecutorUnqualified_name_raw_, null);
	public static final TitanUniversalCharString ExecutorUnqualified_name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorUnqualified_addr_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorUnqualified_addr_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_addr", ExecutorUnqualified_addr_raw_, null);
	public static final TitanUniversalCharString ExecutorUnqualified_addr_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutorUnqualified_port___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutorUnqualified_port___descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_port__", ExecutorUnqualified_port___raw_, null);
	public static final TitanUniversalCharString ExecutorUnqualified_port___default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorUnqualified_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutorEvent_choice_executorMisc_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorMisc", null, null);
	public static final TitanUniversalCharString ExecutorEvent_choice_executorMisc_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutorEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_executorEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_executorEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_executorEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FunctionEvent_descr_ = new TTCN_Typedescriptor("FunctionEvent", null, null);
	public static final TTCN_Typedescriptor FunctionEvent_choice_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice", null, null);
	public static final TTCN_RAWdescriptor FunctionEvent_choice_unqualified_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FunctionEvent_choice_unqualified_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_unqualified", FunctionEvent_choice_unqualified_raw_, null);
	public static final TitanUniversalCharString FunctionEvent_choice_unqualified_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FunctionEvent_choice_random_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random", null, null);
	public static final TTCN_Typedescriptor RandomAction_descr_ = new TTCN_Typedescriptor("RandomAction", null, null);
	public static final TitanUniversalCharString RandomAction_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FunctionEvent_choice_random_operation_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_operation", null, null);
	public static final TitanUniversalCharString FunctionEvent_choice_random_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor FunctionEvent_choice_random_retval_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FunctionEvent_choice_random_retval_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_retval", FunctionEvent_choice_random_retval_raw_, null);
	public static final TitanUniversalCharString FunctionEvent_choice_random_retval_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor FunctionEvent_choice_random_intseed_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FunctionEvent_choice_random_intseed_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_intseed", FunctionEvent_choice_random_intseed_raw_, null);
	public static final TitanUniversalCharString FunctionEvent_choice_random_intseed_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FunctionEvent_choice_random_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FunctionEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FunctionEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_functionEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_functionEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_functionEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ParallelEvent_descr_ = new TTCN_Typedescriptor("ParallelEvent", null, null);
	public static final TTCN_Typedescriptor ParallelEvent_choice_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice", null, null);
	public static final TTCN_Typedescriptor ParallelPTC_descr_ = new TTCN_Typedescriptor("ParallelPTC", null, null);
	public static final TTCN_Typedescriptor ParallelPTC_reason_descr_ = new TTCN_Typedescriptor("ParallelPTC_reason", null, null);
	public static final TitanUniversalCharString ParallelPTC_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_module___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_module___descr_ = new TTCN_Typedescriptor("ParallelPTC_module__", ParallelPTC_module___raw_, null);
	public static final TitanUniversalCharString ParallelPTC_module___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_name_descr_ = new TTCN_Typedescriptor("ParallelPTC_name", ParallelPTC_name_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_compref_descr_ = new TTCN_Typedescriptor("ParallelPTC_compref", ParallelPTC_compref_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_compname_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_compname_descr_ = new TTCN_Typedescriptor("ParallelPTC_compname", ParallelPTC_compname_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_compname_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_tc__loc_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_tc__loc_descr_ = new TTCN_Typedescriptor("ParallelPTC_tc__loc", ParallelPTC_tc__loc_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_tc__loc_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_alive__pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_alive__pid_descr_ = new TTCN_Typedescriptor("ParallelPTC_alive__pid", ParallelPTC_alive__pid_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_alive__pid_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParallelPTC_status_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParallelPTC_status_descr_ = new TTCN_Typedescriptor("ParallelPTC_status", ParallelPTC_status_raw_, null);
	public static final TitanUniversalCharString ParallelPTC_status_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ParallelPTC_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPTC_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPTC", null, null);
	public static final TitanUniversalCharString ParallelEvent_choice_parallelPTC_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PTC__exit_descr_ = new TTCN_Typedescriptor("PTC__exit", null, null);
	public static final TTCN_RAWdescriptor PTC__exit_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor PTC__exit_compref_descr_ = new TTCN_Typedescriptor("PTC__exit_compref", PTC__exit_compref_raw_, null);
	public static final TitanUniversalCharString PTC__exit_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor PTC__exit_pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor PTC__exit_pid_descr_ = new TTCN_Typedescriptor("PTC__exit_pid", PTC__exit_pid_raw_, null);
	public static final TitanUniversalCharString PTC__exit_pid_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor PTC__exit_statuscode_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor PTC__exit_statuscode_descr_ = new TTCN_Typedescriptor("PTC__exit_statuscode", PTC__exit_statuscode_raw_, null);
	public static final TitanUniversalCharString PTC__exit_statuscode_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString PTC__exit_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPTC__exit_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPTC__exit", null, null);
	public static final TitanUniversalCharString ParallelEvent_choice_parallelPTC__exit_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ParPort_descr_ = new TTCN_Typedescriptor("ParPort", null, null);
	public static final TTCN_Typedescriptor ParPort_operation_descr_ = new TTCN_Typedescriptor("ParPort_operation", null, null);
	public static final TitanUniversalCharString ParPort_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParPort_srcCompref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParPort_srcCompref_descr_ = new TTCN_Typedescriptor("ParPort_srcCompref", ParPort_srcCompref_raw_, null);
	public static final TitanUniversalCharString ParPort_srcCompref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParPort_dstCompref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParPort_dstCompref_descr_ = new TTCN_Typedescriptor("ParPort_dstCompref", ParPort_dstCompref_raw_, null);
	public static final TitanUniversalCharString ParPort_dstCompref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParPort_srcPort_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParPort_srcPort_descr_ = new TTCN_Typedescriptor("ParPort_srcPort", ParPort_srcPort_raw_, null);
	public static final TitanUniversalCharString ParPort_srcPort_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ParPort_dstPort_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ParPort_dstPort_descr_ = new TTCN_Typedescriptor("ParPort_dstPort", ParPort_dstPort_raw_, null);
	public static final TitanUniversalCharString ParPort_dstPort_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ParPort_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPort_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPort", null, null);
	public static final TitanUniversalCharString ParallelEvent_choice_parallelPort_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ParallelEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ParallelEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_parallelEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_parallelEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_parallelEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TestcaseEvent_descr_ = new TTCN_Typedescriptor("TestcaseEvent", null, null);
	public static final TTCN_Typedescriptor TestcaseEvent_choice_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice", null, null);
	public static final TTCN_Typedescriptor QualifiedName_descr_ = new TTCN_Typedescriptor("QualifiedName", null, null);
	public static final TTCN_RAWdescriptor QualifiedName_module__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor QualifiedName_module__name_descr_ = new TTCN_Typedescriptor("QualifiedName_module__name", QualifiedName_module__name_raw_, null);
	public static final TitanUniversalCharString QualifiedName_module__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor QualifiedName_testcase__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor QualifiedName_testcase__name_descr_ = new TTCN_Typedescriptor("QualifiedName_testcase__name", QualifiedName_testcase__name_raw_, null);
	public static final TitanUniversalCharString QualifiedName_testcase__name_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString QualifiedName_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TestcaseEvent_choice_testcaseStarted_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice_testcaseStarted", null, null);
	public static final TitanUniversalCharString TestcaseEvent_choice_testcaseStarted_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TestcaseType_descr_ = new TTCN_Typedescriptor("TestcaseType", null, null);
	public static final TTCN_Typedescriptor TestcaseType_name_descr_ = new TTCN_Typedescriptor("TestcaseType_name", null, null);
	public static final TitanUniversalCharString TestcaseType_name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Verdict_descr_ = new TTCN_Typedescriptor("Verdict", null, null);
	public static final TitanUniversalCharString Verdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TestcaseType_verdict_descr_ = new TTCN_Typedescriptor("TestcaseType_verdict", null, null);
	public static final TitanUniversalCharString TestcaseType_verdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor TestcaseType_reason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TestcaseType_reason_descr_ = new TTCN_Typedescriptor("TestcaseType_reason", TestcaseType_reason_raw_, null);
	public static final TitanUniversalCharString TestcaseType_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TestcaseType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TestcaseEvent_choice_testcaseFinished_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice_testcaseFinished", null, null);
	public static final TitanUniversalCharString TestcaseEvent_choice_testcaseFinished_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TestcaseEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TestcaseEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_testcaseOp_descr_ = new TTCN_Typedescriptor("LogEventType_choice_testcaseOp", null, null);
	public static final TitanUniversalCharString LogEventType_choice_testcaseOp_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_descr_ = new TTCN_Typedescriptor("PortEvent", null, null);
	public static final TTCN_Typedescriptor PortEvent_choice_descr_ = new TTCN_Typedescriptor("PortEvent_choice", null, null);
	public static final TTCN_Typedescriptor Port__Queue_descr_ = new TTCN_Typedescriptor("Port__Queue", null, null);
	public static final TTCN_Typedescriptor Port__Queue_operation_descr_ = new TTCN_Typedescriptor("Port__Queue_operation", null, null);
	public static final TitanUniversalCharString Port__Queue_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Queue_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Queue_port__name_descr_ = new TTCN_Typedescriptor("Port__Queue_port__name", Port__Queue_port__name_raw_, null);
	public static final TitanUniversalCharString Port__Queue_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Queue_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Queue_compref_descr_ = new TTCN_Typedescriptor("Port__Queue_compref", Port__Queue_compref_raw_, null);
	public static final TitanUniversalCharString Port__Queue_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Queue_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Queue_msgid_descr_ = new TTCN_Typedescriptor("Port__Queue_msgid", Port__Queue_msgid_raw_, null);
	public static final TitanUniversalCharString Port__Queue_msgid_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Queue_address___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Queue_address___descr_ = new TTCN_Typedescriptor("Port__Queue_address__", Port__Queue_address___raw_, null);
	public static final TitanUniversalCharString Port__Queue_address___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Queue_param___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Queue_param___descr_ = new TTCN_Typedescriptor("Port__Queue_param__", Port__Queue_param___raw_, null);
	public static final TitanUniversalCharString Port__Queue_param___default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Port__Queue_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_portQueue_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portQueue", null, null);
	public static final TitanUniversalCharString PortEvent_choice_portQueue_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Port__State_descr_ = new TTCN_Typedescriptor("Port__State", null, null);
	public static final TTCN_Typedescriptor Port__State_operation_descr_ = new TTCN_Typedescriptor("Port__State_operation", null, null);
	public static final TitanUniversalCharString Port__State_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__State_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__State_port__name_descr_ = new TTCN_Typedescriptor("Port__State_port__name", Port__State_port__name_raw_, null);
	public static final TitanUniversalCharString Port__State_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Port__State_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_portState_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portState", null, null);
	public static final TitanUniversalCharString PortEvent_choice_portState_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Proc__port__out_descr_ = new TTCN_Typedescriptor("Proc__port__out", null, null);
	public static final TTCN_RAWdescriptor Proc__port__out_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__out_port__name_descr_ = new TTCN_Typedescriptor("Proc__port__out_port__name", Proc__port__out_port__name_raw_, null);
	public static final TitanUniversalCharString Proc__port__out_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Port__oper_descr_ = new TTCN_Typedescriptor("Port__oper", null, null);
	public static final TitanUniversalCharString Port__oper_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Proc__port__out_operation_descr_ = new TTCN_Typedescriptor("Proc__port__out_operation", null, null);
	public static final TitanUniversalCharString Proc__port__out_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__out_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__out_compref_descr_ = new TTCN_Typedescriptor("Proc__port__out_compref", Proc__port__out_compref_raw_, null);
	public static final TitanUniversalCharString Proc__port__out_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__out_sys__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__out_sys__name_descr_ = new TTCN_Typedescriptor("Proc__port__out_sys__name", Proc__port__out_sys__name_raw_, null);
	public static final TitanUniversalCharString Proc__port__out_sys__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__out_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__out_parameter_descr_ = new TTCN_Typedescriptor("Proc__port__out_parameter", Proc__port__out_parameter_raw_, null);
	public static final TitanUniversalCharString Proc__port__out_parameter_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Proc__port__out_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_procPortSend_descr_ = new TTCN_Typedescriptor("PortEvent_choice_procPortSend", null, null);
	public static final TitanUniversalCharString PortEvent_choice_procPortSend_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Proc__port__in_descr_ = new TTCN_Typedescriptor("Proc__port__in", null, null);
	public static final TTCN_RAWdescriptor Proc__port__in_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__in_port__name_descr_ = new TTCN_Typedescriptor("Proc__port__in_port__name", Proc__port__in_port__name_raw_, null);
	public static final TitanUniversalCharString Proc__port__in_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Proc__port__in_operation_descr_ = new TTCN_Typedescriptor("Proc__port__in_operation", null, null);
	public static final TitanUniversalCharString Proc__port__in_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__in_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__in_compref_descr_ = new TTCN_Typedescriptor("Proc__port__in_compref", Proc__port__in_compref_raw_, null);
	public static final TitanUniversalCharString Proc__port__in_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__in_check___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__in_check___descr_ = new TTCN_Typedescriptor("Proc__port__in_check__", Proc__port__in_check___raw_, null);
	public static final TitanUniversalCharString Proc__port__in_check___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__in_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__in_parameter_descr_ = new TTCN_Typedescriptor("Proc__port__in_parameter", Proc__port__in_parameter_raw_, null);
	public static final TitanUniversalCharString Proc__port__in_parameter_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Proc__port__in_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Proc__port__in_msgid_descr_ = new TTCN_Typedescriptor("Proc__port__in_msgid", Proc__port__in_msgid_raw_, null);
	public static final TitanUniversalCharString Proc__port__in_msgid_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Proc__port__in_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_procPortRecv_descr_ = new TTCN_Typedescriptor("PortEvent_choice_procPortRecv", null, null);
	public static final TitanUniversalCharString PortEvent_choice_procPortRecv_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Msg__port__send_descr_ = new TTCN_Typedescriptor("Msg__port__send", null, null);
	public static final TTCN_RAWdescriptor Msg__port__send_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__send_port__name_descr_ = new TTCN_Typedescriptor("Msg__port__send_port__name", Msg__port__send_port__name_raw_, null);
	public static final TitanUniversalCharString Msg__port__send_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__send_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__send_compref_descr_ = new TTCN_Typedescriptor("Msg__port__send_compref", Msg__port__send_compref_raw_, null);
	public static final TitanUniversalCharString Msg__port__send_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__send_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__send_parameter_descr_ = new TTCN_Typedescriptor("Msg__port__send_parameter", Msg__port__send_parameter_raw_, null);
	public static final TitanUniversalCharString Msg__port__send_parameter_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Msg__port__send_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_msgPortSend_descr_ = new TTCN_Typedescriptor("PortEvent_choice_msgPortSend", null, null);
	public static final TitanUniversalCharString PortEvent_choice_msgPortSend_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Msg__port__recv_descr_ = new TTCN_Typedescriptor("Msg__port__recv", null, null);
	public static final TTCN_RAWdescriptor Msg__port__recv_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__recv_port__name_descr_ = new TTCN_Typedescriptor("Msg__port__recv_port__name", Msg__port__recv_port__name_raw_, null);
	public static final TitanUniversalCharString Msg__port__recv_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Msg__port__recv_operation_descr_ = new TTCN_Typedescriptor("Msg__port__recv_operation", null, null);
	public static final TitanUniversalCharString Msg__port__recv_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__recv_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__recv_compref_descr_ = new TTCN_Typedescriptor("Msg__port__recv_compref", Msg__port__recv_compref_raw_, null);
	public static final TitanUniversalCharString Msg__port__recv_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__recv_sys__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__recv_sys__name_descr_ = new TTCN_Typedescriptor("Msg__port__recv_sys__name", Msg__port__recv_sys__name_raw_, null);
	public static final TitanUniversalCharString Msg__port__recv_sys__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__recv_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__recv_parameter_descr_ = new TTCN_Typedescriptor("Msg__port__recv_parameter", Msg__port__recv_parameter_raw_, null);
	public static final TitanUniversalCharString Msg__port__recv_parameter_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Msg__port__recv_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Msg__port__recv_msgid_descr_ = new TTCN_Typedescriptor("Msg__port__recv_msgid", Msg__port__recv_msgid_raw_, null);
	public static final TitanUniversalCharString Msg__port__recv_msgid_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Msg__port__recv_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_msgPortRecv_descr_ = new TTCN_Typedescriptor("PortEvent_choice_msgPortRecv", null, null);
	public static final TitanUniversalCharString PortEvent_choice_msgPortRecv_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Dualface__mapped_descr_ = new TTCN_Typedescriptor("Dualface__mapped", null, null);
	public static final TTCN_RAWdescriptor Dualface__mapped_incoming_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__mapped_incoming_descr_ = new TTCN_Typedescriptor("Dualface__mapped_incoming", Dualface__mapped_incoming_raw_, null);
	public static final TitanUniversalCharString Dualface__mapped_incoming_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__mapped_target__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__mapped_target__type_descr_ = new TTCN_Typedescriptor("Dualface__mapped_target__type", Dualface__mapped_target__type_raw_, null);
	public static final TitanUniversalCharString Dualface__mapped_target__type_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__mapped_value___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__mapped_value___descr_ = new TTCN_Typedescriptor("Dualface__mapped_value__", Dualface__mapped_value___raw_, null);
	public static final TitanUniversalCharString Dualface__mapped_value___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__mapped_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__mapped_msgid_descr_ = new TTCN_Typedescriptor("Dualface__mapped_msgid", Dualface__mapped_msgid_raw_, null);
	public static final TitanUniversalCharString Dualface__mapped_msgid_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Dualface__mapped_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_dualMapped_descr_ = new TTCN_Typedescriptor("PortEvent_choice_dualMapped", null, null);
	public static final TitanUniversalCharString PortEvent_choice_dualMapped_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Dualface__discard_descr_ = new TTCN_Typedescriptor("Dualface__discard", null, null);
	public static final TTCN_RAWdescriptor Dualface__discard_incoming_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__discard_incoming_descr_ = new TTCN_Typedescriptor("Dualface__discard_incoming", Dualface__discard_incoming_raw_, null);
	public static final TitanUniversalCharString Dualface__discard_incoming_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__discard_target__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__discard_target__type_descr_ = new TTCN_Typedescriptor("Dualface__discard_target__type", Dualface__discard_target__type_raw_, null);
	public static final TitanUniversalCharString Dualface__discard_target__type_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__discard_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__discard_port__name_descr_ = new TTCN_Typedescriptor("Dualface__discard_port__name", Dualface__discard_port__name_raw_, null);
	public static final TitanUniversalCharString Dualface__discard_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Dualface__discard_unhandled_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Dualface__discard_unhandled_descr_ = new TTCN_Typedescriptor("Dualface__discard_unhandled", Dualface__discard_unhandled_raw_, null);
	public static final TitanUniversalCharString Dualface__discard_unhandled_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Dualface__discard_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_dualDiscard_descr_ = new TTCN_Typedescriptor("PortEvent_choice_dualDiscard", null, null);
	public static final TitanUniversalCharString PortEvent_choice_dualDiscard_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Setstate_descr_ = new TTCN_Typedescriptor("Setstate", null, null);
	public static final TTCN_RAWdescriptor Setstate_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Setstate_port__name_descr_ = new TTCN_Typedescriptor("Setstate_port__name", Setstate_port__name_raw_, null);
	public static final TitanUniversalCharString Setstate_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Setstate_state_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Setstate_state_descr_ = new TTCN_Typedescriptor("Setstate_state", Setstate_state_raw_, null);
	public static final TitanUniversalCharString Setstate_state_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Setstate_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Setstate_info_descr_ = new TTCN_Typedescriptor("Setstate_info", Setstate_info_raw_, null);
	public static final TitanUniversalCharString Setstate_info_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Setstate_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_setState_descr_ = new TTCN_Typedescriptor("PortEvent_choice_setState", null, null);
	public static final TitanUniversalCharString PortEvent_choice_setState_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Port__Misc_descr_ = new TTCN_Typedescriptor("Port__Misc", null, null);
	public static final TTCN_Typedescriptor Port__Misc_reason_descr_ = new TTCN_Typedescriptor("Port__Misc_reason", null, null);
	public static final TitanUniversalCharString Port__Misc_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_port__name_descr_ = new TTCN_Typedescriptor("Port__Misc_port__name", Port__Misc_port__name_raw_, null);
	public static final TitanUniversalCharString Port__Misc_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_remote__component_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_remote__component_descr_ = new TTCN_Typedescriptor("Port__Misc_remote__component", Port__Misc_remote__component_raw_, null);
	public static final TitanUniversalCharString Port__Misc_remote__component_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_remote__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_remote__port_descr_ = new TTCN_Typedescriptor("Port__Misc_remote__port", Port__Misc_remote__port_raw_, null);
	public static final TitanUniversalCharString Port__Misc_remote__port_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_ip__address_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_ip__address_descr_ = new TTCN_Typedescriptor("Port__Misc_ip__address", Port__Misc_ip__address_raw_, null);
	public static final TitanUniversalCharString Port__Misc_ip__address_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_tcp__port_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_tcp__port_descr_ = new TTCN_Typedescriptor("Port__Misc_tcp__port", Port__Misc_tcp__port_raw_, null);
	public static final TitanUniversalCharString Port__Misc_tcp__port_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Port__Misc_new__size_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Port__Misc_new__size_descr_ = new TTCN_Typedescriptor("Port__Misc_new__size", Port__Misc_new__size_raw_, null);
	public static final TitanUniversalCharString Port__Misc_new__size_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Port__Misc_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor PortEvent_choice_portMisc_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portMisc", null, null);
	public static final TitanUniversalCharString PortEvent_choice_portMisc_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString PortEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString PortEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_portEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_portEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_portEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor StatisticsType_descr_ = new TTCN_Typedescriptor("StatisticsType", null, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_descr_ = new TTCN_Typedescriptor("StatisticsType_choice", null, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics", null, null);
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_none___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_none___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_none__", StatisticsType_choice_verdictStatistics_none___raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_none___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_nonePercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_nonePercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_nonePercent", StatisticsType_choice_verdictStatistics_nonePercent_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_nonePercent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_pass___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_pass___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_pass__", StatisticsType_choice_verdictStatistics_pass___raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_pass___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_passPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_passPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_passPercent", StatisticsType_choice_verdictStatistics_passPercent_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_passPercent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_inconc___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_inconc___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_inconc__", StatisticsType_choice_verdictStatistics_inconc___raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_inconc___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_inconcPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_inconcPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_inconcPercent", StatisticsType_choice_verdictStatistics_inconcPercent_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_inconcPercent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_fail___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_fail___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_fail__", StatisticsType_choice_verdictStatistics_fail___raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_fail___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_failPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_failPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_failPercent", StatisticsType_choice_verdictStatistics_failPercent_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_failPercent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_error___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_error___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_error__", StatisticsType_choice_verdictStatistics_error___raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_error___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_errorPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_errorPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_errorPercent", StatisticsType_choice_verdictStatistics_errorPercent_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_errorPercent_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartStart_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_controlpartStart_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartStart", StatisticsType_choice_controlpartStart_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_controlpartStart_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartFinish_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_controlpartFinish_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartFinish", StatisticsType_choice_controlpartFinish_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_controlpartFinish_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartErrors_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StatisticsType_choice_controlpartErrors_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartErrors", StatisticsType_choice_controlpartErrors_raw_, null);
	public static final TitanUniversalCharString StatisticsType_choice_controlpartErrors_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString StatisticsType_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString StatisticsType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_statistics_descr_ = new TTCN_Typedescriptor("LogEventType_choice_statistics", null, null);
	public static final TitanUniversalCharString LogEventType_choice_statistics_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_descr_ = new TTCN_Typedescriptor("TimerEvent", null, null);
	public static final TTCN_Typedescriptor TimerEvent_choice_descr_ = new TTCN_Typedescriptor("TimerEvent_choice", null, null);
	public static final TTCN_Typedescriptor TimerType_descr_ = new TTCN_Typedescriptor("TimerType", null, null);
	public static final TTCN_RAWdescriptor TimerType_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimerType_name_descr_ = new TTCN_Typedescriptor("TimerType_name", TimerType_name_raw_, null);
	public static final TitanUniversalCharString TimerType_name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor TimerType_value___raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimerType_value___descr_ = new TTCN_Typedescriptor("TimerType_value__", TimerType_value___raw_, null);
	public static final TitanUniversalCharString TimerType_value___default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TimerType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_readTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_readTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_readTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_startTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_startTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_startTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerGuardType_descr_ = new TTCN_Typedescriptor("TimerGuardType", null, null);
	public static final TTCN_RAWdescriptor TimerGuardType_value___raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimerGuardType_value___descr_ = new TTCN_Typedescriptor("TimerGuardType_value__", TimerGuardType_value___raw_, null);
	public static final TitanUniversalCharString TimerGuardType_value___default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TimerGuardType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_guardTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_guardTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_guardTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_stopTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_stopTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_stopTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_timeoutTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_timeoutTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_timeoutTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerAnyTimeoutType_descr_ = new TTCN_Typedescriptor("TimerAnyTimeoutType", null, null);
	public static final TitanUniversalCharString TimerAnyTimeoutType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TimerEvent_choice_timeoutAnyTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_timeoutAnyTimer", null, null);
	public static final TitanUniversalCharString TimerEvent_choice_timeoutAnyTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor TimerEvent_choice_unqualifiedTimer_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor TimerEvent_choice_unqualifiedTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_unqualifiedTimer", TimerEvent_choice_unqualifiedTimer_raw_, null);
	public static final TitanUniversalCharString TimerEvent_choice_unqualifiedTimer_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TimerEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TimerEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_timerEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_timerEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_timerEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_userLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_userLog", null, null);
	public static final TitanUniversalCharString LogEventType_choice_userLog_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictOp_descr_ = new TTCN_Typedescriptor("VerdictOp", null, null);
	public static final TTCN_Typedescriptor VerdictOp_choice_descr_ = new TTCN_Typedescriptor("VerdictOp_choice", null, null);
	public static final TTCN_Typedescriptor SetVerdictType_descr_ = new TTCN_Typedescriptor("SetVerdictType", null, null);
	public static final TTCN_Typedescriptor SetVerdictType_newVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_newVerdict", null, null);
	public static final TitanUniversalCharString SetVerdictType_newVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor SetVerdictType_oldVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_oldVerdict", null, null);
	public static final TitanUniversalCharString SetVerdictType_oldVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor SetVerdictType_localVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_localVerdict", null, null);
	public static final TitanUniversalCharString SetVerdictType_localVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor SetVerdictType_oldReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor SetVerdictType_oldReason_descr_ = new TTCN_Typedescriptor("SetVerdictType_oldReason", SetVerdictType_oldReason_raw_, null);
	public static final TitanUniversalCharString SetVerdictType_oldReason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor SetVerdictType_newReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor SetVerdictType_newReason_descr_ = new TTCN_Typedescriptor("SetVerdictType_newReason", SetVerdictType_newReason_raw_, null);
	public static final TitanUniversalCharString SetVerdictType_newReason_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString SetVerdictType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictOp_choice_setVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_setVerdict", null, null);
	public static final TitanUniversalCharString VerdictOp_choice_setVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictOp_choice_getVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_getVerdict", null, null);
	public static final TitanUniversalCharString VerdictOp_choice_getVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictType_descr_ = new TTCN_Typedescriptor("FinalVerdictType", null, null);
	public static final TTCN_Typedescriptor FinalVerdictType_choice_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice", null, null);
	public static final TTCN_Typedescriptor FinalVerdictInfo_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo", null, null);
	public static final TTCN_RAWdescriptor FinalVerdictInfo_is__ptc_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FinalVerdictInfo_is__ptc_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_is__ptc", FinalVerdictInfo_is__ptc_raw_, null);
	public static final TitanUniversalCharString FinalVerdictInfo_is__ptc_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__verdict", null, null);
	public static final TitanUniversalCharString FinalVerdictInfo_ptc__verdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictInfo_local__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_local__verdict", null, null);
	public static final TitanUniversalCharString FinalVerdictInfo_local__verdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictInfo_new__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_new__verdict", null, null);
	public static final TitanUniversalCharString FinalVerdictInfo_new__verdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor FinalVerdictInfo_verdict__reason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FinalVerdictInfo_verdict__reason_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_verdict__reason", FinalVerdictInfo_verdict__reason_raw_, null);
	public static final TitanUniversalCharString FinalVerdictInfo_verdict__reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor FinalVerdictInfo_ptc__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__compref_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__compref", FinalVerdictInfo_ptc__compref_raw_, null);
	public static final TitanUniversalCharString FinalVerdictInfo_ptc__compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor FinalVerdictInfo_ptc__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__name_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__name", FinalVerdictInfo_ptc__name_raw_, null);
	public static final TitanUniversalCharString FinalVerdictInfo_ptc__name_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FinalVerdictInfo_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictType_choice_info_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice_info", null, null);
	public static final TitanUniversalCharString FinalVerdictType_choice_info_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor FinalVerdictType_choice_notification_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice_notification", null, null);
	public static final TitanUniversalCharString FinalVerdictType_choice_notification_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FinalVerdictType_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString FinalVerdictType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictOp_choice_finalVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_finalVerdict", null, null);
	public static final TitanUniversalCharString VerdictOp_choice_finalVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString VerdictOp_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString VerdictOp_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_verdictOp_descr_ = new TTCN_Typedescriptor("LogEventType_choice_verdictOp", null, null);
	public static final TitanUniversalCharString LogEventType_choice_verdictOp_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_warningLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_warningLog", null, null);
	public static final TitanUniversalCharString LogEventType_choice_warningLog_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_descr_ = new TTCN_Typedescriptor("MatchingEvent", null, null);
	public static final TTCN_Typedescriptor MatchingEvent_choice_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice", null, null);
	public static final TTCN_Typedescriptor MatchingDoneType_descr_ = new TTCN_Typedescriptor("MatchingDoneType", null, null);
	public static final TTCN_Typedescriptor MatchingDoneType_reason_descr_ = new TTCN_Typedescriptor("MatchingDoneType_reason", null, null);
	public static final TitanUniversalCharString MatchingDoneType_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingDoneType_type___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingDoneType_type___descr_ = new TTCN_Typedescriptor("MatchingDoneType_type__", MatchingDoneType_type___raw_, null);
	public static final TitanUniversalCharString MatchingDoneType_type___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingDoneType_ptc_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingDoneType_ptc_descr_ = new TTCN_Typedescriptor("MatchingDoneType_ptc", MatchingDoneType_ptc_raw_, null);
	public static final TitanUniversalCharString MatchingDoneType_ptc_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingDoneType_return__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingDoneType_return__type_descr_ = new TTCN_Typedescriptor("MatchingDoneType_return__type", MatchingDoneType_return__type_raw_, null);
	public static final TitanUniversalCharString MatchingDoneType_return__type_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingDoneType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_choice_matchingDone_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingDone", null, null);
	public static final TitanUniversalCharString MatchingEvent_choice_matchingDone_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingSuccessType_descr_ = new TTCN_Typedescriptor("MatchingSuccessType", null, null);
	public static final TTCN_Typedescriptor PortType_descr_ = new TTCN_Typedescriptor("PortType", null, null);
	public static final TitanUniversalCharString PortType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingSuccessType_port__type_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_port__type", null, null);
	public static final TitanUniversalCharString MatchingSuccessType_port__type_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingSuccessType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingSuccessType_port__name_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_port__name", MatchingSuccessType_port__name_raw_, null);
	public static final TitanUniversalCharString MatchingSuccessType_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingSuccessType_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingSuccessType_info_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_info", MatchingSuccessType_info_raw_, null);
	public static final TitanUniversalCharString MatchingSuccessType_info_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingSuccessType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_choice_matchingSuccess_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingSuccess", null, null);
	public static final TitanUniversalCharString MatchingEvent_choice_matchingSuccess_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingFailureType_descr_ = new TTCN_Typedescriptor("MatchingFailureType", null, null);
	public static final TTCN_Typedescriptor MatchingFailureType_port__type_descr_ = new TTCN_Typedescriptor("MatchingFailureType_port__type", null, null);
	public static final TitanUniversalCharString MatchingFailureType_port__type_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingFailureType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingFailureType_port__name_descr_ = new TTCN_Typedescriptor("MatchingFailureType_port__name", MatchingFailureType_port__name_raw_, null);
	public static final TitanUniversalCharString MatchingFailureType_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingFailureType_choice_descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice", null, null);
	public static final TTCN_RAWdescriptor MatchingFailureType_choice_system___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingFailureType_choice_system___descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice_system__", MatchingFailureType_choice_system___raw_, null);
	public static final TitanUniversalCharString MatchingFailureType_choice_system___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingFailureType_choice_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingFailureType_choice_compref_descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice_compref", MatchingFailureType_choice_compref_raw_, null);
	public static final TitanUniversalCharString MatchingFailureType_choice_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingFailureType_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingFailureType_reason_descr_ = new TTCN_Typedescriptor("MatchingFailureType_reason", null, null);
	public static final TitanUniversalCharString MatchingFailureType_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingFailureType_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingFailureType_info_descr_ = new TTCN_Typedescriptor("MatchingFailureType_info", MatchingFailureType_info_raw_, null);
	public static final TitanUniversalCharString MatchingFailureType_info_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingFailureType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_choice_matchingFailure_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingFailure", null, null);
	public static final TitanUniversalCharString MatchingEvent_choice_matchingFailure_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingProblemType_descr_ = new TTCN_Typedescriptor("MatchingProblemType", null, null);
	public static final TTCN_RAWdescriptor MatchingProblemType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingProblemType_port__name_descr_ = new TTCN_Typedescriptor("MatchingProblemType_port__name", MatchingProblemType_port__name_raw_, null);
	public static final TitanUniversalCharString MatchingProblemType_port__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingProblemType_reason_descr_ = new TTCN_Typedescriptor("MatchingProblemType_reason", null, null);
	public static final TitanUniversalCharString MatchingProblemType_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingProblemType_operation_descr_ = new TTCN_Typedescriptor("MatchingProblemType_operation", null, null);
	public static final TitanUniversalCharString MatchingProblemType_operation_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingProblemType_check___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingProblemType_check___descr_ = new TTCN_Typedescriptor("MatchingProblemType_check__", MatchingProblemType_check___raw_, null);
	public static final TitanUniversalCharString MatchingProblemType_check___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor MatchingProblemType_any__port_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingProblemType_any__port_descr_ = new TTCN_Typedescriptor("MatchingProblemType_any__port", MatchingProblemType_any__port_raw_, null);
	public static final TitanUniversalCharString MatchingProblemType_any__port_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingProblemType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_choice_matchingProblem_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingProblem", null, null);
	public static final TitanUniversalCharString MatchingEvent_choice_matchingProblem_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingTimeout_descr_ = new TTCN_Typedescriptor("MatchingTimeout", null, null);
	public static final TTCN_RAWdescriptor MatchingTimeout_timer__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor MatchingTimeout_timer__name_descr_ = new TTCN_Typedescriptor("MatchingTimeout_timer__name", MatchingTimeout_timer__name_raw_, null);
	public static final TitanUniversalCharString MatchingTimeout_timer__name_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingTimeout_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor MatchingEvent_choice_matchingTimeout_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingTimeout", null, null);
	public static final TitanUniversalCharString MatchingEvent_choice_matchingTimeout_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingEvent_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString MatchingEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_matchingEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_matchingEvent", null, null);
	public static final TitanUniversalCharString LogEventType_choice_matchingEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_debugLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_debugLog", null, null);
	public static final TitanUniversalCharString LogEventType_choice_debugLog_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ExecutionSummaryType_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType", null, null);
	public static final TTCN_RAWdescriptor ExecutionSummaryType_numberOfTestcases_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutionSummaryType_numberOfTestcases_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType_numberOfTestcases", ExecutionSummaryType_numberOfTestcases_raw_, null);
	public static final TitanUniversalCharString ExecutionSummaryType_numberOfTestcases_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor ExecutionSummaryType_overallStatistics_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ExecutionSummaryType_overallStatistics_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType_overallStatistics", ExecutionSummaryType_overallStatistics_raw_, null);
	public static final TitanUniversalCharString ExecutionSummaryType_overallStatistics_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ExecutionSummaryType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor LogEventType_choice_executionSummary_descr_ = new TTCN_Typedescriptor("LogEventType_choice_executionSummary", null, null);
	public static final TitanUniversalCharString LogEventType_choice_executionSummary_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor LogEventType_choice_unhandledEvent_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor LogEventType_choice_unhandledEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_unhandledEvent", LogEventType_choice_unhandledEvent_raw_, null);
	public static final TitanUniversalCharString LogEventType_choice_unhandledEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString LogEventType_choice_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString LogEventType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLogEvent_logEvent_descr_ = new TTCN_Typedescriptor("TitanLogEvent_logEvent", null, null);
	public static final TitanUniversalCharString TitanLogEvent_logEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TitanLogEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLog_sequence__list_0_event__list_0_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_event__list_0", null, null);
	public static final TitanUniversalCharString TitanLog_sequence__list_0_event__list_0_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLog_sequence__list_0_event__list_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_event__list", null, null);
	public static final TitanUniversalCharString TitanLog_sequence__list_0_event__list_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TitanLog_sequence__list_0_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanLog_sequence__list_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list", null, null);
	public static final TitanUniversalCharString TitanLog_sequence__list_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TitanLog_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanSingleLogEvent_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent", null, null);
	public static final TTCN_Typedescriptor TitanSingleLogEvent_entityId_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent_entityId", null, null);
	public static final TitanUniversalCharString TitanSingleLogEvent_entityId_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor TitanSingleLogEvent_event_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent_event", null, null);
	public static final TitanUniversalCharString TitanSingleLogEvent_event_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString TitanSingleLogEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor ErrorEvent_descr_ = new TTCN_Typedescriptor("ErrorEvent", null, null);
	public static final TTCN_RAWdescriptor ErrorEvent_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor ErrorEvent_text_descr_ = new TTCN_Typedescriptor("ErrorEvent_text", ErrorEvent_text_raw_, null);
	public static final TitanUniversalCharString ErrorEvent_text_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString ErrorEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor WarningEvent_descr_ = new TTCN_Typedescriptor("WarningEvent", null, null);
	public static final TTCN_RAWdescriptor WarningEvent_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor WarningEvent_text_descr_ = new TTCN_Typedescriptor("WarningEvent_text", WarningEvent_text_raw_, null);
	public static final TitanUniversalCharString WarningEvent_text_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString WarningEvent_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictType_descr_ = new TTCN_Typedescriptor("VerdictType", null, null);
	public static final TTCN_Typedescriptor VerdictType_fromVerdict_descr_ = new TTCN_Typedescriptor("VerdictType_fromVerdict", null, null);
	public static final TitanUniversalCharString VerdictType_fromVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor VerdictType_toVerdict_descr_ = new TTCN_Typedescriptor("VerdictType_toVerdict", null, null);
	public static final TitanUniversalCharString VerdictType_toVerdict_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor VerdictType_verdictReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor VerdictType_verdictReason_descr_ = new TTCN_Typedescriptor("VerdictType_verdictReason", VerdictType_verdictReason_raw_, null);
	public static final TitanUniversalCharString VerdictType_verdictReason_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString VerdictType_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor Parallel_descr_ = new TTCN_Typedescriptor("Parallel", null, null);
	public static final TTCN_Typedescriptor Parallel_reason_descr_ = new TTCN_Typedescriptor("Parallel_reason", null, null);
	public static final TitanUniversalCharString Parallel_reason_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_alive___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_alive___descr_ = new TTCN_Typedescriptor("Parallel_alive__", Parallel_alive___raw_, null);
	public static final TitanUniversalCharString Parallel_alive___default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_function__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_function__name_descr_ = new TTCN_Typedescriptor("Parallel_function__name", Parallel_function__name_raw_, null);
	public static final TitanUniversalCharString Parallel_function__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_src__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_src__compref_descr_ = new TTCN_Typedescriptor("Parallel_src__compref", Parallel_src__compref_raw_, null);
	public static final TitanUniversalCharString Parallel_src__compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_src__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_src__port_descr_ = new TTCN_Typedescriptor("Parallel_src__port", Parallel_src__port_raw_, null);
	public static final TitanUniversalCharString Parallel_src__port_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_dst__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_dst__compref_descr_ = new TTCN_Typedescriptor("Parallel_dst__compref", Parallel_dst__compref_raw_, null);
	public static final TitanUniversalCharString Parallel_dst__compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor Parallel_dst__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor Parallel_dst__port_descr_ = new TTCN_Typedescriptor("Parallel_dst__port", Parallel_dst__port_raw_, null);
	public static final TitanUniversalCharString Parallel_dst__port_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString Parallel_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor StartFunction_descr_ = new TTCN_Typedescriptor("StartFunction", null, null);
	public static final TTCN_RAWdescriptor StartFunction_function__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StartFunction_function__name_descr_ = new TTCN_Typedescriptor("StartFunction_function__name", StartFunction_function__name_raw_, null);
	public static final TitanUniversalCharString StartFunction_function__name_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StartFunction_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StartFunction_compref_descr_ = new TTCN_Typedescriptor("StartFunction_compref", StartFunction_compref_raw_, null);
	public static final TitanUniversalCharString StartFunction_compref_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_RAWdescriptor StartFunction_parameter__list_0_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
	public static final TTCN_Typedescriptor StartFunction_parameter__list_0_descr_ = new TTCN_Typedescriptor("StartFunction_parameter__list_0", StartFunction_parameter__list_0_raw_, null);
	public static final TitanUniversalCharString StartFunction_parameter__list_0_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor StartFunction_parameter__list_descr_ = new TTCN_Typedescriptor("StartFunction_parameter__list", null, null);
	public static final TitanUniversalCharString StartFunction_parameter__list_default_coding = new TitanUniversalCharString("XER");
	public static final TitanUniversalCharString StartFunction_default_coding = new TitanUniversalCharString("XER");
	public static final TTCN_Typedescriptor anytype_descr_ = new TTCN_Typedescriptor("anytype", null, null);
	public static final TitanUniversalCharString anytype_default_coding = new TitanUniversalCharString("XER");

	public TitanLoggerApi() {
		super("TitanLoggerApi", moduleTypeEnum.TTCN3_MODULE);
	}

	public static void VerdictOp_choice_getVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictOp_choice_getVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictOp_choice_getVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictOp_choice_getVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingEvent_choice_matchingFailure_encoder(final MatchingFailureType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_matchingFailure_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_matchingFailure_decoder( final TitanOctetString input_stream, final MatchingFailureType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_matchingFailure_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__mapped_incoming_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__mapped_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__mapped_incoming_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__mapped_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Categorized_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Categorized_text_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Categorized_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Categorized_text_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_portMisc_encoder(final Port__Misc input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_portMisc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_portMisc_decoder( final TitanOctetString input_stream, final Port__Misc output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_portMisc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_setState_encoder(final Setstate input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_setState_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_setState_decoder( final TitanOctetString input_stream, final Setstate output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_setState_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_dst__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_dst__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_dst__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_dst__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class DefaultOp extends Base_Type {
		private final TitanCharString name; //CharString_Type
		private final TitanInteger id; //Integer_Type
		private final DefaultEnd end; //Referenced_Type

		public DefaultOp() {
			this.name = new TitanCharString();
			this.id = new TitanInteger();
			this.end = new DefaultEnd();
		}

		public DefaultOp(final TitanCharString name, final TitanInteger id, final DefaultEnd end ) {
			this.name = new TitanCharString( name );
			this.id = new TitanInteger( id );
			this.end = new DefaultEnd( end );
		}

		public DefaultOp( final DefaultOp otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.DefaultOp.");
			}
			name = new TitanCharString();
			id = new TitanInteger();
			end = new DefaultEnd();
			assign( otherValue );
		}

		public DefaultOp assign(final DefaultOp otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.DefaultOp");
			}

			if (otherValue != this) {
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
				if ( otherValue.getid().isBound() ) {
					this.id.assign( otherValue.getid() );
				} else {
					this.id.cleanUp();
				}
				if ( otherValue.getend().isBound() ) {
					this.end.assign( otherValue.getend() );
				} else {
					this.end.cleanUp();
				}
			}

			return this;
		}

		@Override
		public DefaultOp assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp ) {
				return assign((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultOp", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			id.cleanUp();
			end.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( id.isBound() ) { return true; }
			if ( end.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !id.isValue() ) { return false; }
			if ( !end.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final DefaultOp otherValue) {
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			if ( !this.id.operatorEquals( otherValue.id ) ) { return false; }
			if ( !this.end.operatorEquals( otherValue.end ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp ) {
				return operatorEquals((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultOp", otherValue));
		}

		public TitanCharString getname() {
			return name;
		}

		public TitanCharString constGetname() {
			return name;
		}

		public TitanInteger getid() {
			return id;
		}

		public TitanInteger constGetid() {
			return id;
		}

		public DefaultEnd getend() {
			return end;
		}

		public DefaultEnd constGetend() {
			return end;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" id := ");
			id.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" end := ");
			end.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.DefaultOp has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getid().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getend().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("id".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("end".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getend().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.DefaultOp: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.DefaultOp");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (id.isBound()) {
				id.set_implicit_omit();
			}
			if (end.isBound()) {
				end.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			id.encode_text(text_buf);
			end.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			id.decode_text(text_buf);
			end.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class DefaultOp_template extends Base_Template {

		private TitanCharString_template name; //CharString_Type
		private TitanInteger_template id; //Integer_Type
		private DefaultEnd_template end; //Referenced_Type
		//originally value_list/list_value
		private List<DefaultOp_template> list_value;

		public TitanCharString_template getname() {
			setSpecific();
			return name;
		}

		public TitanCharString_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.DefaultOp.");
			}
			return name;
		}

		public TitanInteger_template getid() {
			setSpecific();
			return id;
		}

		public TitanInteger_template constGetid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field id of a non-specific template of type @TitanLoggerApi.DefaultOp.");
			}
			return id;
		}

		public DefaultEnd_template getend() {
			setSpecific();
			return end;
		}

		public DefaultEnd_template constGetend() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field end of a non-specific template of type @TitanLoggerApi.DefaultOp.");
			}
			return end;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				name = new TitanCharString_template();
				id = new TitanInteger_template();
				end = new DefaultEnd_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					name.assign(template_sel.ANY_VALUE);
					id.assign(template_sel.ANY_VALUE);
					end.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public DefaultOp_template() {
			// do nothing
		}

		public DefaultOp_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public DefaultOp_template( final DefaultOp otherValue ) {
			copyValue(otherValue);
		}

		public DefaultOp_template( final DefaultOp_template otherValue ) {
			copyTemplate( otherValue );
		}

		public DefaultOp_template( final Optional<DefaultOp> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.DefaultOp from an unbound optional field.");
			}
		}

		//originally operator=
		public DefaultOp_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public DefaultOp_template assign( final DefaultOp other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public DefaultOp_template assign( final DefaultOp_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public DefaultOp_template assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp) {
				return assign((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultOp' can not be cast to {1}", otherValue));
		}

		@Override
		public DefaultOp_template assign(final Base_Template otherValue) {
			if (otherValue instanceof DefaultOp_template) {
				return assign((DefaultOp_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultOp' can not be cast to {1}_template", otherValue));
		}

		public DefaultOp_template assign( final Optional<DefaultOp> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.DefaultOp.");
			}
			return this;
		}

		private void copyValue(final DefaultOp other_value) {
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			if (other_value.getid().isBound()) {
				getid().assign(other_value.getid());
			} else {
				getid().cleanUp();
			}
			if (other_value.getend().isBound()) {
				getend().assign(other_value.getend());
			} else {
				getend().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final DefaultOp_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getid().get_selection()) {
					getid().cleanUp();
				} else {
					getid().assign(other_value.getid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getend().get_selection()) {
					getend().cleanUp();
				} else {
					getend().assign(other_value.getend());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<DefaultOp_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final DefaultOp_template temp = new DefaultOp_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.DefaultOp.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public DefaultOp valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.DefaultOp.");
			}
			final DefaultOp ret_val = new DefaultOp();
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			if (id.isBound()) {
				ret_val.getid().assign(id.valueOf());
			}
			if (end.isBound()) {
				ret_val.getend().assign(end.valueOf());
			}
			return ret_val;
		}

		public DefaultOp_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.DefaultOp.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.DefaultOp.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.DefaultOp.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<DefaultOp_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new DefaultOp_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (id.isBound()) {
				return true;
			}
			if (end.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!id.isValue()) {
				return false;
			}
			if (!end.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final DefaultOp other_value) {
			return match(other_value, false);
		}

		public boolean match(final DefaultOp other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				if(!other_value.getid().isBound()) {
					return false;
				}
				if(!id.match(other_value.getid(), legacy)) {
					return false;
				}
				if(!other_value.getend().isBound()) {
					return false;
				}
				if(!end.match(other_value.getend(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof DefaultOp) {
				return match((DefaultOp)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultOp.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" id := ");
				id.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" end := ");
				end.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final DefaultOp match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultOp) {
				log_match((DefaultOp)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultOp.");
		}

		public void log_match(final DefaultOp match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !id.match(match_value.constGetid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".id");
							id.log_match(match_value.constGetid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !end.match(match_value.constGetend(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".end");
							end.log_match(match_value.constGetend(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str("{ id := ");
				id.log_match(match_value.constGetid(), legacy);
				TTCN_Logger.log_event_str("{ end := ");
				end.log_match(match_value.constGetend(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				id.encode_text(text_buf);
				end.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				id = new TitanInteger_template();
				id.decode_text(text_buf);
				end = new DefaultEnd_template();
				end.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<DefaultOp_template>(size);
				for (int i = 0; i < size; i++) {
					final DefaultOp_template temp = new DefaultOp_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.DefaultOp has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getid().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getend().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("id".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("end".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getend().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.DefaultOp: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.DefaultOp");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultOp" : name, legacy);
				this.id.check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultOp" : name, legacy);
				this.end.check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultOp" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.DefaultOp" : name));
		}
	}
	public static void DefaultOp_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultOp_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultOp_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultOp_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_module___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_module___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_module___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_module___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_executorConfigdata_encoder(final ExecutorConfigdata input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_executorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_executorConfigdata_decoder( final TitanOctetString input_stream, final ExecutorConfigdata output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_executorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class VerdictOp_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_setVerdict,  ALT_getVerdict,  ALT_finalVerdict };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public VerdictOp_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public VerdictOp_choice(final VerdictOp_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final VerdictOp_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_setVerdict:
				field = new SetVerdictType((SetVerdictType)otherValue.field);
				break;
			case ALT_getVerdict:
				field = new Verdict((Verdict)otherValue.field);
				break;
			case ALT_finalVerdict:
				field = new FinalVerdictType((FinalVerdictType)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.VerdictOp.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public VerdictOp_choice assign( final VerdictOp_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public VerdictOp_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof VerdictOp_choice) {
				return assign((VerdictOp_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_setVerdict:
				return field.isValue();
			case ALT_getVerdict:
				return field.isValue();
			case ALT_finalVerdict:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final VerdictOp_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.VerdictOp.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.VerdictOp.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_setVerdict:
				return ((SetVerdictType)field).operatorEquals((SetVerdictType)otherValue.field);
			case ALT_getVerdict:
				return ((Verdict)field).operatorEquals((Verdict)otherValue.field);
			case ALT_finalVerdict:
				return ((FinalVerdictType)field).operatorEquals((FinalVerdictType)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof VerdictOp_choice) {
				return operatorEquals((VerdictOp_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final VerdictOp_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public SetVerdictType getsetVerdict() {
			if (union_selection != union_selection_type.ALT_setVerdict) {
				cleanUp();
				field = new SetVerdictType();
				union_selection = union_selection_type.ALT_setVerdict;
			}
			return (SetVerdictType)field;
		}

		public SetVerdictType constGetsetVerdict() {
			if (union_selection != union_selection_type.ALT_setVerdict) {
				throw new TtcnError("Using non-selected field setVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (SetVerdictType)field;
		}

		public Verdict getgetVerdict() {
			if (union_selection != union_selection_type.ALT_getVerdict) {
				cleanUp();
				field = new Verdict();
				union_selection = union_selection_type.ALT_getVerdict;
			}
			return (Verdict)field;
		}

		public Verdict constGetgetVerdict() {
			if (union_selection != union_selection_type.ALT_getVerdict) {
				throw new TtcnError("Using non-selected field getVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (Verdict)field;
		}

		public FinalVerdictType getfinalVerdict() {
			if (union_selection != union_selection_type.ALT_finalVerdict) {
				cleanUp();
				field = new FinalVerdictType();
				union_selection = union_selection_type.ALT_finalVerdict;
			}
			return (FinalVerdictType)field;
		}

		public FinalVerdictType constGetfinalVerdict() {
			if (union_selection != union_selection_type.ALT_finalVerdict) {
				throw new TtcnError("Using non-selected field finalVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (FinalVerdictType)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_setVerdict:
				TTCN_Logger.log_event_str("{ setVerdict := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_getVerdict:
				TTCN_Logger.log_event_str("{ getVerdict := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_finalVerdict:
				TTCN_Logger.log_event_str("{ finalVerdict := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("setVerdict".equals(last_name)) {
				getsetVerdict().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("getVerdict".equals(last_name)) {
				getgetVerdict().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("finalVerdict".equals(last_name)) {
				getfinalVerdict().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.VerdictOp.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_setVerdict:
			case ALT_getVerdict:
			case ALT_finalVerdict:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_setVerdict:
				text_buf.push_int(0);
				break;
			case ALT_getVerdict:
				text_buf.push_int(1);
				break;
			case ALT_finalVerdict:
				text_buf.push_int(2);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getsetVerdict().decode_text(text_buf);
				break;
			case 1:
				getgetVerdict().decode_text(text_buf);
				break;
			case 2:
				getfinalVerdict().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.VerdictOp.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class VerdictOp_choice_template extends Base_Template {
		//if single value which value?
		private VerdictOp_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<VerdictOp_choice_template> value_list;

		private void copy_value(final VerdictOp_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_setVerdict:
				single_value = new SetVerdictType_template(other_value.constGetsetVerdict());
				break;
			case ALT_getVerdict:
				single_value = new Verdict_template(other_value.constGetgetVerdict());
				break;
			case ALT_finalVerdict:
				single_value = new FinalVerdictType_template(other_value.constGetfinalVerdict());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.VerdictOp.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final VerdictOp_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_setVerdict:
					single_value = new SetVerdictType_template(other_value.constGetsetVerdict());
					break;
				case ALT_getVerdict:
					single_value = new Verdict_template(other_value.constGetgetVerdict());
					break;
				case ALT_finalVerdict:
					single_value = new FinalVerdictType_template(other_value.constGetfinalVerdict());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.VerdictOp.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<VerdictOp_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final VerdictOp_choice_template temp = new VerdictOp_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			set_selection(other_value);
		}

		public VerdictOp_choice_template() {
			// do nothing
		}
		public VerdictOp_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public VerdictOp_choice_template(final VerdictOp_choice other_value) {
			copy_value(other_value);
		}
		public VerdictOp_choice_template(final VerdictOp_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_setVerdict:
					((SetVerdictType_template)single_value).cleanUp();
					break;
				case ALT_getVerdict:
					((Verdict_template)single_value).cleanUp();
					break;
				case ALT_finalVerdict:
					((FinalVerdictType_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public VerdictOp_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public VerdictOp_choice_template assign( final VerdictOp_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public VerdictOp_choice_template assign( final VerdictOp_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public VerdictOp_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof VerdictOp_choice) {
				return assign((VerdictOp_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to VerdictOp_choice.");
		}

		@Override
		public VerdictOp_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof VerdictOp_choice_template) {
				return assign((VerdictOp_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to VerdictOp_choice_template.");
		}

		// originally match
		public boolean match(final VerdictOp_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final VerdictOp_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final VerdictOp_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_setVerdict:
					return ((SetVerdictType_template)single_value).match(other_value.getsetVerdict(), legacy);
				case ALT_getVerdict:
					return ((Verdict_template)single_value).match(other_value.getgetVerdict(), legacy);
				case ALT_finalVerdict:
					return ((FinalVerdictType_template)single_value).match(other_value.getfinalVerdict(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.VerdictOp.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof VerdictOp_choice) {
				return match((VerdictOp_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictOp_choice.");
		}
		public boolean isChosen(final VerdictOp_choice.union_selection_type checked_selection) {
			if(checked_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.VerdictOp.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_setVerdict:
				return ((SetVerdictType_template)single_value).isValue();
			case ALT_getVerdict:
				return ((Verdict_template)single_value).isValue();
			case ALT_finalVerdict:
				return ((FinalVerdictType_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
		}

		public VerdictOp_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			final VerdictOp_choice ret_val = new VerdictOp_choice();
			switch (single_value_union_selection) {
			case ALT_setVerdict:
				ret_val.getsetVerdict().assign(((SetVerdictType_template)single_value).valueOf());
				break;
			case ALT_getVerdict:
				ret_val.getgetVerdict().assign(((Verdict_template)single_value).valueOf());
				break;
			case ALT_finalVerdict:
				ret_val.getfinalVerdict().assign(((FinalVerdictType_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<VerdictOp_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new VerdictOp_choice_template());
			}
		}

		public VerdictOp_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public SetVerdictType_template getsetVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_setVerdict) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new SetVerdictType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new SetVerdictType_template();
				}
				single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_setVerdict;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (SetVerdictType_template)single_value;
		}

		public SetVerdictType_template constGetsetVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field setVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_setVerdict) {
				throw new TtcnError("Accessing non-selected field setVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (SetVerdictType_template)single_value;
		}

		public Verdict_template getgetVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_getVerdict) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Verdict_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Verdict_template();
				}
				single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_getVerdict;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Verdict_template)single_value;
		}

		public Verdict_template constGetgetVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field getVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_getVerdict) {
				throw new TtcnError("Accessing non-selected field getVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (Verdict_template)single_value;
		}

		public FinalVerdictType_template getfinalVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_finalVerdict) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new FinalVerdictType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new FinalVerdictType_template();
				}
				single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_finalVerdict;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (FinalVerdictType_template)single_value;
		}

		public FinalVerdictType_template constGetfinalVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field finalVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_finalVerdict) {
				throw new TtcnError("Accessing non-selected field finalVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
			}
			return (FinalVerdictType_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof VerdictOp_choice) {
				log_match((VerdictOp_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
		}

		public void log_match(final VerdictOp_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_setVerdict:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".setVerdict");
						single_value.log_match(match_value.getsetVerdict(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ setVerdict := ");
						single_value.log_match(match_value.getsetVerdict(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_getVerdict:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".getVerdict");
						single_value.log_match(match_value.getgetVerdict(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ getVerdict := ");
						single_value.log_match(match_value.getgetVerdict(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_finalVerdict:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".finalVerdict");
						single_value.log_match(match_value.getfinalVerdict(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ finalVerdict := ");
						single_value.log_match(match_value.getfinalVerdict(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.VerdictOp.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new SetVerdictType_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new Verdict_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new FinalVerdictType_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<VerdictOp_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final VerdictOp_choice_template temp2 = new VerdictOp_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.VerdictOp.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.VerdictOp.choice");
				}
				if("setVerdict".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("getVerdict".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("finalVerdict".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.VerdictOp.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("setVerdict".equals(last_name)) {
					getsetVerdict().set_param(mp_last);
					break;
				}
				if("getVerdict".equals(last_name)) {
					getgetVerdict().set_param(mp_last);
					break;
				}
				if("finalVerdict".equals(last_name)) {
					getfinalVerdict().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.VerdictOp.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.VerdictOp.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_setVerdict:
					((SetVerdictType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictOp.choice" : name, legacy);
					return;
				case ALT_getVerdict:
					((Verdict_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictOp.choice" : name, legacy);
					return;
				case ALT_finalVerdict:
					((FinalVerdictType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictOp.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.VerdictOp.choice" : name));
		}
	}
	public static void VerdictOp_choice_encoder(final VerdictOp_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictOp_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictOp_choice_decoder( final TitanOctetString input_stream, final VerdictOp_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictOp_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultEvent_choice_defaultopExit_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEvent_choice_defaultopExit_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEvent_choice_defaultopExit_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEvent_choice_defaultopExit_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_controlpartStart_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_controlpartStart_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_controlpartStart_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_controlpartStart_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__mapped_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__mapped_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__mapped_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__mapped_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FinalVerdictInfo extends Base_Type {
		private final TitanBoolean is__ptc; //Boolean_Type
		private final Verdict ptc__verdict; //Referenced_Type
		private final Verdict local__verdict; //Referenced_Type
		private final Verdict new__verdict; //Referenced_Type
		private final Optional<TitanCharString> verdict__reason; //CharString_Type
		private final Optional<TitanInteger> ptc__compref; //Integer_Type
		private final Optional<TitanCharString> ptc__name; //CharString_Type

		public FinalVerdictInfo() {
			this.is__ptc = new TitanBoolean();
			this.ptc__verdict = new Verdict();
			this.local__verdict = new Verdict();
			this.new__verdict = new Verdict();
			this.verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			this.ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			this.ptc__name = new Optional<TitanCharString>(TitanCharString.class);
		}

		public FinalVerdictInfo(final TitanBoolean is__ptc, final Verdict ptc__verdict, final Verdict local__verdict, final Verdict new__verdict, final Optional<TitanCharString> verdict__reason, final Optional<TitanInteger> ptc__compref, final Optional<TitanCharString> ptc__name ) {
			this.is__ptc = new TitanBoolean( is__ptc );
			this.ptc__verdict = new Verdict( ptc__verdict );
			this.local__verdict = new Verdict( local__verdict );
			this.new__verdict = new Verdict( new__verdict );
			this.verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			this.verdict__reason.assign( verdict__reason );
			this.ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			this.ptc__compref.assign( ptc__compref );
			this.ptc__name = new Optional<TitanCharString>(TitanCharString.class);
			this.ptc__name.assign( ptc__name );
		}

		public FinalVerdictInfo( final FinalVerdictInfo otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			is__ptc = new TitanBoolean();
			ptc__verdict = new Verdict();
			local__verdict = new Verdict();
			new__verdict = new Verdict();
			verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			ptc__name = new Optional<TitanCharString>(TitanCharString.class);
			assign( otherValue );
		}

		public FinalVerdictInfo assign(final FinalVerdictInfo otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FinalVerdictInfo");
			}

			if (otherValue != this) {
				if ( otherValue.getis__ptc().isBound() ) {
					this.is__ptc.assign( otherValue.getis__ptc() );
				} else {
					this.is__ptc.cleanUp();
				}
				if ( otherValue.getptc__verdict().isBound() ) {
					this.ptc__verdict.assign( otherValue.getptc__verdict() );
				} else {
					this.ptc__verdict.cleanUp();
				}
				if ( otherValue.getlocal__verdict().isBound() ) {
					this.local__verdict.assign( otherValue.getlocal__verdict() );
				} else {
					this.local__verdict.cleanUp();
				}
				if ( otherValue.getnew__verdict().isBound() ) {
					this.new__verdict.assign( otherValue.getnew__verdict() );
				} else {
					this.new__verdict.cleanUp();
				}
				if ( otherValue.getverdict__reason().isBound() ) {
					this.verdict__reason.assign( otherValue.getverdict__reason() );
				} else {
					this.verdict__reason.cleanUp();
				}
				if ( otherValue.getptc__compref().isBound() ) {
					this.ptc__compref.assign( otherValue.getptc__compref() );
				} else {
					this.ptc__compref.cleanUp();
				}
				if ( otherValue.getptc__name().isBound() ) {
					this.ptc__name.assign( otherValue.getptc__name() );
				} else {
					this.ptc__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FinalVerdictInfo assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo ) {
				return assign((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictInfo", otherValue));
		}

		public void cleanUp() {
			is__ptc.cleanUp();
			ptc__verdict.cleanUp();
			local__verdict.cleanUp();
			new__verdict.cleanUp();
			verdict__reason.cleanUp();
			ptc__compref.cleanUp();
			ptc__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( is__ptc.isBound() ) { return true; }
			if ( ptc__verdict.isBound() ) { return true; }
			if ( local__verdict.isBound() ) { return true; }
			if ( new__verdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(verdict__reason.get_selection()) || verdict__reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(ptc__compref.get_selection()) || ptc__compref.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(ptc__name.get_selection()) || ptc__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !is__ptc.isValue() ) { return false; }
			if ( !ptc__verdict.isValue() ) { return false; }
			if ( !local__verdict.isValue() ) { return false; }
			if ( !new__verdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(verdict__reason.get_selection()) && !verdict__reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(ptc__compref.get_selection()) && !ptc__compref.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(ptc__name.get_selection()) && !ptc__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FinalVerdictInfo otherValue) {
			if ( !this.is__ptc.operatorEquals( otherValue.is__ptc ) ) { return false; }
			if ( !this.ptc__verdict.operatorEquals( otherValue.ptc__verdict ) ) { return false; }
			if ( !this.local__verdict.operatorEquals( otherValue.local__verdict ) ) { return false; }
			if ( !this.new__verdict.operatorEquals( otherValue.new__verdict ) ) { return false; }
			if ( !this.verdict__reason.operatorEquals( otherValue.verdict__reason ) ) { return false; }
			if ( !this.ptc__compref.operatorEquals( otherValue.ptc__compref ) ) { return false; }
			if ( !this.ptc__name.operatorEquals( otherValue.ptc__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo ) {
				return operatorEquals((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictInfo", otherValue));
		}

		public TitanBoolean getis__ptc() {
			return is__ptc;
		}

		public TitanBoolean constGetis__ptc() {
			return is__ptc;
		}

		public Verdict getptc__verdict() {
			return ptc__verdict;
		}

		public Verdict constGetptc__verdict() {
			return ptc__verdict;
		}

		public Verdict getlocal__verdict() {
			return local__verdict;
		}

		public Verdict constGetlocal__verdict() {
			return local__verdict;
		}

		public Verdict getnew__verdict() {
			return new__verdict;
		}

		public Verdict constGetnew__verdict() {
			return new__verdict;
		}

		public Optional<TitanCharString> getverdict__reason() {
			return verdict__reason;
		}

		public Optional<TitanCharString> constGetverdict__reason() {
			return verdict__reason;
		}

		public Optional<TitanInteger> getptc__compref() {
			return ptc__compref;
		}

		public Optional<TitanInteger> constGetptc__compref() {
			return ptc__compref;
		}

		public Optional<TitanCharString> getptc__name() {
			return ptc__name;
		}

		public Optional<TitanCharString> constGetptc__name() {
			return ptc__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			if (verdict__reason.isPresent()) {
				sizeof++;
			}
			if (ptc__compref.isPresent()) {
				sizeof++;
			}
			if (ptc__name.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" is_ptc := ");
			is__ptc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_verdict := ");
			ptc__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" local_verdict := ");
			local__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" new_verdict := ");
			new__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdict_reason := ");
			verdict__reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_compref := ");
			ptc__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_name := ");
			ptc__name.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.FinalVerdictInfo has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getis__ptc().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__verdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlocal__verdict().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnew__verdict().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdict__reason().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__compref().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__name().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("is_ptc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getis__ptc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("local_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlocal__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("new_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnew__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdict_reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdict__reason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FinalVerdictInfo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.FinalVerdictInfo");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (is__ptc.isBound()) {
				is__ptc.set_implicit_omit();
			}
			if (ptc__verdict.isBound()) {
				ptc__verdict.set_implicit_omit();
			}
			if (local__verdict.isBound()) {
				local__verdict.set_implicit_omit();
			}
			if (new__verdict.isBound()) {
				new__verdict.set_implicit_omit();
			}
			if (verdict__reason.isBound()) {
				verdict__reason.set_implicit_omit();
			} else {
				verdict__reason.assign(template_sel.OMIT_VALUE);
			}
			if (ptc__compref.isBound()) {
				ptc__compref.set_implicit_omit();
			} else {
				ptc__compref.assign(template_sel.OMIT_VALUE);
			}
			if (ptc__name.isBound()) {
				ptc__name.set_implicit_omit();
			} else {
				ptc__name.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			is__ptc.encode_text(text_buf);
			ptc__verdict.encode_text(text_buf);
			local__verdict.encode_text(text_buf);
			new__verdict.encode_text(text_buf);
			verdict__reason.encode_text(text_buf);
			ptc__compref.encode_text(text_buf);
			ptc__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			is__ptc.decode_text(text_buf);
			ptc__verdict.decode_text(text_buf);
			local__verdict.decode_text(text_buf);
			new__verdict.decode_text(text_buf);
			verdict__reason.decode_text(text_buf);
			ptc__compref.decode_text(text_buf);
			ptc__name.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FinalVerdictInfo_template extends Base_Template {

		private TitanBoolean_template is__ptc; //Boolean_Type
		private Verdict_template ptc__verdict; //Referenced_Type
		private Verdict_template local__verdict; //Referenced_Type
		private Verdict_template new__verdict; //Referenced_Type
		private TitanCharString_template verdict__reason; //CharString_Type
		private TitanInteger_template ptc__compref; //Integer_Type
		private TitanCharString_template ptc__name; //CharString_Type
		//originally value_list/list_value
		private List<FinalVerdictInfo_template> list_value;

		public TitanBoolean_template getis__ptc() {
			setSpecific();
			return is__ptc;
		}

		public TitanBoolean_template constGetis__ptc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field is_ptc of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return is__ptc;
		}

		public Verdict_template getptc__verdict() {
			setSpecific();
			return ptc__verdict;
		}

		public Verdict_template constGetptc__verdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ptc_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return ptc__verdict;
		}

		public Verdict_template getlocal__verdict() {
			setSpecific();
			return local__verdict;
		}

		public Verdict_template constGetlocal__verdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field local_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return local__verdict;
		}

		public Verdict_template getnew__verdict() {
			setSpecific();
			return new__verdict;
		}

		public Verdict_template constGetnew__verdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field new_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return new__verdict;
		}

		public TitanCharString_template getverdict__reason() {
			setSpecific();
			return verdict__reason;
		}

		public TitanCharString_template constGetverdict__reason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field verdict_reason of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return verdict__reason;
		}

		public TitanInteger_template getptc__compref() {
			setSpecific();
			return ptc__compref;
		}

		public TitanInteger_template constGetptc__compref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ptc_compref of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return ptc__compref;
		}

		public TitanCharString_template getptc__name() {
			setSpecific();
			return ptc__name;
		}

		public TitanCharString_template constGetptc__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ptc_name of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return ptc__name;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				is__ptc = new TitanBoolean_template();
				ptc__verdict = new Verdict_template();
				local__verdict = new Verdict_template();
				new__verdict = new Verdict_template();
				verdict__reason = new TitanCharString_template();
				ptc__compref = new TitanInteger_template();
				ptc__name = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					is__ptc.assign(template_sel.ANY_VALUE);
					ptc__verdict.assign(template_sel.ANY_VALUE);
					local__verdict.assign(template_sel.ANY_VALUE);
					new__verdict.assign(template_sel.ANY_VALUE);
					verdict__reason.assign(template_sel.ANY_OR_OMIT);
					ptc__compref.assign(template_sel.ANY_OR_OMIT);
					ptc__name.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public FinalVerdictInfo_template() {
			// do nothing
		}

		public FinalVerdictInfo_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public FinalVerdictInfo_template( final FinalVerdictInfo otherValue ) {
			copyValue(otherValue);
		}

		public FinalVerdictInfo_template( final FinalVerdictInfo_template otherValue ) {
			copyTemplate( otherValue );
		}

		public FinalVerdictInfo_template( final Optional<FinalVerdictInfo> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.FinalVerdictInfo from an unbound optional field.");
			}
		}

		//originally operator=
		public FinalVerdictInfo_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictInfo_template assign( final FinalVerdictInfo other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictInfo_template assign( final FinalVerdictInfo_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public FinalVerdictInfo_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo) {
				return assign((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictInfo' can not be cast to {1}", otherValue));
		}

		@Override
		public FinalVerdictInfo_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FinalVerdictInfo_template) {
				return assign((FinalVerdictInfo_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictInfo' can not be cast to {1}_template", otherValue));
		}

		public FinalVerdictInfo_template assign( final Optional<FinalVerdictInfo> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return this;
		}

		private void copyValue(final FinalVerdictInfo other_value) {
			if (other_value.getis__ptc().isBound()) {
				getis__ptc().assign(other_value.getis__ptc());
			} else {
				getis__ptc().cleanUp();
			}
			if (other_value.getptc__verdict().isBound()) {
				getptc__verdict().assign(other_value.getptc__verdict());
			} else {
				getptc__verdict().cleanUp();
			}
			if (other_value.getlocal__verdict().isBound()) {
				getlocal__verdict().assign(other_value.getlocal__verdict());
			} else {
				getlocal__verdict().cleanUp();
			}
			if (other_value.getnew__verdict().isBound()) {
				getnew__verdict().assign(other_value.getnew__verdict());
			} else {
				getnew__verdict().cleanUp();
			}
			if (other_value.getverdict__reason().isBound()) {
				if (other_value.getverdict__reason().isPresent()) {
					getverdict__reason().assign(other_value.getverdict__reason().get());
				} else {
					getverdict__reason().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getverdict__reason().cleanUp();
			}
			if (other_value.getptc__compref().isBound()) {
				if (other_value.getptc__compref().isPresent()) {
					getptc__compref().assign(other_value.getptc__compref().get());
				} else {
					getptc__compref().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getptc__compref().cleanUp();
			}
			if (other_value.getptc__name().isBound()) {
				if (other_value.getptc__name().isPresent()) {
					getptc__name().assign(other_value.getptc__name().get());
				} else {
					getptc__name().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getptc__name().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final FinalVerdictInfo_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getis__ptc().get_selection()) {
					getis__ptc().cleanUp();
				} else {
					getis__ptc().assign(other_value.getis__ptc());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getptc__verdict().get_selection()) {
					getptc__verdict().cleanUp();
				} else {
					getptc__verdict().assign(other_value.getptc__verdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getlocal__verdict().get_selection()) {
					getlocal__verdict().cleanUp();
				} else {
					getlocal__verdict().assign(other_value.getlocal__verdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnew__verdict().get_selection()) {
					getnew__verdict().cleanUp();
				} else {
					getnew__verdict().assign(other_value.getnew__verdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getverdict__reason().get_selection()) {
					getverdict__reason().cleanUp();
				} else {
					getverdict__reason().assign(other_value.getverdict__reason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getptc__compref().get_selection()) {
					getptc__compref().cleanUp();
				} else {
					getptc__compref().assign(other_value.getptc__compref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getptc__name().get_selection()) {
					getptc__name().cleanUp();
				} else {
					getptc__name().assign(other_value.getptc__name());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<FinalVerdictInfo_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final FinalVerdictInfo_template temp = new FinalVerdictInfo_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FinalVerdictInfo valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			final FinalVerdictInfo ret_val = new FinalVerdictInfo();
			if (is__ptc.isBound()) {
				ret_val.getis__ptc().assign(is__ptc.valueOf());
			}
			if (ptc__verdict.isBound()) {
				ret_val.getptc__verdict().assign(ptc__verdict.valueOf());
			}
			if (local__verdict.isBound()) {
				ret_val.getlocal__verdict().assign(local__verdict.valueOf());
			}
			if (new__verdict.isBound()) {
				ret_val.getnew__verdict().assign(new__verdict.valueOf());
			}
			if (verdict__reason.isOmit()) {
				ret_val.getverdict__reason().assign(template_sel.OMIT_VALUE);
			} else if (verdict__reason.isBound()) {
				ret_val.getverdict__reason().assign(verdict__reason.valueOf());
			}
			if (ptc__compref.isOmit()) {
				ret_val.getptc__compref().assign(template_sel.OMIT_VALUE);
			} else if (ptc__compref.isBound()) {
				ret_val.getptc__compref().assign(ptc__compref.valueOf());
			}
			if (ptc__name.isOmit()) {
				ret_val.getptc__name().assign(template_sel.OMIT_VALUE);
			} else if (ptc__name.isBound()) {
				ret_val.getptc__name().assign(ptc__name.valueOf());
			}
			return ret_val;
		}

		public FinalVerdictInfo_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FinalVerdictInfo_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FinalVerdictInfo_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (is__ptc.isBound()) {
				return true;
			}
			if (ptc__verdict.isBound()) {
				return true;
			}
			if (local__verdict.isBound()) {
				return true;
			}
			if (new__verdict.isBound()) {
				return true;
			}
			if (verdict__reason.isOmit() || verdict__reason.isBound()) {
				return true;
			}
			if (ptc__compref.isOmit() || ptc__compref.isBound()) {
				return true;
			}
			if (ptc__name.isOmit() || ptc__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!is__ptc.isValue()) {
				return false;
			}
			if (!ptc__verdict.isValue()) {
				return false;
			}
			if (!local__verdict.isValue()) {
				return false;
			}
			if (!new__verdict.isValue()) {
				return false;
			}
			if (!verdict__reason.isOmit() && !verdict__reason.isValue()) {
				return false;
			}
			if (!ptc__compref.isOmit() && !ptc__compref.isValue()) {
				return false;
			}
			if (!ptc__name.isOmit() && !ptc__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FinalVerdictInfo other_value) {
			return match(other_value, false);
		}

		public boolean match(final FinalVerdictInfo other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getis__ptc().isBound()) {
					return false;
				}
				if(!is__ptc.match(other_value.getis__ptc(), legacy)) {
					return false;
				}
				if(!other_value.getptc__verdict().isBound()) {
					return false;
				}
				if(!ptc__verdict.match(other_value.getptc__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getlocal__verdict().isBound()) {
					return false;
				}
				if(!local__verdict.match(other_value.getlocal__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getnew__verdict().isBound()) {
					return false;
				}
				if(!new__verdict.match(other_value.getnew__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getverdict__reason().isBound()) {
					return false;
				}
				if((other_value.getverdict__reason().isPresent() ? !verdict__reason.match(other_value.getverdict__reason().get(), legacy) : !verdict__reason.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getptc__compref().isBound()) {
					return false;
				}
				if((other_value.getptc__compref().isPresent() ? !ptc__compref.match(other_value.getptc__compref().get(), legacy) : !ptc__compref.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getptc__name().isBound()) {
					return false;
				}
				if((other_value.getptc__name().isPresent() ? !ptc__name.match(other_value.getptc__name().get(), legacy) : !ptc__name.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FinalVerdictInfo) {
				return match((FinalVerdictInfo)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictInfo.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				if (verdict__reason.isPresent()) {
					sizeof++;
				}
				if (ptc__compref.isPresent()) {
					sizeof++;
				}
				if (ptc__name.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" is_ptc := ");
				is__ptc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_verdict := ");
				ptc__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" local_verdict := ");
				local__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" new_verdict := ");
				new__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdict_reason := ");
				verdict__reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_compref := ");
				ptc__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_name := ");
				ptc__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FinalVerdictInfo match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictInfo) {
				log_match((FinalVerdictInfo)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictInfo.");
		}

		public void log_match(final FinalVerdictInfo match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !is__ptc.match(match_value.constGetis__ptc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".is_ptc");
							is__ptc.log_match(match_value.constGetis__ptc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ptc__verdict.match(match_value.constGetptc__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ptc_verdict");
							ptc__verdict.log_match(match_value.constGetptc__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !local__verdict.match(match_value.constGetlocal__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".local_verdict");
							local__verdict.log_match(match_value.constGetlocal__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !new__verdict.match(match_value.constGetnew__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".new_verdict");
							new__verdict.log_match(match_value.constGetnew__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetverdict__reason().isPresent()) {
							if( !verdict__reason.match(match_value.constGetverdict__reason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".verdict_reason");
								verdict__reason.log_match(match_value.constGetverdict__reason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!verdict__reason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".verdict_reason := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								verdict__reason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetptc__compref().isPresent()) {
							if( !ptc__compref.match(match_value.constGetptc__compref().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ptc_compref");
								ptc__compref.log_match(match_value.constGetptc__compref().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ptc__compref.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ptc_compref := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ptc__compref.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetptc__name().isPresent()) {
							if( !ptc__name.match(match_value.constGetptc__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ptc_name");
								ptc__name.log_match(match_value.constGetptc__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ptc__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ptc_name := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								ptc__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ is_ptc := ");
				is__ptc.log_match(match_value.constGetis__ptc(), legacy);
				TTCN_Logger.log_event_str("{ ptc_verdict := ");
				ptc__verdict.log_match(match_value.constGetptc__verdict(), legacy);
				TTCN_Logger.log_event_str("{ local_verdict := ");
				local__verdict.log_match(match_value.constGetlocal__verdict(), legacy);
				TTCN_Logger.log_event_str("{ new_verdict := ");
				new__verdict.log_match(match_value.constGetnew__verdict(), legacy);
				TTCN_Logger.log_event_str("{ verdict_reason := ");
				verdict__reason.log_match(match_value.constGetverdict__reason(), legacy);
				TTCN_Logger.log_event_str("{ ptc_compref := ");
				ptc__compref.log_match(match_value.constGetptc__compref(), legacy);
				TTCN_Logger.log_event_str("{ ptc_name := ");
				ptc__name.log_match(match_value.constGetptc__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				is__ptc.encode_text(text_buf);
				ptc__verdict.encode_text(text_buf);
				local__verdict.encode_text(text_buf);
				new__verdict.encode_text(text_buf);
				verdict__reason.encode_text(text_buf);
				ptc__compref.encode_text(text_buf);
				ptc__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				is__ptc = new TitanBoolean_template();
				is__ptc.decode_text(text_buf);
				ptc__verdict = new Verdict_template();
				ptc__verdict.decode_text(text_buf);
				local__verdict = new Verdict_template();
				local__verdict.decode_text(text_buf);
				new__verdict = new Verdict_template();
				new__verdict.decode_text(text_buf);
				verdict__reason = new TitanCharString_template();
				verdict__reason.decode_text(text_buf);
				ptc__compref = new TitanInteger_template();
				ptc__compref.decode_text(text_buf);
				ptc__name = new TitanCharString_template();
				ptc__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FinalVerdictInfo_template>(size);
				for (int i = 0; i < size; i++) {
					final FinalVerdictInfo_template temp = new FinalVerdictInfo_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.FinalVerdictInfo has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getis__ptc().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__verdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlocal__verdict().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnew__verdict().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdict__reason().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__compref().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc__name().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("is_ptc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getis__ptc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("local_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlocal__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("new_verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnew__verdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdict_reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdict__reason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FinalVerdictInfo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.FinalVerdictInfo");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.is__ptc.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.ptc__verdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.local__verdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.new__verdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.verdict__reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.ptc__compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				this.ptc__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FinalVerdictInfo" : name));
		}
	}
	public static void FinalVerdictInfo_encoder(final FinalVerdictInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_decoder( final TitanOctetString input_stream, final FinalVerdictInfo output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimerEvent extends Base_Type {
		private final TimerEvent_choice choice; //TTCN3_Choice_Type

		public TimerEvent() {
			this.choice = new TimerEvent_choice();
		}

		public TimerEvent(final TimerEvent_choice choice ) {
			this.choice = new TimerEvent_choice( choice );
		}

		public TimerEvent( final TimerEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerEvent.");
			}
			choice = new TimerEvent_choice();
			assign( otherValue );
		}

		public TimerEvent assign(final TimerEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent ) {
				return assign((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent ) {
				return operatorEquals((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerEvent", otherValue));
		}

		public TimerEvent_choice getchoice() {
			return choice;
		}

		public TimerEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TimerEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TimerEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TimerEvent_template extends Base_Template {

		private TimerEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<TimerEvent_template> list_value;

		public TimerEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public TimerEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.TimerEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new TimerEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TimerEvent_template() {
			// do nothing
		}

		public TimerEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TimerEvent_template( final TimerEvent otherValue ) {
			copyValue(otherValue);
		}

		public TimerEvent_template( final TimerEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TimerEvent_template( final Optional<TimerEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public TimerEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimerEvent_template assign( final TimerEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TimerEvent_template assign( final TimerEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TimerEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent) {
				return assign((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerEvent_template) {
				return assign((TimerEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerEvent' can not be cast to {1}_template", otherValue));
		}

		public TimerEvent_template assign( final Optional<TimerEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerEvent.");
			}
			return this;
		}

		private void copyValue(final TimerEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TimerEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TimerEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TimerEvent_template temp = new TimerEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerEvent.");
			}
			final TimerEvent ret_val = new TimerEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public TimerEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TimerEvent) {
				return match((TimerEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerEvent) {
				log_match((TimerEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.");
		}

		public void log_match(final TimerEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new TimerEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final TimerEvent_template temp = new TimerEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TimerEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TimerEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimerEvent" : name));
		}
	}
	public static void TimerEvent_encoder(final TimerEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_decoder( final TitanOctetString input_stream, final TimerEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingSuccessType extends Base_Type {
		private final PortType port__type; //Referenced_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanCharString info; //CharString_Type

		public MatchingSuccessType() {
			this.port__type = new PortType();
			this.port__name = new TitanCharString();
			this.info = new TitanCharString();
		}

		public MatchingSuccessType(final PortType port__type, final TitanCharString port__name, final TitanCharString info ) {
			this.port__type = new PortType( port__type );
			this.port__name = new TitanCharString( port__name );
			this.info = new TitanCharString( info );
		}

		public MatchingSuccessType( final MatchingSuccessType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingSuccessType.");
			}
			port__type = new PortType();
			port__name = new TitanCharString();
			info = new TitanCharString();
			assign( otherValue );
		}

		public MatchingSuccessType assign(final MatchingSuccessType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingSuccessType");
			}

			if (otherValue != this) {
				if ( otherValue.getport__type().isBound() ) {
					this.port__type.assign( otherValue.getport__type() );
				} else {
					this.port__type.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getinfo().isBound() ) {
					this.info.assign( otherValue.getinfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingSuccessType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType ) {
				return assign((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingSuccessType", otherValue));
		}

		public void cleanUp() {
			port__type.cleanUp();
			port__name.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingSuccessType otherValue) {
			if ( !this.port__type.operatorEquals( otherValue.port__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.info.operatorEquals( otherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType ) {
				return operatorEquals((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingSuccessType", otherValue));
		}

		public PortType getport__type() {
			return port__type;
		}

		public PortType constGetport__type() {
			return port__type;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanCharString getinfo() {
			return info;
		}

		public TitanCharString constGetinfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_type := ");
			port__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingSuccessType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__type().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingSuccessType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingSuccessType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__type.isBound()) {
				port__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			info.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingSuccessType_template extends Base_Template {

		private PortType_template port__type; //Referenced_Type
		private TitanCharString_template port__name; //CharString_Type
		private TitanCharString_template info; //CharString_Type
		//originally value_list/list_value
		private List<MatchingSuccessType_template> list_value;

		public PortType_template getport__type() {
			setSpecific();
			return port__type;
		}

		public PortType_template constGetport__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_type of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return port__type;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return port__name;
		}

		public TitanCharString_template getinfo() {
			setSpecific();
			return info;
		}

		public TitanCharString_template constGetinfo() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return info;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__type = new PortType_template();
				port__name = new TitanCharString_template();
				info = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__type.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
					info.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public MatchingSuccessType_template() {
			// do nothing
		}

		public MatchingSuccessType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingSuccessType_template( final MatchingSuccessType otherValue ) {
			copyValue(otherValue);
		}

		public MatchingSuccessType_template( final MatchingSuccessType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingSuccessType_template( final Optional<MatchingSuccessType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingSuccessType from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingSuccessType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingSuccessType_template assign( final MatchingSuccessType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingSuccessType_template assign( final MatchingSuccessType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingSuccessType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType) {
				return assign((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingSuccessType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingSuccessType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingSuccessType_template) {
				return assign((MatchingSuccessType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingSuccessType' can not be cast to {1}_template", otherValue));
		}

		public MatchingSuccessType_template assign( final Optional<MatchingSuccessType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return this;
		}

		private void copyValue(final MatchingSuccessType other_value) {
			if (other_value.getport__type().isBound()) {
				getport__type().assign(other_value.getport__type());
			} else {
				getport__type().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getinfo().isBound()) {
				getinfo().assign(other_value.getinfo());
			} else {
				getinfo().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingSuccessType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__type().get_selection()) {
					getport__type().cleanUp();
				} else {
					getport__type().assign(other_value.getport__type());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getinfo().get_selection()) {
					getinfo().cleanUp();
				} else {
					getinfo().assign(other_value.getinfo());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingSuccessType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingSuccessType_template temp = new MatchingSuccessType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingSuccessType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			final MatchingSuccessType ret_val = new MatchingSuccessType();
			if (port__type.isBound()) {
				ret_val.getport__type().assign(port__type.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (info.isBound()) {
				ret_val.getinfo().assign(info.valueOf());
			}
			return ret_val;
		}

		public MatchingSuccessType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingSuccessType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingSuccessType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingSuccessType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingSuccessType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__type().isBound()) {
					return false;
				}
				if(!port__type.match(other_value.getport__type(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getinfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getinfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingSuccessType) {
				return match((MatchingSuccessType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingSuccessType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_type := ");
				port__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingSuccessType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingSuccessType) {
				log_match((MatchingSuccessType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingSuccessType.");
		}

		public void log_match(final MatchingSuccessType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__type.match(match_value.constGetport__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_type");
							port__type.log_match(match_value.constGetport__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetinfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetinfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_type := ");
				port__type.log_match(match_value.constGetport__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetinfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type = new PortType_template();
				port__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingSuccessType_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingSuccessType_template temp = new MatchingSuccessType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingSuccessType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__type().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingSuccessType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingSuccessType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingSuccessType" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingSuccessType" : name, legacy);
				this.info.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingSuccessType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingSuccessType" : name));
		}
	}
	public static void MatchingSuccessType_encoder(final MatchingSuccessType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingSuccessType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingSuccessType_decoder( final TitanOctetString input_stream, final MatchingSuccessType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingSuccessType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Proc__port__out extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Port__oper operation; //Referenced_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString sys__name; //CharString_Type
		private final TitanCharString parameter; //CharString_Type

		public Proc__port__out() {
			this.port__name = new TitanCharString();
			this.operation = new Port__oper();
			this.compref = new TitanInteger();
			this.sys__name = new TitanCharString();
			this.parameter = new TitanCharString();
		}

		public Proc__port__out(final TitanCharString port__name, final Port__oper operation, final TitanInteger compref, final TitanCharString sys__name, final TitanCharString parameter ) {
			this.port__name = new TitanCharString( port__name );
			this.operation = new Port__oper( operation );
			this.compref = new TitanInteger( compref );
			this.sys__name = new TitanCharString( sys__name );
			this.parameter = new TitanCharString( parameter );
		}

		public Proc__port__out( final Proc__port__out otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Proc_port_out.");
			}
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
			assign( otherValue );
		}

		public Proc__port__out assign(final Proc__port__out otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Proc_port_out");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getsys__name().isBound() ) {
					this.sys__name.assign( otherValue.getsys__name() );
				} else {
					this.sys__name.cleanUp();
				}
				if ( otherValue.getparameter().isBound() ) {
					this.parameter.assign( otherValue.getparameter() );
				} else {
					this.parameter.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Proc__port__out assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out ) {
				return assign((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_out", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			sys__name.cleanUp();
			parameter.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( sys__name.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !sys__name.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Proc__port__out otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.sys__name.operatorEquals( otherValue.sys__name ) ) { return false; }
			if ( !this.parameter.operatorEquals( otherValue.parameter ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out ) {
				return operatorEquals((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_out", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public Port__oper getoperation() {
			return operation;
		}

		public Port__oper constGetoperation() {
			return operation;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanCharString getsys__name() {
			return sys__name;
		}

		public TitanCharString constGetsys__name() {
			return sys__name;
		}

		public TitanCharString getparameter() {
			return parameter;
		}

		public TitanCharString constGetparameter() {
			return parameter;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(5);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sys_name := ");
			sys__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Proc_port_out has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsys__name().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sys_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsys__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Proc_port_out: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Proc_port_out");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (sys__name.isBound()) {
				sys__name.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			sys__name.encode_text(text_buf);
			parameter.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			sys__name.decode_text(text_buf);
			parameter.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Proc__port__out_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private Port__oper_template operation; //Referenced_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanCharString_template sys__name; //CharString_Type
		private TitanCharString_template parameter; //CharString_Type
		//originally value_list/list_value
		private List<Proc__port__out_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			return port__name;
		}

		public Port__oper_template getoperation() {
			setSpecific();
			return operation;
		}

		public Port__oper_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			return operation;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			return compref;
		}

		public TitanCharString_template getsys__name() {
			setSpecific();
			return sys__name;
		}

		public TitanCharString_template constGetsys__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sys_name of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			return sys__name;
		}

		public TitanCharString_template getparameter() {
			setSpecific();
			return parameter;
		}

		public TitanCharString_template constGetparameter() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			return parameter;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				operation = new Port__oper_template();
				compref = new TitanInteger_template();
				sys__name = new TitanCharString_template();
				parameter = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					operation.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					sys__name.assign(template_sel.ANY_VALUE);
					parameter.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Proc__port__out_template() {
			// do nothing
		}

		public Proc__port__out_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Proc__port__out_template( final Proc__port__out otherValue ) {
			copyValue(otherValue);
		}

		public Proc__port__out_template( final Proc__port__out_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Proc__port__out_template( final Optional<Proc__port__out> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Proc_port_out from an unbound optional field.");
			}
		}

		//originally operator=
		public Proc__port__out_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Proc__port__out_template assign( final Proc__port__out other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Proc__port__out_template assign( final Proc__port__out_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Proc__port__out_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out) {
				return assign((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__out' can not be cast to {1}", otherValue));
		}

		@Override
		public Proc__port__out_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Proc__port__out_template) {
				return assign((Proc__port__out_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__out' can not be cast to {1}_template", otherValue));
		}

		public Proc__port__out_template assign( final Optional<Proc__port__out> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Proc_port_out.");
			}
			return this;
		}

		private void copyValue(final Proc__port__out other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getsys__name().isBound()) {
				getsys__name().assign(other_value.getsys__name());
			} else {
				getsys__name().cleanUp();
			}
			if (other_value.getparameter().isBound()) {
				getparameter().assign(other_value.getparameter());
			} else {
				getparameter().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Proc__port__out_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsys__name().get_selection()) {
					getsys__name().cleanUp();
				} else {
					getsys__name().assign(other_value.getsys__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparameter().get_selection()) {
					getparameter().cleanUp();
				} else {
					getparameter().assign(other_value.getparameter());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Proc__port__out_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Proc__port__out_template temp = new Proc__port__out_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Proc_port_out.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Proc__port__out valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			final Proc__port__out ret_val = new Proc__port__out();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (sys__name.isBound()) {
				ret_val.getsys__name().assign(sys__name.valueOf());
			}
			if (parameter.isBound()) {
				ret_val.getparameter().assign(parameter.valueOf());
			}
			return ret_val;
		}

		public Proc__port__out_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Proc_port_out.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Proc_port_out.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Proc_port_out.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Proc__port__out_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Proc__port__out_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (sys__name.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!sys__name.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Proc__port__out other_value) {
			return match(other_value, false);
		}

		public boolean match(final Proc__port__out other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getsys__name().isBound()) {
					return false;
				}
				if(!sys__name.match(other_value.getsys__name(), legacy)) {
					return false;
				}
				if(!other_value.getparameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getparameter(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Proc__port__out) {
				return match((Proc__port__out)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Proc__port__out.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(5);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sys_name := ");
				sys__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Proc__port__out match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Proc__port__out) {
				log_match((Proc__port__out)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Proc_port_out.");
		}

		public void log_match(final Proc__port__out match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sys__name.match(match_value.constGetsys__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sys_name");
							sys__name.log_match(match_value.constGetsys__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetparameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetparameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ sys_name := ");
				sys__name.log_match(match_value.constGetsys__name(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetparameter(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				sys__name.encode_text(text_buf);
				parameter.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Port__oper_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				sys__name = new TitanCharString_template();
				sys__name.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Proc__port__out_template>(size);
				for (int i = 0; i < size; i++) {
					final Proc__port__out_template temp = new Proc__port__out_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Proc_port_out has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsys__name().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sys_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsys__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Proc_port_out: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Proc_port_out");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_out" : name, legacy);
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_out" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_out" : name, legacy);
				this.sys__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_out" : name, legacy);
				this.parameter.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_out" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Proc_port_out" : name));
		}
	}
	public static void Proc__port__out_encoder(final Proc__port__out input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_decoder( final TitanOctetString input_stream, final Proc__port__out output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void VerdictOp_choice_setVerdict_encoder(final SetVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictOp_choice_setVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictOp_choice_setVerdict_decoder( final TitanOctetString input_stream, final SetVerdictType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictOp_choice_setVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Strings_str__list extends Base_Type {

		private List<TitanCharString> valueElements;

		public Strings_str__list() {
			// do nothing
		}

		public Strings_str__list( final Strings_str__list otherValue ) {
			otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.Strings.str_list.");
			valueElements = copyList( otherValue.valueElements );
		}

		public Strings_str__list(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copyList( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = getUnboundElem();
				if (srcElem.isBound()) {
					newElem.assign( srcElem );
				}
				newList.add( ( newElem ) );
			}
			return newList;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return valueElements != null;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !isBound() ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		@Override
		public boolean isValue() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.isValue()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Strings_str__list) {
				return operatorEquals((Strings_str__list)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type Strings_str__list.");
		}

		//originally operator==
		public boolean operatorEquals( final Strings_str__list otherValue ) {
			mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.Strings.str_list.");
			otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.Strings.str_list.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final TitanCharString rightElem = otherValue.valueElements.get( i );
				if (leftElem.isBound()) {
					if (rightElem.isBound()) {
						if ( !leftElem.operatorEquals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.isBound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public Strings_str__list assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings_str__list) {
				return assign((Strings_str__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
		}

		//originally operator=
		public Strings_str__list assign( final Strings_str__list aOtherValue ) {
			aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.Strings.str_list." );

			valueElements = copyList( aOtherValue.valueElements );
			return this;
		}

		public Strings_str__list assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		//originally operator+
		public Strings_str__list concatenate(final Strings_str__list other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @TitanLoggerApi.Strings.str_list concatenation.");
			}
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public Strings_str__list concatenate(final TitanNull_Type nullValue) {
			return new Strings_str__list(this);
		}

		//originally operator<<=
		public Strings_str__list rotateLeft(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate left operator.");
			return rotateLeft(rotate_count.getInt());
		}

		//originally operator<<=
		public Strings_str__list rotateLeft(final int rotate_count) {
			return rotateRight(-rotate_count);
		}

		//originally operator>>=
		public Strings_str__list rotateRight(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate right operator.");
			return rotateRight(rotate_count.getInt());
		}

		//originally operator>>=
		public Strings_str__list rotateRight(final int rotate_count) {
			if (valueElements == null) {
				throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
			}
			final int size = valueElements.size();
			if (size == 0) {
				return new Strings_str__list(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new Strings_str__list(this);
			}
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		//originally clean_up
		public void cleanUp() {
			valueElements = null;
		}

		//originally get_at(int)
		public TitanCharString getAt( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.Strings.str_list using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				setSize(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final TitanCharString newElem = getUnboundElem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		//originally get_at(const INTEGER&)
		public TitanCharString getAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.Strings.str_list." );
			return getAt( index_value.getInt() );
		}

		//originally get_at(int) const
		public TitanCharString constGetAt( final int index_value ) {
			if ( !isBound() ) {
				throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.Strings.str_list." );
			}
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.Strings.str_list using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().getInt();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.Strings.str_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem != null ) ? elem : getUnboundElem();
		}

		//originally get_at(const INTEGER&) const
		public TitanCharString constGetAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.Strings.str_list." );
			return constGetAt( index_value.getInt() );
		}

		public TitanInteger sizeOf() {
			mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return sizeOf();
		}

		public TitanInteger lengthOf() {
			mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.isBound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void setSize(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.Strings.str_list.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>();
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString getUnboundElem() {
			return new TitanCharString();
		}
		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */

		@Override
		public String toString() {
			if (!isBound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public Strings_str__list substr(final int index, final int returncount) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
			}
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.Strings.str_list","element");
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public Strings_str__list replace(final int index, final int len, final Strings_str__list repl) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
			}
			if (repl.valueElements == null) {
				throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
			}
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.Strings.str_list","element");
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public Strings_str__list replace(final int index, final int len, final Strings_str__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueOf());
		}

		public Strings_str__list replace(final int index, final TitanInteger len, final Strings_str__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.getInt(), repl.valueOf());
		}

		public Strings_str__list replace(final TitanInteger index, final int len, final Strings_str__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len, repl.valueOf());
		}

		public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len.getInt(), repl.valueOf());
		}
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					setSize(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(i).set_param(current);
							if (!constGetAt(i).isBound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						getAt(current.get_id().get_index()).set_param(current);
						if (!constGetAt(current.get_id().get_index()).isBound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.Strings.str_list");
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!isBound()) {
						assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthOf().getInt();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.Strings.str_list");
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.Strings.str_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Strings_str__list_template extends Record_Of_Template {

		//originally single_value/value_elements
		private List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		private List<Strings_str__list_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((Strings_str__list)value_ptr, value_index, (Strings_str__list_template)template_ptr, template_index, legacy);
			}
		};

		public Strings_str__list_template() {
			// do nothing
		}

		public Strings_str__list_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Strings_str__list_template( final Strings_str__list otherValue ) {
			copy_value( otherValue );
		}

		public Strings_str__list_template( final Strings_str__list_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Strings_str__list_template( final Optional<Strings_str__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Strings.str_list from an unbound optional field.");
			}
		}

		public Strings_str__list_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		private void copy_value(final Strings_str__list other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Initialization of a template of type @TitanLoggerApi.Strings.str_list with an unbound value.");
			}
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Strings_str__list_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGetAt(elem_count).isBound()) {
						value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Strings_str__list_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Strings_str__list_template temp = new Strings_str__list_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Strings.str_list.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		// originally match
		public boolean match(final Strings_str__list other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final Strings_str__list other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.Strings.str_list.");
			}
		}

		private boolean match_index(final Strings_str__list value_ptr, final int value_index, final Strings_str__list_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Strings_str__list) {
				return match((Strings_str__list)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		//originally operator=
		public Strings_str__list_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Strings_str__list_template assign( final Strings_str__list other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public Strings_str__list_template assign( final Strings_str__list_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Strings_str__list_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings_str__list) {
				return assign((Strings_str__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
		}

		@Override
		public Strings_str__list_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Strings_str__list_template) {
				return assign((Strings_str__list_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list_template.");
		}

		public Strings_str__list_template assign( final Optional<Strings_str__list> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Strings.str_list.");
			}
			return this;
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public Strings_str__list replace(final int index, final int len, final Strings_str__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl.valueOf());
		}

		public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
		}

		public Strings_str__list replace(final int index, final int len, final Strings_str__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl);
		}

		public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl);
		}

		public TitanCharString_template getAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.Strings.str_list using a negative index: {0}.", index_value ) );
			}

			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				setSize(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.Strings.str_list.");
			}
			return value_elements.get(index_value);
		}

		public TitanCharString_template getAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.Strings.str_list.");
			}

			return getAt(index_value.getInt());
		}

		public TitanCharString_template constGetAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.Strings.str_list using a negative index: {0}.", index_value ) );
			}

			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.Strings.str_list.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.Strings.str_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public TitanCharString_template constGetAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.Strings.str_list.");
			}

			return constGetAt(index_value.getInt());
		}

		private int get_length_for_concat(final AtomicBoolean is_any_value) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					if (templateSelection == template_sel.ANY_VALUE) {
						// ? => { * }
						is_any_value.set( true );
						return 1;
					}
					throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
				case RANGE_LENGTH_RESTRICTION:
					if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
						throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
					}
					// else fall through (range length restriction is allowed if the minimum
					// and maximum value are the same)
				case SINGLE_LENGTH_RESTRICTION:
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
				}
			default:
				throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
			}
		}

		private int get_length_for_concat(final Strings_str__list operand) {
			operand.mustBound("Operand of record of template concatenation is an unbound value.");
			return operand.valueElements.size();
		}


		private int get_length_for_concat(final template_sel operand) {
			if (operand == template_sel.ANY_VALUE) {
				// ? => { * }
				return 1;
			}
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}

		//TODO: simplify, just use value_elements.add()
		private void concat(final AtomicInteger pos, final Strings_str__list_template operand) {
			// all errors should have already been caught by the operand's
			// get_length_for_concat() call;
			// the result template (this) should already be set to SPECIFIC_VALUE and
			// single_value.value_elements should already be allocated
			switch (operand.templateSelection) {
			case SPECIFIC_VALUE:
				for (int i = 0; i < operand.value_elements.size(); ++i) {
					value_elements.set( pos.get() + i, new TitanCharString_template(operand.value_elements.get(i)) );
				}
				pos.addAndGet( operand.value_elements.size() );
				break;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (operand.length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					// ? => { * }
					value_elements.set( pos.get(), new TitanCharString_template( template_sel.ANY_OR_OMIT ) );
					pos.incrementAndGet();
					break;
				case RANGE_LENGTH_RESTRICTION:
				case SINGLE_LENGTH_RESTRICTION: {
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
					for (int i = 0; i < N; ++i) {
						value_elements.set( pos.get() + i, new TitanCharString_template( template_sel.ANY_VALUE ) );
					}
					pos.addAndGet( N );
					break; }
				}
			default:
				break;
			}
		}

		public void setSize(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.Strings.str_list.");
			}
			final template_sel old_selection = templateSelection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>();
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				final int oldSize = value_elements.size();
				for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
					value_elements.remove( new_size );
				}
			}
		}

		public TitanInteger sizeOf() {
			return sizeOf(true);
		}

		public TitanInteger lengthOf() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (templateSelection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.size()<1) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).getInt();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type Strings_str__list.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		public TitanInteger n_elem() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type Strings_str__list containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type Strings_str__list.");
		}

		private boolean matchv(final Strings_str__list other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).matchv(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type Strings_str__list.");
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).isValue()) {
					return false;
				}
			}
			return true;
		}

		public void setType(final template_sel template_type, final int list_length) {
			cleanUp();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Strings_str__list_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new Strings_str__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.Strings.str_list.");
			}
			set_selection(template_type);
		}

		public Strings_str__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.str_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Strings.str_list.");
			}
			return list_value.get(list_index);
		}

		public Strings_str__list_template get_list_item(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.str_list.");
			}
			if (list_index < 0) {
				throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.Strings.str_list using a negative index ({0}).", list_index ) );
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.Strings.str_list.");
			}
			return list_value.get( list_index );
		}

		public Strings_str__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Strings.str_list.");
			}
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public Strings_str__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final Strings_str__list match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Strings_str__list) {
				log_match((Strings_str__list)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Strings.str_list.");
		}

		public void log_match(final Strings_str__list match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Strings.str_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.Strings.str_list.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Strings_str__list_template>(size);
				for (int i = 0; i < size; i++) {
					final Strings_str__list_template temp2 = new Strings_str__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.Strings.str_list.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					setSize(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					getAt(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				setSize(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							getAt(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						getAt(current_index).set_param(param.get_elem(i));
						current_index++;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@TitanLoggerApi.Strings.str_list");
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (templateSelection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++)
					value_elements.get(i).check_restriction(restriction, name == null ? "@TitanLoggerApi.Strings.str_list" : name, false);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) return;
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Strings.str_list" : name));
		}
	}
	public static void Strings_str__list_encoder(final Strings_str__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings.str_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Strings_str__list_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Strings_str__list_decoder( final TitanOctetString input_stream, final Strings_str__list output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings.str_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Strings_str__list_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_executorRuntime,  ALT_executorConfigdata,  ALT_extcommandStart,  ALT_extcommandSuccess,  ALT_executorComponent,  ALT_logOptions,  ALT_executorMisc };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public ExecutorEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public ExecutorEvent_choice(final ExecutorEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final ExecutorEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_executorRuntime:
				field = new ExecutorRuntime((ExecutorRuntime)otherValue.field);
				break;
			case ALT_executorConfigdata:
				field = new ExecutorConfigdata((ExecutorConfigdata)otherValue.field);
				break;
			case ALT_extcommandStart:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_extcommandSuccess:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_executorComponent:
				field = new ExecutorComponent((ExecutorComponent)otherValue.field);
				break;
			case ALT_logOptions:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_executorMisc:
				field = new ExecutorUnqualified((ExecutorUnqualified)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public ExecutorEvent_choice assign( final ExecutorEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public ExecutorEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof ExecutorEvent_choice) {
				return assign((ExecutorEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_executorRuntime:
				return field.isValue();
			case ALT_executorConfigdata:
				return field.isValue();
			case ALT_extcommandStart:
				return field.isValue();
			case ALT_extcommandSuccess:
				return field.isValue();
			case ALT_executorComponent:
				return field.isValue();
			case ALT_logOptions:
				return field.isValue();
			case ALT_executorMisc:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final ExecutorEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_executorRuntime:
				return ((ExecutorRuntime)field).operatorEquals((ExecutorRuntime)otherValue.field);
			case ALT_executorConfigdata:
				return ((ExecutorConfigdata)field).operatorEquals((ExecutorConfigdata)otherValue.field);
			case ALT_extcommandStart:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_extcommandSuccess:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_executorComponent:
				return ((ExecutorComponent)field).operatorEquals((ExecutorComponent)otherValue.field);
			case ALT_logOptions:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_executorMisc:
				return ((ExecutorUnqualified)field).operatorEquals((ExecutorUnqualified)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof ExecutorEvent_choice) {
				return operatorEquals((ExecutorEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final ExecutorEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public ExecutorRuntime getexecutorRuntime() {
			if (union_selection != union_selection_type.ALT_executorRuntime) {
				cleanUp();
				field = new ExecutorRuntime();
				union_selection = union_selection_type.ALT_executorRuntime;
			}
			return (ExecutorRuntime)field;
		}

		public ExecutorRuntime constGetexecutorRuntime() {
			if (union_selection != union_selection_type.ALT_executorRuntime) {
				throw new TtcnError("Using non-selected field executorRuntime in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorRuntime)field;
		}

		public ExecutorConfigdata getexecutorConfigdata() {
			if (union_selection != union_selection_type.ALT_executorConfigdata) {
				cleanUp();
				field = new ExecutorConfigdata();
				union_selection = union_selection_type.ALT_executorConfigdata;
			}
			return (ExecutorConfigdata)field;
		}

		public ExecutorConfigdata constGetexecutorConfigdata() {
			if (union_selection != union_selection_type.ALT_executorConfigdata) {
				throw new TtcnError("Using non-selected field executorConfigdata in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorConfigdata)field;
		}

		public TitanCharString getextcommandStart() {
			if (union_selection != union_selection_type.ALT_extcommandStart) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_extcommandStart;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetextcommandStart() {
			if (union_selection != union_selection_type.ALT_extcommandStart) {
				throw new TtcnError("Using non-selected field extcommandStart in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString)field;
		}

		public TitanCharString getextcommandSuccess() {
			if (union_selection != union_selection_type.ALT_extcommandSuccess) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_extcommandSuccess;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetextcommandSuccess() {
			if (union_selection != union_selection_type.ALT_extcommandSuccess) {
				throw new TtcnError("Using non-selected field extcommandSuccess in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString)field;
		}

		public ExecutorComponent getexecutorComponent() {
			if (union_selection != union_selection_type.ALT_executorComponent) {
				cleanUp();
				field = new ExecutorComponent();
				union_selection = union_selection_type.ALT_executorComponent;
			}
			return (ExecutorComponent)field;
		}

		public ExecutorComponent constGetexecutorComponent() {
			if (union_selection != union_selection_type.ALT_executorComponent) {
				throw new TtcnError("Using non-selected field executorComponent in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorComponent)field;
		}

		public TitanCharString getlogOptions() {
			if (union_selection != union_selection_type.ALT_logOptions) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_logOptions;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetlogOptions() {
			if (union_selection != union_selection_type.ALT_logOptions) {
				throw new TtcnError("Using non-selected field logOptions in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString)field;
		}

		public ExecutorUnqualified getexecutorMisc() {
			if (union_selection != union_selection_type.ALT_executorMisc) {
				cleanUp();
				field = new ExecutorUnqualified();
				union_selection = union_selection_type.ALT_executorMisc;
			}
			return (ExecutorUnqualified)field;
		}

		public ExecutorUnqualified constGetexecutorMisc() {
			if (union_selection != union_selection_type.ALT_executorMisc) {
				throw new TtcnError("Using non-selected field executorMisc in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorUnqualified)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_executorRuntime:
				TTCN_Logger.log_event_str("{ executorRuntime := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_executorConfigdata:
				TTCN_Logger.log_event_str("{ executorConfigdata := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_extcommandStart:
				TTCN_Logger.log_event_str("{ extcommandStart := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_extcommandSuccess:
				TTCN_Logger.log_event_str("{ extcommandSuccess := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_executorComponent:
				TTCN_Logger.log_event_str("{ executorComponent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_logOptions:
				TTCN_Logger.log_event_str("{ logOptions := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_executorMisc:
				TTCN_Logger.log_event_str("{ executorMisc := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("executorRuntime".equals(last_name)) {
				getexecutorRuntime().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("executorConfigdata".equals(last_name)) {
				getexecutorConfigdata().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("extcommandStart".equals(last_name)) {
				getextcommandStart().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("extcommandSuccess".equals(last_name)) {
				getextcommandSuccess().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("executorComponent".equals(last_name)) {
				getexecutorComponent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("logOptions".equals(last_name)) {
				getlogOptions().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("executorMisc".equals(last_name)) {
				getexecutorMisc().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.ExecutorEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_executorRuntime:
			case ALT_executorConfigdata:
			case ALT_extcommandStart:
			case ALT_extcommandSuccess:
			case ALT_executorComponent:
			case ALT_logOptions:
			case ALT_executorMisc:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_executorRuntime:
				text_buf.push_int(0);
				break;
			case ALT_executorConfigdata:
				text_buf.push_int(1);
				break;
			case ALT_extcommandStart:
				text_buf.push_int(2);
				break;
			case ALT_extcommandSuccess:
				text_buf.push_int(3);
				break;
			case ALT_executorComponent:
				text_buf.push_int(4);
				break;
			case ALT_logOptions:
				text_buf.push_int(5);
				break;
			case ALT_executorMisc:
				text_buf.push_int(6);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getexecutorRuntime().decode_text(text_buf);
				break;
			case 1:
				getexecutorConfigdata().decode_text(text_buf);
				break;
			case 2:
				getextcommandStart().decode_text(text_buf);
				break;
			case 3:
				getextcommandSuccess().decode_text(text_buf);
				break;
			case 4:
				getexecutorComponent().decode_text(text_buf);
				break;
			case 5:
				getlogOptions().decode_text(text_buf);
				break;
			case 6:
				getexecutorMisc().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.ExecutorEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorEvent_choice_template extends Base_Template {
		//if single value which value?
		private ExecutorEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<ExecutorEvent_choice_template> value_list;

		private void copy_value(final ExecutorEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_executorRuntime:
				single_value = new ExecutorRuntime_template(other_value.constGetexecutorRuntime());
				break;
			case ALT_executorConfigdata:
				single_value = new ExecutorConfigdata_template(other_value.constGetexecutorConfigdata());
				break;
			case ALT_extcommandStart:
				single_value = new TitanCharString_template(other_value.constGetextcommandStart());
				break;
			case ALT_extcommandSuccess:
				single_value = new TitanCharString_template(other_value.constGetextcommandSuccess());
				break;
			case ALT_executorComponent:
				single_value = new ExecutorComponent_template(other_value.constGetexecutorComponent());
				break;
			case ALT_logOptions:
				single_value = new TitanCharString_template(other_value.constGetlogOptions());
				break;
			case ALT_executorMisc:
				single_value = new ExecutorUnqualified_template(other_value.constGetexecutorMisc());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final ExecutorEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_executorRuntime:
					single_value = new ExecutorRuntime_template(other_value.constGetexecutorRuntime());
					break;
				case ALT_executorConfigdata:
					single_value = new ExecutorConfigdata_template(other_value.constGetexecutorConfigdata());
					break;
				case ALT_extcommandStart:
					single_value = new TitanCharString_template(other_value.constGetextcommandStart());
					break;
				case ALT_extcommandSuccess:
					single_value = new TitanCharString_template(other_value.constGetextcommandSuccess());
					break;
				case ALT_executorComponent:
					single_value = new ExecutorComponent_template(other_value.constGetexecutorComponent());
					break;
				case ALT_logOptions:
					single_value = new TitanCharString_template(other_value.constGetlogOptions());
					break;
				case ALT_executorMisc:
					single_value = new ExecutorUnqualified_template(other_value.constGetexecutorMisc());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.ExecutorEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ExecutorEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final ExecutorEvent_choice_template temp = new ExecutorEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			set_selection(other_value);
		}

		public ExecutorEvent_choice_template() {
			// do nothing
		}
		public ExecutorEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public ExecutorEvent_choice_template(final ExecutorEvent_choice other_value) {
			copy_value(other_value);
		}
		public ExecutorEvent_choice_template(final ExecutorEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_executorRuntime:
					((ExecutorRuntime_template)single_value).cleanUp();
					break;
				case ALT_executorConfigdata:
					((ExecutorConfigdata_template)single_value).cleanUp();
					break;
				case ALT_extcommandStart:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_extcommandSuccess:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_executorComponent:
					((ExecutorComponent_template)single_value).cleanUp();
					break;
				case ALT_logOptions:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_executorMisc:
					((ExecutorUnqualified_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public ExecutorEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorEvent_choice_template assign( final ExecutorEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public ExecutorEvent_choice_template assign( final ExecutorEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public ExecutorEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof ExecutorEvent_choice) {
				return assign((ExecutorEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to ExecutorEvent_choice.");
		}

		@Override
		public ExecutorEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof ExecutorEvent_choice_template) {
				return assign((ExecutorEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to ExecutorEvent_choice_template.");
		}

		// originally match
		public boolean match(final ExecutorEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final ExecutorEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final ExecutorEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_executorRuntime:
					return ((ExecutorRuntime_template)single_value).match(other_value.getexecutorRuntime(), legacy);
				case ALT_executorConfigdata:
					return ((ExecutorConfigdata_template)single_value).match(other_value.getexecutorConfigdata(), legacy);
				case ALT_extcommandStart:
					return ((TitanCharString_template)single_value).match(other_value.getextcommandStart(), legacy);
				case ALT_extcommandSuccess:
					return ((TitanCharString_template)single_value).match(other_value.getextcommandSuccess(), legacy);
				case ALT_executorComponent:
					return ((ExecutorComponent_template)single_value).match(other_value.getexecutorComponent(), legacy);
				case ALT_logOptions:
					return ((TitanCharString_template)single_value).match(other_value.getlogOptions(), legacy);
				case ALT_executorMisc:
					return ((ExecutorUnqualified_template)single_value).match(other_value.getexecutorMisc(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorEvent_choice) {
				return match((ExecutorEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorEvent_choice.");
		}
		public boolean isChosen(final ExecutorEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_executorRuntime:
				return ((ExecutorRuntime_template)single_value).isValue();
			case ALT_executorConfigdata:
				return ((ExecutorConfigdata_template)single_value).isValue();
			case ALT_extcommandStart:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_extcommandSuccess:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_executorComponent:
				return ((ExecutorComponent_template)single_value).isValue();
			case ALT_logOptions:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_executorMisc:
				return ((ExecutorUnqualified_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
		}

		public ExecutorEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			final ExecutorEvent_choice ret_val = new ExecutorEvent_choice();
			switch (single_value_union_selection) {
			case ALT_executorRuntime:
				ret_val.getexecutorRuntime().assign(((ExecutorRuntime_template)single_value).valueOf());
				break;
			case ALT_executorConfigdata:
				ret_val.getexecutorConfigdata().assign(((ExecutorConfigdata_template)single_value).valueOf());
				break;
			case ALT_extcommandStart:
				ret_val.getextcommandStart().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_extcommandSuccess:
				ret_val.getextcommandSuccess().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_executorComponent:
				ret_val.getexecutorComponent().assign(((ExecutorComponent_template)single_value).valueOf());
				break;
			case ALT_logOptions:
				ret_val.getlogOptions().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_executorMisc:
				ret_val.getexecutorMisc().assign(((ExecutorUnqualified_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<ExecutorEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ExecutorEvent_choice_template());
			}
		}

		public ExecutorEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public ExecutorRuntime_template getexecutorRuntime() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorRuntime) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutorRuntime_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutorRuntime_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_executorRuntime;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutorRuntime_template)single_value;
		}

		public ExecutorRuntime_template constGetexecutorRuntime() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executorRuntime in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorRuntime) {
				throw new TtcnError("Accessing non-selected field executorRuntime in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorRuntime_template)single_value;
		}

		public ExecutorConfigdata_template getexecutorConfigdata() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorConfigdata) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutorConfigdata_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutorConfigdata_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_executorConfigdata;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutorConfigdata_template)single_value;
		}

		public ExecutorConfigdata_template constGetexecutorConfigdata() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executorConfigdata in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorConfigdata) {
				throw new TtcnError("Accessing non-selected field executorConfigdata in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorConfigdata_template)single_value;
		}

		public TitanCharString_template getextcommandStart() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_extcommandStart) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_extcommandStart;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetextcommandStart() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field extcommandStart in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_extcommandStart) {
				throw new TtcnError("Accessing non-selected field extcommandStart in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template getextcommandSuccess() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_extcommandSuccess) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_extcommandSuccess;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetextcommandSuccess() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field extcommandSuccess in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_extcommandSuccess) {
				throw new TtcnError("Accessing non-selected field extcommandSuccess in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public ExecutorComponent_template getexecutorComponent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorComponent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutorComponent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutorComponent_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_executorComponent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutorComponent_template)single_value;
		}

		public ExecutorComponent_template constGetexecutorComponent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executorComponent in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorComponent) {
				throw new TtcnError("Accessing non-selected field executorComponent in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorComponent_template)single_value;
		}

		public TitanCharString_template getlogOptions() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_logOptions) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_logOptions;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetlogOptions() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field logOptions in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_logOptions) {
				throw new TtcnError("Accessing non-selected field logOptions in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public ExecutorUnqualified_template getexecutorMisc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorMisc) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutorUnqualified_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutorUnqualified_template();
				}
				single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_executorMisc;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutorUnqualified_template)single_value;
		}

		public ExecutorUnqualified_template constGetexecutorMisc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executorMisc in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_executorMisc) {
				throw new TtcnError("Accessing non-selected field executorMisc in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
			}
			return (ExecutorUnqualified_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorEvent_choice) {
				log_match((ExecutorEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
		}

		public void log_match(final ExecutorEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_executorRuntime:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executorRuntime");
						single_value.log_match(match_value.getexecutorRuntime(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executorRuntime := ");
						single_value.log_match(match_value.getexecutorRuntime(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_executorConfigdata:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executorConfigdata");
						single_value.log_match(match_value.getexecutorConfigdata(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executorConfigdata := ");
						single_value.log_match(match_value.getexecutorConfigdata(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_extcommandStart:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".extcommandStart");
						single_value.log_match(match_value.getextcommandStart(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ extcommandStart := ");
						single_value.log_match(match_value.getextcommandStart(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_extcommandSuccess:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".extcommandSuccess");
						single_value.log_match(match_value.getextcommandSuccess(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ extcommandSuccess := ");
						single_value.log_match(match_value.getextcommandSuccess(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_executorComponent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executorComponent");
						single_value.log_match(match_value.getexecutorComponent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executorComponent := ");
						single_value.log_match(match_value.getexecutorComponent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_logOptions:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".logOptions");
						single_value.log_match(match_value.getlogOptions(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ logOptions := ");
						single_value.log_match(match_value.getlogOptions(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_executorMisc:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executorMisc");
						single_value.log_match(match_value.getexecutorMisc(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executorMisc := ");
						single_value.log_match(match_value.getexecutorMisc(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.ExecutorEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new ExecutorRuntime_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new ExecutorConfigdata_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new ExecutorComponent_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new ExecutorUnqualified_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ExecutorEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorEvent_choice_template temp2 = new ExecutorEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.ExecutorEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.ExecutorEvent.choice");
				}
				if("executorRuntime".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("executorConfigdata".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("extcommandStart".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("extcommandSuccess".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("executorComponent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("logOptions".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("executorMisc".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.ExecutorEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("executorRuntime".equals(last_name)) {
					getexecutorRuntime().set_param(mp_last);
					break;
				}
				if("executorConfigdata".equals(last_name)) {
					getexecutorConfigdata().set_param(mp_last);
					break;
				}
				if("extcommandStart".equals(last_name)) {
					getextcommandStart().set_param(mp_last);
					break;
				}
				if("extcommandSuccess".equals(last_name)) {
					getextcommandSuccess().set_param(mp_last);
					break;
				}
				if("executorComponent".equals(last_name)) {
					getexecutorComponent().set_param(mp_last);
					break;
				}
				if("logOptions".equals(last_name)) {
					getlogOptions().set_param(mp_last);
					break;
				}
				if("executorMisc".equals(last_name)) {
					getexecutorMisc().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.ExecutorEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.ExecutorEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_executorRuntime:
					((ExecutorRuntime_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_executorConfigdata:
					((ExecutorConfigdata_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_extcommandStart:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_extcommandSuccess:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_executorComponent:
					((ExecutorComponent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_logOptions:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				case ALT_executorMisc:
					((ExecutorUnqualified_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorEvent.choice" : name));
		}
	}
	public static void ExecutorEvent_choice_encoder(final ExecutorEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_decoder( final TitanOctetString input_stream, final ExecutorEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_nonePercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_nonePercent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_nonePercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_nonePercent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimerAnyTimeoutType extends Base_Type {
		private boolean bound_flag;

		public TimerAnyTimeoutType() {
			bound_flag = false;
		}

		public TimerAnyTimeoutType( final TitanNull_Type otherValue ) {
			bound_flag = true;
		}

		public TimerAnyTimeoutType( final TimerAnyTimeoutType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			bound_flag = true;
		}

		//originally operator=
		public TimerAnyTimeoutType assign( final TitanNull_Type otherValue ) {
			bound_flag = true;
			return this;
		}

		//originally operator=
		public TimerAnyTimeoutType assign( final TimerAnyTimeoutType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError("Assignment of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			bound_flag = true;
			return this;
		}

		@Override
		public TimerAnyTimeoutType assign( final Base_Type otherValue ) {
			if (otherValue instanceof TimerAnyTimeoutType) {
				return assign((TimerAnyTimeoutType)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to TimerAnyTimeoutType.");
		}

		//originally clean_up
		public void cleanUp() {
			bound_flag = false;
		}

		//originally is_bound
		public boolean isBound() {
			return bound_flag;
		}

		//originally is_present
		public boolean isPresent() {
			return isBound();
		}

		//originally is_value
		public boolean isValue() {
			return bound_flag;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !bound_flag ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		//originally operator==
		public boolean operatorEquals( final TitanNull_Type otherValue ) {
			if (!isBound()) {
				throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			return true;
		}

		//originally operator==
		public boolean operatorEquals( final TimerAnyTimeoutType otherValue ) {
			if (!isBound()) {
				throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			if (!otherValue.isBound()) {
				throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			return true;
		}

		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof TimerAnyTimeoutType) {
				return operatorEquals((TimerAnyTimeoutType)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerAnyTimeoutType.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final TitanNull_Type otherValue ) {
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals( final TimerAnyTimeoutType otherValue ) {
			return !operatorEquals(otherValue);
		}

		public boolean operatorNotEquals( final Base_Type otherValue ) {
			return !operatorEquals(otherValue);
		}

		public void log() {
			if (bound_flag) {
				TTCN_Logger.log_event_str("{ }");
				return;
			}
			TTCN_Logger.log_event_unbound();
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "empty record/set value (i.e. { })");
			if (param.get_type() != Module_Parameter.type_t.MP_Value_List || param.get_size() > 0) {
				param.type_error("empty record/set value (i.e. { })", "@TitanLoggerApi.TimerAnyTimeoutType");
			}
			bound_flag = true;
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			bound_flag = true;
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}

	public static class TimerAnyTimeoutType_template extends Base_Template {
		//originally value_list/list_value
		private List<TimerAnyTimeoutType_template> list_value;
		public TimerAnyTimeoutType_template() {
		}

		public TimerAnyTimeoutType_template(final template_sel other_value) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TimerAnyTimeoutType_template(final TitanNull_Type other_value) {
			super(template_sel.SPECIFIC_VALUE);
		}

		public TimerAnyTimeoutType_template(final TimerAnyTimeoutType other_value) {
			super(template_sel.SPECIFIC_VALUE);
			if (!other_value.isBound()) {
				throw new TtcnError("Creating a template from an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
		}

		public TimerAnyTimeoutType_template(final TimerAnyTimeoutType_template other_value) {
			copyTemplate( other_value );
		}

		public TimerAnyTimeoutType_template(final Optional<TimerAnyTimeoutType> other_value) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				set_selection(template_sel.SPECIFIC_VALUE);
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerAnyTimeoutType from an unbound optional field.");
			}
		}

		//originally operator=
		public TimerAnyTimeoutType_template assign(final template_sel other_value) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimerAnyTimeoutType_template assign(final TitanNull_Type other_value) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public TimerAnyTimeoutType_template assign(final TimerAnyTimeoutType other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Assignment of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType to a template.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public TimerAnyTimeoutType_template assign(final TimerAnyTimeoutType_template other_value) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TimerAnyTimeoutType_template assign(final Base_Type other_value) {
			if (other_value instanceof TimerAnyTimeoutType) {
				return assign((TimerAnyTimeoutType) other_value);
			}
			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerAnyTimeoutType' can not be cast to {1}", other_value));
		}

		@Override
		public TimerAnyTimeoutType_template assign(final Base_Template other_value) {
			if (other_value instanceof TimerAnyTimeoutType_template) {
				return assign((TimerAnyTimeoutType_template) other_value);
			}
			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerAnyTimeoutType' can not be cast to {1}_template", other_value));
		}

		public TimerAnyTimeoutType_template assign(final Optional<TimerAnyTimeoutType> other_value) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				set_selection(template_sel.SPECIFIC_VALUE);
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerAnyTimeoutType .");
			}
			return this;
		}

		public void copyTemplate(final TimerAnyTimeoutType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TimerAnyTimeoutType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TimerAnyTimeoutType_template temp = new TimerAnyTimeoutType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerAnyTimeoutType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			return new TimerAnyTimeoutType(TitanNull_Type.NULL_VALUE);
		}

		public TimerAnyTimeoutType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerAnyTimeoutType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerAnyTimeoutType_template());
			}
		}

		public boolean match(final TimerAnyTimeoutType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerAnyTimeoutType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			return match(TitanNull_Type.NULL_VALUE, legacy);
		}

		private boolean match(final TitanNull_Type other_value, final boolean legacy) {
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
		}

		@Override
		public boolean match(final Base_Type other_value, final boolean legacy) {
			if (other_value instanceof TimerAnyTimeoutType) {
				return match((TimerAnyTimeoutType)other_value, legacy);
			}
			throw new TtcnError("Internal Error: The left operand of assignment is not of type @TitanLoggerApi.TimerAnyTimeoutType.");
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_str("{ }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerAnyTimeoutType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerAnyTimeoutType) {
				log_match((TimerAnyTimeoutType)match_value, legacy);
				return;
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerAnyTimeoutType.");
		}

		public void log_match(final TimerAnyTimeoutType match_value, final boolean legacy) {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case SPECIFIC_VALUE:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case SPECIFIC_VALUE:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerAnyTimeoutType_template>(size);
				for (int i = 0; i < size; i++) {
					final TimerAnyTimeoutType_template temp = new TimerAnyTimeoutType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "empty record/set template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 0) {
					param.type_error("empty record/set template", "@TitanLoggerApi.TimerAnyTimeoutType");
				}
				assign(TitanNull_Type.NULL_VALUE);
				break;
			default:
				param.type_error("empty record/set template", "@TitanLoggerApi.TimerAnyTimeoutType");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimerAnyTimeoutType" : name));
		}
	}

	public static void TimerAnyTimeoutType_encoder(final TimerAnyTimeoutType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerAnyTimeoutType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerAnyTimeoutType_decoder( final TitanOctetString input_stream, final TimerAnyTimeoutType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerAnyTimeoutType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorRuntime_testcase__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_testcase__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingFailureType_port__type_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_port__type_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_alive___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_alive___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_alive___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_alive___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanSingleLogEvent_event_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanSingleLogEvent_event_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanSingleLogEvent_event_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanSingleLogEvent_event_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingProblemType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_alive__pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_alive__pid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_alive__pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_alive__pid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__recv_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class SetVerdictType extends Base_Type {
		private final Verdict newVerdict; //Referenced_Type
		private final Verdict oldVerdict; //Referenced_Type
		private final Verdict localVerdict; //Referenced_Type
		private final Optional<TitanCharString> oldReason; //CharString_Type
		private final Optional<TitanCharString> newReason; //CharString_Type

		public SetVerdictType() {
			this.newVerdict = new Verdict();
			this.oldVerdict = new Verdict();
			this.localVerdict = new Verdict();
			this.oldReason = new Optional<TitanCharString>(TitanCharString.class);
			this.newReason = new Optional<TitanCharString>(TitanCharString.class);
		}

		public SetVerdictType(final Verdict newVerdict, final Verdict oldVerdict, final Verdict localVerdict, final Optional<TitanCharString> oldReason, final Optional<TitanCharString> newReason ) {
			this.newVerdict = new Verdict( newVerdict );
			this.oldVerdict = new Verdict( oldVerdict );
			this.localVerdict = new Verdict( localVerdict );
			this.oldReason = new Optional<TitanCharString>(TitanCharString.class);
			this.oldReason.assign( oldReason );
			this.newReason = new Optional<TitanCharString>(TitanCharString.class);
			this.newReason.assign( newReason );
		}

		public SetVerdictType( final SetVerdictType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.SetVerdictType.");
			}
			newVerdict = new Verdict();
			oldVerdict = new Verdict();
			localVerdict = new Verdict();
			oldReason = new Optional<TitanCharString>(TitanCharString.class);
			newReason = new Optional<TitanCharString>(TitanCharString.class);
			assign( otherValue );
		}

		public SetVerdictType assign(final SetVerdictType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.SetVerdictType");
			}

			if (otherValue != this) {
				if ( otherValue.getnewVerdict().isBound() ) {
					this.newVerdict.assign( otherValue.getnewVerdict() );
				} else {
					this.newVerdict.cleanUp();
				}
				if ( otherValue.getoldVerdict().isBound() ) {
					this.oldVerdict.assign( otherValue.getoldVerdict() );
				} else {
					this.oldVerdict.cleanUp();
				}
				if ( otherValue.getlocalVerdict().isBound() ) {
					this.localVerdict.assign( otherValue.getlocalVerdict() );
				} else {
					this.localVerdict.cleanUp();
				}
				if ( otherValue.getoldReason().isBound() ) {
					this.oldReason.assign( otherValue.getoldReason() );
				} else {
					this.oldReason.cleanUp();
				}
				if ( otherValue.getnewReason().isBound() ) {
					this.newReason.assign( otherValue.getnewReason() );
				} else {
					this.newReason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public SetVerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType ) {
				return assign((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.SetVerdictType", otherValue));
		}

		public void cleanUp() {
			newVerdict.cleanUp();
			oldVerdict.cleanUp();
			localVerdict.cleanUp();
			oldReason.cleanUp();
			newReason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( newVerdict.isBound() ) { return true; }
			if ( oldVerdict.isBound() ) { return true; }
			if ( localVerdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(oldReason.get_selection()) || oldReason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(newReason.get_selection()) || newReason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !newVerdict.isValue() ) { return false; }
			if ( !oldVerdict.isValue() ) { return false; }
			if ( !localVerdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(oldReason.get_selection()) && !oldReason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(newReason.get_selection()) && !newReason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final SetVerdictType otherValue) {
			if ( !this.newVerdict.operatorEquals( otherValue.newVerdict ) ) { return false; }
			if ( !this.oldVerdict.operatorEquals( otherValue.oldVerdict ) ) { return false; }
			if ( !this.localVerdict.operatorEquals( otherValue.localVerdict ) ) { return false; }
			if ( !this.oldReason.operatorEquals( otherValue.oldReason ) ) { return false; }
			if ( !this.newReason.operatorEquals( otherValue.newReason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType ) {
				return operatorEquals((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.SetVerdictType", otherValue));
		}

		public Verdict getnewVerdict() {
			return newVerdict;
		}

		public Verdict constGetnewVerdict() {
			return newVerdict;
		}

		public Verdict getoldVerdict() {
			return oldVerdict;
		}

		public Verdict constGetoldVerdict() {
			return oldVerdict;
		}

		public Verdict getlocalVerdict() {
			return localVerdict;
		}

		public Verdict constGetlocalVerdict() {
			return localVerdict;
		}

		public Optional<TitanCharString> getoldReason() {
			return oldReason;
		}

		public Optional<TitanCharString> constGetoldReason() {
			return oldReason;
		}

		public Optional<TitanCharString> getnewReason() {
			return newReason;
		}

		public Optional<TitanCharString> constGetnewReason() {
			return newReason;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			if (oldReason.isPresent()) {
				sizeof++;
			}
			if (newReason.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" newVerdict := ");
			newVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" oldVerdict := ");
			oldVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" localVerdict := ");
			localVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" oldReason := ");
			oldReason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" newReason := ");
			newReason.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.SetVerdictType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnewVerdict().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoldVerdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlocalVerdict().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoldReason().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnewReason().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("newVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnewVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("oldVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoldVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlocalVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("oldReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoldReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("newReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnewReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.SetVerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.SetVerdictType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (newVerdict.isBound()) {
				newVerdict.set_implicit_omit();
			}
			if (oldVerdict.isBound()) {
				oldVerdict.set_implicit_omit();
			}
			if (localVerdict.isBound()) {
				localVerdict.set_implicit_omit();
			}
			if (oldReason.isBound()) {
				oldReason.set_implicit_omit();
			} else {
				oldReason.assign(template_sel.OMIT_VALUE);
			}
			if (newReason.isBound()) {
				newReason.set_implicit_omit();
			} else {
				newReason.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			newVerdict.encode_text(text_buf);
			oldVerdict.encode_text(text_buf);
			localVerdict.encode_text(text_buf);
			oldReason.encode_text(text_buf);
			newReason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			newVerdict.decode_text(text_buf);
			oldVerdict.decode_text(text_buf);
			localVerdict.decode_text(text_buf);
			oldReason.decode_text(text_buf);
			newReason.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class SetVerdictType_template extends Base_Template {

		private Verdict_template newVerdict; //Referenced_Type
		private Verdict_template oldVerdict; //Referenced_Type
		private Verdict_template localVerdict; //Referenced_Type
		private TitanCharString_template oldReason; //CharString_Type
		private TitanCharString_template newReason; //CharString_Type
		//originally value_list/list_value
		private List<SetVerdictType_template> list_value;

		public Verdict_template getnewVerdict() {
			setSpecific();
			return newVerdict;
		}

		public Verdict_template constGetnewVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field newVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			return newVerdict;
		}

		public Verdict_template getoldVerdict() {
			setSpecific();
			return oldVerdict;
		}

		public Verdict_template constGetoldVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field oldVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			return oldVerdict;
		}

		public Verdict_template getlocalVerdict() {
			setSpecific();
			return localVerdict;
		}

		public Verdict_template constGetlocalVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field localVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			return localVerdict;
		}

		public TitanCharString_template getoldReason() {
			setSpecific();
			return oldReason;
		}

		public TitanCharString_template constGetoldReason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field oldReason of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			return oldReason;
		}

		public TitanCharString_template getnewReason() {
			setSpecific();
			return newReason;
		}

		public TitanCharString_template constGetnewReason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field newReason of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			return newReason;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				newVerdict = new Verdict_template();
				oldVerdict = new Verdict_template();
				localVerdict = new Verdict_template();
				oldReason = new TitanCharString_template();
				newReason = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					newVerdict.assign(template_sel.ANY_VALUE);
					oldVerdict.assign(template_sel.ANY_VALUE);
					localVerdict.assign(template_sel.ANY_VALUE);
					oldReason.assign(template_sel.ANY_OR_OMIT);
					newReason.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public SetVerdictType_template() {
			// do nothing
		}

		public SetVerdictType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public SetVerdictType_template( final SetVerdictType otherValue ) {
			copyValue(otherValue);
		}

		public SetVerdictType_template( final SetVerdictType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public SetVerdictType_template( final Optional<SetVerdictType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.SetVerdictType from an unbound optional field.");
			}
		}

		//originally operator=
		public SetVerdictType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public SetVerdictType_template assign( final SetVerdictType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public SetVerdictType_template assign( final SetVerdictType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public SetVerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType) {
				return assign((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SetVerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public SetVerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof SetVerdictType_template) {
				return assign((SetVerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SetVerdictType' can not be cast to {1}_template", otherValue));
		}

		public SetVerdictType_template assign( final Optional<SetVerdictType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.SetVerdictType.");
			}
			return this;
		}

		private void copyValue(final SetVerdictType other_value) {
			if (other_value.getnewVerdict().isBound()) {
				getnewVerdict().assign(other_value.getnewVerdict());
			} else {
				getnewVerdict().cleanUp();
			}
			if (other_value.getoldVerdict().isBound()) {
				getoldVerdict().assign(other_value.getoldVerdict());
			} else {
				getoldVerdict().cleanUp();
			}
			if (other_value.getlocalVerdict().isBound()) {
				getlocalVerdict().assign(other_value.getlocalVerdict());
			} else {
				getlocalVerdict().cleanUp();
			}
			if (other_value.getoldReason().isBound()) {
				if (other_value.getoldReason().isPresent()) {
					getoldReason().assign(other_value.getoldReason().get());
				} else {
					getoldReason().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getoldReason().cleanUp();
			}
			if (other_value.getnewReason().isBound()) {
				if (other_value.getnewReason().isPresent()) {
					getnewReason().assign(other_value.getnewReason().get());
				} else {
					getnewReason().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getnewReason().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final SetVerdictType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnewVerdict().get_selection()) {
					getnewVerdict().cleanUp();
				} else {
					getnewVerdict().assign(other_value.getnewVerdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoldVerdict().get_selection()) {
					getoldVerdict().cleanUp();
				} else {
					getoldVerdict().assign(other_value.getoldVerdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getlocalVerdict().get_selection()) {
					getlocalVerdict().cleanUp();
				} else {
					getlocalVerdict().assign(other_value.getlocalVerdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoldReason().get_selection()) {
					getoldReason().cleanUp();
				} else {
					getoldReason().assign(other_value.getoldReason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnewReason().get_selection()) {
					getnewReason().cleanUp();
				} else {
					getnewReason().assign(other_value.getnewReason());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<SetVerdictType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final SetVerdictType_template temp = new SetVerdictType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.SetVerdictType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public SetVerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			final SetVerdictType ret_val = new SetVerdictType();
			if (newVerdict.isBound()) {
				ret_val.getnewVerdict().assign(newVerdict.valueOf());
			}
			if (oldVerdict.isBound()) {
				ret_val.getoldVerdict().assign(oldVerdict.valueOf());
			}
			if (localVerdict.isBound()) {
				ret_val.getlocalVerdict().assign(localVerdict.valueOf());
			}
			if (oldReason.isOmit()) {
				ret_val.getoldReason().assign(template_sel.OMIT_VALUE);
			} else if (oldReason.isBound()) {
				ret_val.getoldReason().assign(oldReason.valueOf());
			}
			if (newReason.isOmit()) {
				ret_val.getnewReason().assign(template_sel.OMIT_VALUE);
			} else if (newReason.isBound()) {
				ret_val.getnewReason().assign(newReason.valueOf());
			}
			return ret_val;
		}

		public SetVerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.SetVerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.SetVerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.SetVerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<SetVerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new SetVerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (newVerdict.isBound()) {
				return true;
			}
			if (oldVerdict.isBound()) {
				return true;
			}
			if (localVerdict.isBound()) {
				return true;
			}
			if (oldReason.isOmit() || oldReason.isBound()) {
				return true;
			}
			if (newReason.isOmit() || newReason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!newVerdict.isValue()) {
				return false;
			}
			if (!oldVerdict.isValue()) {
				return false;
			}
			if (!localVerdict.isValue()) {
				return false;
			}
			if (!oldReason.isOmit() && !oldReason.isValue()) {
				return false;
			}
			if (!newReason.isOmit() && !newReason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final SetVerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final SetVerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getnewVerdict().isBound()) {
					return false;
				}
				if(!newVerdict.match(other_value.getnewVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getoldVerdict().isBound()) {
					return false;
				}
				if(!oldVerdict.match(other_value.getoldVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getlocalVerdict().isBound()) {
					return false;
				}
				if(!localVerdict.match(other_value.getlocalVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getoldReason().isBound()) {
					return false;
				}
				if((other_value.getoldReason().isPresent() ? !oldReason.match(other_value.getoldReason().get(), legacy) : !oldReason.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getnewReason().isBound()) {
					return false;
				}
				if((other_value.getnewReason().isPresent() ? !newReason.match(other_value.getnewReason().get(), legacy) : !newReason.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof SetVerdictType) {
				return match((SetVerdictType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type SetVerdictType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				if (oldReason.isPresent()) {
					sizeof++;
				}
				if (newReason.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" newVerdict := ");
				newVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" oldVerdict := ");
				oldVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" localVerdict := ");
				localVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" oldReason := ");
				oldReason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" newReason := ");
				newReason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final SetVerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SetVerdictType) {
				log_match((SetVerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.SetVerdictType.");
		}

		public void log_match(final SetVerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !newVerdict.match(match_value.constGetnewVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".newVerdict");
							newVerdict.log_match(match_value.constGetnewVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !oldVerdict.match(match_value.constGetoldVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".oldVerdict");
							oldVerdict.log_match(match_value.constGetoldVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !localVerdict.match(match_value.constGetlocalVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".localVerdict");
							localVerdict.log_match(match_value.constGetlocalVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetoldReason().isPresent()) {
							if( !oldReason.match(match_value.constGetoldReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".oldReason");
								oldReason.log_match(match_value.constGetoldReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!oldReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".oldReason := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								oldReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetnewReason().isPresent()) {
							if( !newReason.match(match_value.constGetnewReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".newReason");
								newReason.log_match(match_value.constGetnewReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!newReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".newReason := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								newReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ newVerdict := ");
				newVerdict.log_match(match_value.constGetnewVerdict(), legacy);
				TTCN_Logger.log_event_str("{ oldVerdict := ");
				oldVerdict.log_match(match_value.constGetoldVerdict(), legacy);
				TTCN_Logger.log_event_str("{ localVerdict := ");
				localVerdict.log_match(match_value.constGetlocalVerdict(), legacy);
				TTCN_Logger.log_event_str("{ oldReason := ");
				oldReason.log_match(match_value.constGetoldReason(), legacy);
				TTCN_Logger.log_event_str("{ newReason := ");
				newReason.log_match(match_value.constGetnewReason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				newVerdict.encode_text(text_buf);
				oldVerdict.encode_text(text_buf);
				localVerdict.encode_text(text_buf);
				oldReason.encode_text(text_buf);
				newReason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				newVerdict = new Verdict_template();
				newVerdict.decode_text(text_buf);
				oldVerdict = new Verdict_template();
				oldVerdict.decode_text(text_buf);
				localVerdict = new Verdict_template();
				localVerdict.decode_text(text_buf);
				oldReason = new TitanCharString_template();
				oldReason.decode_text(text_buf);
				newReason = new TitanCharString_template();
				newReason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<SetVerdictType_template>(size);
				for (int i = 0; i < size; i++) {
					final SetVerdictType_template temp = new SetVerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.SetVerdictType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnewVerdict().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoldVerdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlocalVerdict().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoldReason().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnewReason().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("newVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnewVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("oldVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoldVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("localVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlocalVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("oldReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoldReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("newReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnewReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.SetVerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.SetVerdictType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.newVerdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.SetVerdictType" : name, legacy);
				this.oldVerdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.SetVerdictType" : name, legacy);
				this.localVerdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.SetVerdictType" : name, legacy);
				this.oldReason.check_restriction(restriction, name == null ? "@TitanLoggerApi.SetVerdictType" : name, legacy);
				this.newReason.check_restriction(restriction, name == null ? "@TitanLoggerApi.SetVerdictType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.SetVerdictType" : name));
		}
	}
	public static void SetVerdictType_encoder(final SetVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_decoder( final TitanOctetString input_stream, final SetVerdictType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorUnqualified_addr_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorUnqualified_addr_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorUnqualified_addr_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorUnqualified_addr_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_unhandledEvent_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_unhandledEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_unhandledEvent_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_unhandledEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Parallel_reason extends Base_Type {
		public enum enum_type {
			creating__new__ptc (0),
			function__stopped (1),
			terminating__test__component__exec (2),
			stopping__ptc (3),
			stop__no__effect (4),
			stopping__all__ptcs (5),
			stop__all__no__effect (6),
			killing__ptc (7),
			kill__no__effect (8),
			killing__all__ptcs (9),
			kill__all__no__effect (10),
			connecting__ports (11),
			disconnecting__ports (12),
			mapping__ports (13),
			unmapping__ports (14),
			kill__request__from__mc (15),
			killing__component (16),
			process__already__terminated (17),
			compref__not__exist (18),
			UNKNOWN_VALUE(19),
			UNBOUND_VALUE(20);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return creating__new__ptc;
				case 1:  return function__stopped;
				case 2:  return terminating__test__component__exec;
				case 3:  return stopping__ptc;
				case 4:  return stop__no__effect;
				case 5:  return stopping__all__ptcs;
				case 6:  return stop__all__no__effect;
				case 7:  return killing__ptc;
				case 8:  return kill__no__effect;
				case 9:  return killing__all__ptcs;
				case 10:  return kill__all__no__effect;
				case 11:  return connecting__ports;
				case 12:  return disconnecting__ports;
				case 13:  return mapping__ports;
				case 14:  return unmapping__ports;
				case 15:  return kill__request__from__mc;
				case 16:  return killing__component;
				case 17:  return process__already__terminated;
				case 18:  return compref__not__exist;
				case 19:  return UNKNOWN_VALUE;
				case 20:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Parallel_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Parallel_reason(final Parallel_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Parallel_reason(final Parallel_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Parallel_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Parallel_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Parallel_reason assign(final Parallel_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Parallel_reason assign(final Base_Type otherValue){
			if( otherValue instanceof Parallel_reason ) {
				return assign((Parallel_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Parallel_reason assign(final Parallel_reason.enum_type otherValue){
			return assign( new Parallel_reason(otherValue) );
		}

		//originally operator=
		public Parallel_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Parallel_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Parallel_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Parallel_reason) {
				return operatorEquals( (Parallel_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Parallel_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Parallel_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Parallel_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Parallel_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Parallel_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Parallel_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Parallel_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Parallel_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Parallel_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Parallel_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Parallel_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Parallel_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Parallel_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("creating__new__ptc".equals(strPar) || "creating_new_ptc".equals(strPar)) {
				return enum_type.creating__new__ptc;
			}
			if ("function__stopped".equals(strPar) || "function_stopped".equals(strPar)) {
				return enum_type.function__stopped;
			}
			if ("terminating__test__component__exec".equals(strPar) || "terminating_test_component_exec".equals(strPar)) {
				return enum_type.terminating__test__component__exec;
			}
			if ("stopping__ptc".equals(strPar) || "stopping_ptc".equals(strPar)) {
				return enum_type.stopping__ptc;
			}
			if ("stop__no__effect".equals(strPar) || "stop_no_effect".equals(strPar)) {
				return enum_type.stop__no__effect;
			}
			if ("stopping__all__ptcs".equals(strPar) || "stopping_all_ptcs".equals(strPar)) {
				return enum_type.stopping__all__ptcs;
			}
			if ("stop__all__no__effect".equals(strPar) || "stop_all_no_effect".equals(strPar)) {
				return enum_type.stop__all__no__effect;
			}
			if ("killing__ptc".equals(strPar) || "killing_ptc".equals(strPar)) {
				return enum_type.killing__ptc;
			}
			if ("kill__no__effect".equals(strPar) || "kill_no_effect".equals(strPar)) {
				return enum_type.kill__no__effect;
			}
			if ("killing__all__ptcs".equals(strPar) || "killing_all_ptcs".equals(strPar)) {
				return enum_type.killing__all__ptcs;
			}
			if ("kill__all__no__effect".equals(strPar) || "kill_all_no_effect".equals(strPar)) {
				return enum_type.kill__all__no__effect;
			}
			if ("connecting__ports".equals(strPar) || "connecting_ports".equals(strPar)) {
				return enum_type.connecting__ports;
			}
			if ("disconnecting__ports".equals(strPar) || "disconnecting_ports".equals(strPar)) {
				return enum_type.disconnecting__ports;
			}
			if ("mapping__ports".equals(strPar) || "mapping_ports".equals(strPar)) {
				return enum_type.mapping__ports;
			}
			if ("unmapping__ports".equals(strPar) || "unmapping_ports".equals(strPar)) {
				return enum_type.unmapping__ports;
			}
			if ("kill__request__from__mc".equals(strPar) || "kill_request_from_mc".equals(strPar)) {
				return enum_type.kill__request__from__mc;
			}
			if ("killing__component".equals(strPar) || "killing_component".equals(strPar)) {
				return enum_type.killing__component;
			}
			if ("process__already__terminated".equals(strPar) || "process_already_terminated".equals(strPar)) {
				return enum_type.process__already__terminated;
			}
			if ("compref__not__exist".equals(strPar) || "compref_not_exist".equals(strPar)) {
				return enum_type.compref__not__exist;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Parallel.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Parallel.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Parallel.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Parallel.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Parallel_reason_template extends Base_Template {
		// single_value
		private Parallel_reason.enum_type single_value;
		// value_list part
		private ArrayList<Parallel_reason_template> value_list;

		private void copy_template(final Parallel_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Parallel_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Parallel_reason_template temp = new Parallel_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Parallel_reason.");
			}
		}

		public Parallel_reason_template() {
			// do nothing
		}

		public Parallel_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Parallel_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Parallel_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Parallel_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = Parallel_reason.enum_type.getValue(otherValue);
		}

		public Parallel_reason_template(final Parallel_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Parallel_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Parallel_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public Parallel_reason_template(final Parallel_reason_template otherValue) {
			copy_template(otherValue);
		}

		public Parallel_reason_template(final Parallel_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Parallel_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Parallel_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Parallel_reason_template assign(final int otherValue) {
			if (!Parallel_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Parallel_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Parallel_reason_template assign(final Parallel_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Parallel_reason_template assign(final Parallel_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Parallel_reason_template assign(final Parallel_reason otherValue){
			if (otherValue.enum_value == Parallel_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Parallel_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Parallel_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof Parallel_reason ) {
				return assign((Parallel_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public Parallel_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof Parallel_reason_template ) {
				return assign((Parallel_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Parallel_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Parallel_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Parallel_reason.");
			}
		}

		// originally match
		public boolean match(final Parallel_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Parallel_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Parallel_reason ) {
				return match((Parallel_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
		}

		public Parallel_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Parallel_reason.");
			}
			return new Parallel_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Parallel_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Parallel_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Parallel_reason_template());
			}
		}

		public Parallel_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Parallel_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Parallel_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Parallel_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Parallel_reason.enum2str(single_value), Parallel_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Parallel_reason) {
				log_match((Parallel_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.reason.");
		}
		public void log_match(final Parallel_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Parallel_reason.enum_type enum_value = Parallel_reason.str_to_enum(param.get_enumerated());
				if (!Parallel_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Parallel.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Parallel.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Parallel.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Parallel_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Parallel.reason.", temp));
				}
				single_value = Parallel_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Parallel_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final Parallel_reason_template temp = new Parallel_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Parallel.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Parallel.reason" : name));
		}
	}
	public static void Parallel_reason_encoder(final Parallel_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_reason_decoder( final TitanOctetString input_stream, final Parallel_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_userLog_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_userLog_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_userLog_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_userLog_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutionSummaryType_numberOfTestcases_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutionSummaryType_numberOfTestcases_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutionSummaryType_numberOfTestcases_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutionSummaryType_numberOfTestcases_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_procPortSend_encoder(final Proc__port__out input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_procPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_procPortSend_decoder( final TitanOctetString input_stream, final Proc__port__out output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_procPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_new__size_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_new__size_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_new__size_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_new__size_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_pass___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_pass___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_pass___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_pass___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_msgPortRecv_encoder(final Msg__port__recv input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_msgPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_msgPortRecv_decoder( final TitanOctetString input_stream, final Msg__port__recv output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_msgPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class PortType extends Base_Type {
		public enum enum_type {
			message__ (0),
			procedure__ (1),
			UNKNOWN_VALUE(2),
			UNBOUND_VALUE(3);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return message__;
				case 1:  return procedure__;
				case 2:  return UNKNOWN_VALUE;
				case 3:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public PortType() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public PortType(final PortType otherValue) {
			enum_value = otherValue.enum_value;
		}

		public PortType(final PortType.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public PortType(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `PortType' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public PortType assign(final PortType otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public PortType assign(final Base_Type otherValue){
			if( otherValue instanceof PortType ) {
				return assign((PortType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public PortType assign(final PortType.enum_type otherValue){
			return assign( new PortType(otherValue) );
		}

		//originally operator=
		public PortType assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `PortType'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final PortType otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof PortType) {
				return operatorEquals( (PortType) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortType.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final PortType.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final PortType otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final PortType.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final PortType.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final PortType otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final PortType.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final PortType otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final PortType.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final PortType otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final PortType.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final PortType otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final PortType.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final PortType enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("message__".equals(strPar) || "message_".equals(strPar)) {
				return enum_type.message__;
			}
			if ("procedure__".equals(strPar) || "procedure_".equals(strPar)) {
				return enum_type.procedure__;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.PortType");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.PortType.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.PortType.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.PortType.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class PortType_template extends Base_Template {
		// single_value
		private PortType.enum_type single_value;
		// value_list part
		private ArrayList<PortType_template> value_list;

		private void copy_template(final PortType_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<PortType_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final PortType_template temp = new PortType_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type PortType.");
			}
		}

		public PortType_template() {
			// do nothing
		}

		public PortType_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public PortType_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!PortType.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type PortType with unknown numeric value "+ otherValue +".");
			}
			single_value = PortType.enum_type.getValue(otherValue);
		}

		public PortType_template(final PortType otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == PortType.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type PortType. ");
			}
			single_value = otherValue.enum_value;
		}

		public PortType_template(final PortType_template otherValue) {
			copy_template(otherValue);
		}

		public PortType_template(final PortType.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != PortType.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public PortType_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public PortType_template assign(final int otherValue) {
			if (!PortType.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type PortType.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public PortType_template assign(final PortType.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public PortType_template assign(final PortType_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public PortType_template assign(final PortType otherValue){
			if (otherValue.enum_value == PortType.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type PortType to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public PortType_template assign(final Base_Type otherValue){
			if( otherValue instanceof PortType ) {
				return assign((PortType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
		}

		@Override
		public PortType_template assign(final Base_Template otherValue){
			if( otherValue instanceof PortType_template ) {
				return assign((PortType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortType'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final PortType.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final PortType.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type PortType.");
			}
		}

		// originally match
		public boolean match(final PortType otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final PortType otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof PortType ) {
				return match((PortType) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
		}

		public PortType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type PortType.");
			}
			return new PortType(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type PortType.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<PortType_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new PortType_template());
			}
		}

		public PortType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type PortType.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type PortType.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type PortType.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(PortType.enum2str(single_value), PortType.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PortType) {
				log_match((PortType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortType.");
		}
		public void log_match(final PortType match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final PortType.enum_type enum_value = PortType.str_to_enum(param.get_enumerated());
				if (!PortType.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.PortType.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.PortType");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.PortType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!PortType.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.PortType.", temp));
				}
				single_value = PortType.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<PortType_template>(size);
				for (int i = 0; i < size; i++) {
					final PortType_template temp = new PortType_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.PortType.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.PortType" : name));
		}
	}
	public static void PortType_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortType_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingFailureType_choice_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_choice_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_choice_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_choice_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorComponent_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorComponent_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorComponent_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorComponent_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_portState_encoder(final Port__State input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_portState_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_portState_decoder( final TitanOctetString input_stream, final Port__State output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_portState_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_dualDiscard_encoder(final Dualface__discard input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_dualDiscard_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_dualDiscard_decoder( final TitanOctetString input_stream, final Dualface__discard output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_dualDiscard_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_is__ptc_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_is__ptc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_is__ptc_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_is__ptc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_verdict__reason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_verdict__reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_verdict__reason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_verdict__reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void SetVerdictType_newReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_newReason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_newReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_newReason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class WarningEvent extends Base_Type {
		private final TitanCharString text; //CharString_Type

		public WarningEvent() {
			this.text = new TitanCharString();
		}

		public WarningEvent(final TitanCharString text ) {
			this.text = new TitanCharString( text );
		}

		public WarningEvent( final WarningEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.WarningEvent.");
			}
			text = new TitanCharString();
			assign( otherValue );
		}

		public WarningEvent assign(final WarningEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.WarningEvent");
			}

			if (otherValue != this) {
				if ( otherValue.gettext().isBound() ) {
					this.text.assign( otherValue.gettext() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public WarningEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent ) {
				return assign((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.WarningEvent", otherValue));
		}

		public void cleanUp() {
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final WarningEvent otherValue) {
			if ( !this.text.operatorEquals( otherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent ) {
				return operatorEquals((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.WarningEvent", otherValue));
		}

		public TitanCharString gettext() {
			return text;
		}

		public TitanCharString constGettext() {
			return text;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.WarningEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.WarningEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.WarningEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			text.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class WarningEvent_template extends Base_Template {

		private TitanCharString_template text; //CharString_Type
		//originally value_list/list_value
		private List<WarningEvent_template> list_value;

		public TitanCharString_template gettext() {
			setSpecific();
			return text;
		}

		public TitanCharString_template constGettext() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.WarningEvent.");
			}
			return text;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				text = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					text.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public WarningEvent_template() {
			// do nothing
		}

		public WarningEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public WarningEvent_template( final WarningEvent otherValue ) {
			copyValue(otherValue);
		}

		public WarningEvent_template( final WarningEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public WarningEvent_template( final Optional<WarningEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.WarningEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public WarningEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public WarningEvent_template assign( final WarningEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public WarningEvent_template assign( final WarningEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public WarningEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent) {
				return assign((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `WarningEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public WarningEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof WarningEvent_template) {
				return assign((WarningEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `WarningEvent' can not be cast to {1}_template", otherValue));
		}

		public WarningEvent_template assign( final Optional<WarningEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.WarningEvent.");
			}
			return this;
		}

		private void copyValue(final WarningEvent other_value) {
			if (other_value.gettext().isBound()) {
				gettext().assign(other_value.gettext());
			} else {
				gettext().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final WarningEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettext().get_selection()) {
					gettext().cleanUp();
				} else {
					gettext().assign(other_value.gettext());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<WarningEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final WarningEvent_template temp = new WarningEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.WarningEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public WarningEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.WarningEvent.");
			}
			final WarningEvent ret_val = new WarningEvent();
			if (text.isBound()) {
				ret_val.gettext().assign(text.valueOf());
			}
			return ret_val;
		}

		public WarningEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.WarningEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.WarningEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.WarningEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<WarningEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new WarningEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final WarningEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final WarningEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.gettext().isBound()) {
					return false;
				}
				if(!text.match(other_value.gettext(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof WarningEvent) {
				return match((WarningEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type WarningEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final WarningEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof WarningEvent) {
				log_match((WarningEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.WarningEvent.");
		}

		public void log_match(final WarningEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !text.match(match_value.constGettext(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGettext(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGettext(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<WarningEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final WarningEvent_template temp = new WarningEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.WarningEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.WarningEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.WarningEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.text.check_restriction(restriction, name == null ? "@TitanLoggerApi.WarningEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.WarningEvent" : name));
		}
	}
	public static void WarningEvent_encoder(final WarningEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.WarningEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(WarningEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger WarningEvent_decoder( final TitanOctetString input_stream, final WarningEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.WarningEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(WarningEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParPort_operation extends Base_Type {
		public enum enum_type {
			connect__ (0),
			disconnect__ (1),
			map__ (2),
			unmap__ (3),
			UNKNOWN_VALUE(4),
			UNBOUND_VALUE(5);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return connect__;
				case 1:  return disconnect__;
				case 2:  return map__;
				case 3:  return unmap__;
				case 4:  return UNKNOWN_VALUE;
				case 5:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ParPort_operation() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ParPort_operation(final ParPort_operation otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ParPort_operation(final ParPort_operation.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ParPort_operation(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ParPort_operation' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ParPort_operation assign(final ParPort_operation otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ParPort_operation assign(final Base_Type otherValue){
			if( otherValue instanceof ParPort_operation ) {
				return assign((ParPort_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ParPort_operation assign(final ParPort_operation.enum_type otherValue){
			return assign( new ParPort_operation(otherValue) );
		}

		//originally operator=
		public ParPort_operation assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ParPort_operation'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ParPort_operation otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ParPort_operation) {
				return operatorEquals( (ParPort_operation) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.operation.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ParPort_operation.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ParPort_operation otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ParPort_operation.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ParPort_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ParPort_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ParPort_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ParPort_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ParPort_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ParPort_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ParPort_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ParPort_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ParPort_operation.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ParPort_operation enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("connect__".equals(strPar) || "connect_".equals(strPar)) {
				return enum_type.connect__;
			}
			if ("disconnect__".equals(strPar) || "disconnect_".equals(strPar)) {
				return enum_type.disconnect__;
			}
			if ("map__".equals(strPar) || "map_".equals(strPar)) {
				return enum_type.map__;
			}
			if ("unmap__".equals(strPar) || "unmap_".equals(strPar)) {
				return enum_type.unmap__;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ParPort.operation");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ParPort.operation.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ParPort.operation.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParPort.operation.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParPort_operation_template extends Base_Template {
		// single_value
		private ParPort_operation.enum_type single_value;
		// value_list part
		private ArrayList<ParPort_operation_template> value_list;

		private void copy_template(final ParPort_operation_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ParPort_operation_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ParPort_operation_template temp = new ParPort_operation_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ParPort_operation.");
			}
		}

		public ParPort_operation_template() {
			// do nothing
		}

		public ParPort_operation_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ParPort_operation_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ParPort_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ParPort_operation with unknown numeric value "+ otherValue +".");
			}
			single_value = ParPort_operation.enum_type.getValue(otherValue);
		}

		public ParPort_operation_template(final ParPort_operation otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ParPort_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ParPort_operation. ");
			}
			single_value = otherValue.enum_value;
		}

		public ParPort_operation_template(final ParPort_operation_template otherValue) {
			copy_template(otherValue);
		}

		public ParPort_operation_template(final ParPort_operation.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ParPort_operation.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ParPort_operation_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ParPort_operation_template assign(final int otherValue) {
			if (!ParPort_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ParPort_operation.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ParPort_operation_template assign(final ParPort_operation.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ParPort_operation_template assign(final ParPort_operation_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ParPort_operation_template assign(final ParPort_operation otherValue){
			if (otherValue.enum_value == ParPort_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ParPort_operation to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ParPort_operation_template assign(final Base_Type otherValue){
			if( otherValue instanceof ParPort_operation ) {
				return assign((ParPort_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
		}

		@Override
		public ParPort_operation_template assign(final Base_Template otherValue){
			if( otherValue instanceof ParPort_operation_template ) {
				return assign((ParPort_operation_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ParPort_operation.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ParPort_operation.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ParPort_operation.");
			}
		}

		// originally match
		public boolean match(final ParPort_operation otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ParPort_operation otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ParPort_operation ) {
				return match((ParPort_operation) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
		}

		public ParPort_operation valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ParPort_operation.");
			}
			return new ParPort_operation(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ParPort_operation.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ParPort_operation_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ParPort_operation_template());
			}
		}

		public ParPort_operation_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ParPort_operation.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ParPort_operation.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ParPort_operation.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ParPort_operation.enum2str(single_value), ParPort_operation.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParPort_operation) {
				log_match((ParPort_operation)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.operation.");
		}
		public void log_match(final ParPort_operation match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ParPort_operation.enum_type enum_value = ParPort_operation.str_to_enum(param.get_enumerated());
				if (!ParPort_operation.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ParPort.operation.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ParPort.operation");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ParPort.operation.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ParPort_operation.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParPort.operation.", temp));
				}
				single_value = ParPort_operation.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ParPort_operation_template>(size);
				for (int i = 0; i < size; i++) {
					final ParPort_operation_template temp = new ParPort_operation_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ParPort.operation.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParPort.operation" : name));
		}
	}
	public static void ParPort_operation_encoder(final ParPort_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_operation_decoder( final TitanOctetString input_stream, final ParPort_operation output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ComponentIDType extends Base_Type {
		private final TitanInteger id; //Integer_Type
		private final TitanCharString name; //CharString_Type

		public ComponentIDType() {
			this.id = new TitanInteger();
			this.name = new TitanCharString();
		}

		public ComponentIDType(final TitanInteger id, final TitanCharString name ) {
			this.id = new TitanInteger( id );
			this.name = new TitanCharString( name );
		}

		public ComponentIDType( final ComponentIDType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ComponentIDType.");
			}
			id = new TitanInteger();
			name = new TitanCharString();
			assign( otherValue );
		}

		public ComponentIDType assign(final ComponentIDType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ComponentIDType");
			}

			if (otherValue != this) {
				if ( otherValue.getid().isBound() ) {
					this.id.assign( otherValue.getid() );
				} else {
					this.id.cleanUp();
				}
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ComponentIDType assign(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType ) {
				return assign((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ComponentIDType", otherValue));
		}

		public void cleanUp() {
			id.cleanUp();
			name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( id.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !id.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ComponentIDType otherValue) {
			if ( !this.id.operatorEquals( otherValue.id ) ) { return false; }
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType ) {
				return operatorEquals((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ComponentIDType", otherValue));
		}

		public TitanInteger getid() {
			return id;
		}

		public TitanInteger constGetid() {
			return id;
		}

		public TitanCharString getname() {
			return name;
		}

		public TitanCharString constGetname() {
			return name;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" id := ");
			id.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ComponentIDType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getid().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("id".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ComponentIDType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ComponentIDType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (id.isBound()) {
				id.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			id.encode_text(text_buf);
			name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			id.decode_text(text_buf);
			name.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ComponentIDType_template extends Base_Template {

		private TitanInteger_template id; //Integer_Type
		private TitanCharString_template name; //CharString_Type
		//originally value_list/list_value
		private List<ComponentIDType_template> list_value;

		public TitanInteger_template getid() {
			setSpecific();
			return id;
		}

		public TitanInteger_template constGetid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field id of a non-specific template of type @TitanLoggerApi.ComponentIDType.");
			}
			return id;
		}

		public TitanCharString_template getname() {
			setSpecific();
			return name;
		}

		public TitanCharString_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ComponentIDType.");
			}
			return name;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				id = new TitanInteger_template();
				name = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					id.assign(template_sel.ANY_VALUE);
					name.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ComponentIDType_template() {
			// do nothing
		}

		public ComponentIDType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ComponentIDType_template( final ComponentIDType otherValue ) {
			copyValue(otherValue);
		}

		public ComponentIDType_template( final ComponentIDType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ComponentIDType_template( final Optional<ComponentIDType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ComponentIDType from an unbound optional field.");
			}
		}

		//originally operator=
		public ComponentIDType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ComponentIDType_template assign( final ComponentIDType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ComponentIDType_template assign( final ComponentIDType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ComponentIDType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType) {
				return assign((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ComponentIDType' can not be cast to {1}", otherValue));
		}

		@Override
		public ComponentIDType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ComponentIDType_template) {
				return assign((ComponentIDType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ComponentIDType' can not be cast to {1}_template", otherValue));
		}

		public ComponentIDType_template assign( final Optional<ComponentIDType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ComponentIDType.");
			}
			return this;
		}

		private void copyValue(final ComponentIDType other_value) {
			if (other_value.getid().isBound()) {
				getid().assign(other_value.getid());
			} else {
				getid().cleanUp();
			}
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ComponentIDType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getid().get_selection()) {
					getid().cleanUp();
				} else {
					getid().assign(other_value.getid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ComponentIDType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ComponentIDType_template temp = new ComponentIDType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ComponentIDType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ComponentIDType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ComponentIDType.");
			}
			final ComponentIDType ret_val = new ComponentIDType();
			if (id.isBound()) {
				ret_val.getid().assign(id.valueOf());
			}
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			return ret_val;
		}

		public ComponentIDType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ComponentIDType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ComponentIDType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ComponentIDType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ComponentIDType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ComponentIDType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (id.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!id.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ComponentIDType other_value) {
			return match(other_value, false);
		}

		public boolean match(final ComponentIDType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getid().isBound()) {
					return false;
				}
				if(!id.match(other_value.getid(), legacy)) {
					return false;
				}
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ComponentIDType) {
				return match((ComponentIDType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ComponentIDType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" id := ");
				id.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ComponentIDType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ComponentIDType) {
				log_match((ComponentIDType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ComponentIDType.");
		}

		public void log_match(final ComponentIDType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !id.match(match_value.constGetid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".id");
							id.log_match(match_value.constGetid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ id := ");
				id.log_match(match_value.constGetid(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				id.encode_text(text_buf);
				name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				id = new TitanInteger_template();
				id.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ComponentIDType_template>(size);
				for (int i = 0; i < size; i++) {
					final ComponentIDType_template temp = new ComponentIDType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ComponentIDType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getid().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("id".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ComponentIDType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ComponentIDType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.id.check_restriction(restriction, name == null ? "@TitanLoggerApi.ComponentIDType" : name, legacy);
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.ComponentIDType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ComponentIDType" : name));
		}
	}
	public static void ComponentIDType_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ComponentIDType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ComponentIDType_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ComponentIDType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StartFunction_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StartFunction_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StartFunction_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StartFunction_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_controlpartErrors_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_controlpartErrors_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_controlpartErrors_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_controlpartErrors_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void SetVerdictType_localVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_localVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_localVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_localVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLog_sequence__list_0_event__list extends Base_Type {

		private List<TitanLogEvent> valueElements;

		public TitanLog_sequence__list_0_event__list() {
			// do nothing
		}

		public TitanLog_sequence__list_0_event__list( final TitanLog_sequence__list_0_event__list otherValue ) {
			otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			valueElements = copyList( otherValue.valueElements );
		}

		public TitanLog_sequence__list_0_event__list(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanLogEvent>();
		}

		private static final List<TitanLogEvent> copyList( final List<TitanLogEvent> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanLogEvent> newList = new ArrayList<TitanLogEvent>( srcList.size() );
			for (final TitanLogEvent srcElem : srcList) {
				final TitanLogEvent newElem = getUnboundElem();
				if (srcElem.isBound()) {
					newElem.assign( srcElem );
				}
				newList.add( ( newElem ) );
			}
			return newList;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return valueElements != null;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !isBound() ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		@Override
		public boolean isValue() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final TitanLogEvent elem = valueElements.get(i);
				if (elem == null || !elem.isValue()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
				return operatorEquals((TitanLog_sequence__list_0_event__list)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLog_sequence__list_0_event__list.");
		}

		//originally operator==
		public boolean operatorEquals( final TitanLog_sequence__list_0_event__list otherValue ) {
			mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanLogEvent leftElem = valueElements.get( i );
				final TitanLogEvent rightElem = otherValue.valueElements.get( i );
				if (leftElem.isBound()) {
					if (rightElem.isBound()) {
						if ( !leftElem.operatorEquals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.isBound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public TitanLog_sequence__list_0_event__list assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
				return assign((TitanLog_sequence__list_0_event__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
		}

		//originally operator=
		public TitanLog_sequence__list_0_event__list assign( final TitanLog_sequence__list_0_event__list aOtherValue ) {
			aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );

			valueElements = copyList( aOtherValue.valueElements );
			return this;
		}

		public TitanLog_sequence__list_0_event__list assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanLogEvent>();
			return this;
		}

		//originally operator+
		public TitanLog_sequence__list_0_event__list concatenate(final TitanLog_sequence__list_0_event__list other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list concatenation.");
			}
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final TitanLogEvent elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final TitanLogEvent elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_event__list concatenate(final TitanNull_Type nullValue) {
			return new TitanLog_sequence__list_0_event__list(this);
		}

		//originally operator<<=
		public TitanLog_sequence__list_0_event__list rotateLeft(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate left operator.");
			return rotateLeft(rotate_count.getInt());
		}

		//originally operator<<=
		public TitanLog_sequence__list_0_event__list rotateLeft(final int rotate_count) {
			return rotateRight(-rotate_count);
		}

		//originally operator>>=
		public TitanLog_sequence__list_0_event__list rotateRight(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate right operator.");
			return rotateRight(rotate_count.getInt());
		}

		//originally operator>>=
		public TitanLog_sequence__list_0_event__list rotateRight(final int rotate_count) {
			if (valueElements == null) {
				throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			final int size = valueElements.size();
			if (size == 0) {
				return new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new TitanLog_sequence__list_0_event__list(this);
			}
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanLogEvent elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanLogEvent elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			return ret_val;
		}

		//originally clean_up
		public void cleanUp() {
			valueElements = null;
		}

		//originally get_at(int)
		public TitanLogEvent getAt( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				setSize(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final TitanLogEvent newElem = getUnboundElem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		//originally get_at(const INTEGER&)
		public TitanLogEvent getAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
			return getAt( index_value.getInt() );
		}

		//originally get_at(int) const
		public TitanLogEvent constGetAt( final int index_value ) {
			if ( !isBound() ) {
				throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
			}
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().getInt();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanLogEvent elem = valueElements.get( index_value );
			return ( elem != null ) ? elem : getUnboundElem();
		}

		//originally get_at(const INTEGER&) const
		public TitanLogEvent constGetAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
			return constGetAt( index_value.getInt() );
		}

		public TitanInteger sizeOf() {
			mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return sizeOf();
		}

		public TitanInteger lengthOf() {
			mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanLogEvent elem = valueElements.get( i );
				if ( elem != null && elem.isBound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void setSize(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanLogEvent>();
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new TitanLogEvent() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanLogEvent getUnboundElem() {
			return new TitanLogEvent();
		}
		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */

		@Override
		public String toString() {
			if (!isBound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public TitanLog_sequence__list_0_event__list substr(final int index, final int returncount) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list","element");
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanLogEvent(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list repl) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			if (repl.valueElements == null) {
				throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list","element");
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanLogEvent elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanLogEvent elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final TitanLogEvent elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLogEvent(elem));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueOf());
		}

		public TitanLog_sequence__list_0_event__list replace(final int index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.getInt(), repl.valueOf());
		}

		public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len, repl.valueOf());
		}

		public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len.getInt(), repl.valueOf());
		}
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					setSize(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(i).set_param(current);
							if (!constGetAt(i).isBound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						getAt(current.get_id().get_index()).set_param(current);
						if (!constGetAt(current.get_id().get_index()).isBound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list");
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!isBound()) {
						assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthOf().getInt();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list");
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanLogEvent>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanLogEvent temp2 = new TitanLogEvent();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLog_sequence__list_0_event__list_template extends Record_Of_Template {

		//originally single_value/value_elements
		private List<TitanLogEvent_template> value_elements;

		//originally value_list/list_value
		private List<TitanLog_sequence__list_0_event__list_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((TitanLog_sequence__list_0_event__list)value_ptr, value_index, (TitanLog_sequence__list_0_event__list_template)template_ptr, template_index, legacy);
			}
		};

		public TitanLog_sequence__list_0_event__list_template() {
			// do nothing
		}

		public TitanLog_sequence__list_0_event__list_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLog_sequence__list_0_event__list_template( final TitanLog_sequence__list_0_event__list otherValue ) {
			copy_value( otherValue );
		}

		public TitanLog_sequence__list_0_event__list_template( final TitanLog_sequence__list_0_event__list_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLog_sequence__list_0_event__list_template( final Optional<TitanLog_sequence__list_0_event__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list from an unbound optional field.");
			}
		}

		public TitanLog_sequence__list_0_event__list_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanLogEvent_template>();
		}

		private void copy_value(final TitanLog_sequence__list_0_event__list other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list with an unbound value.");
			}
			value_elements = new ArrayList<TitanLogEvent_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanLogEvent_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanLogEvent_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLog_sequence__list_0_event__list_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanLogEvent_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGetAt(elem_count).isBound()) {
						value_elements.add( new TitanLogEvent_template(other_value.constGetAt(elem_count)) );
					} else {
						value_elements.add( new TitanLogEvent_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLog_sequence__list_0_event__list_template temp = new TitanLog_sequence__list_0_event__list_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		// originally match
		public boolean match(final TitanLog_sequence__list_0_event__list other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final TitanLog_sequence__list_0_event__list other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
		}

		private boolean match_index(final TitanLog_sequence__list_0_event__list value_ptr, final int value_index, final TitanLog_sequence__list_0_event__list_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
				return match((TitanLog_sequence__list_0_event__list)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		//originally operator=
		public TitanLog_sequence__list_0_event__list_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_0_event__list_template assign( final TitanLog_sequence__list_0_event__list other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_0_event__list_template assign( final TitanLog_sequence__list_0_event__list_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLog_sequence__list_0_event__list_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
				return assign((TitanLog_sequence__list_0_event__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
		}

		@Override
		public TitanLog_sequence__list_0_event__list_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_event__list_template) {
				return assign((TitanLog_sequence__list_0_event__list_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list_template.");
		}

		public TitanLog_sequence__list_0_event__list_template assign( final Optional<TitanLog_sequence__list_0_event__list> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			return this;
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl.valueOf());
		}

		public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
		}

		public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl);
		}

		public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl);
		}

		public TitanLogEvent_template getAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: {0}.", index_value ) );
			}

			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				setSize(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			return value_elements.get(index_value);
		}

		public TitanLogEvent_template getAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}

			return getAt(index_value.getInt());
		}

		public TitanLogEvent_template constGetAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: {0}.", index_value ) );
			}

			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public TitanLogEvent_template constGetAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}

			return constGetAt(index_value.getInt());
		}

		private int get_length_for_concat(final AtomicBoolean is_any_value) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					if (templateSelection == template_sel.ANY_VALUE) {
						// ? => { * }
						is_any_value.set( true );
						return 1;
					}
					throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
				case RANGE_LENGTH_RESTRICTION:
					if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
						throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
					}
					// else fall through (range length restriction is allowed if the minimum
					// and maximum value are the same)
				case SINGLE_LENGTH_RESTRICTION:
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
				}
			default:
				throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
			}
		}

		private int get_length_for_concat(final TitanLog_sequence__list_0_event__list operand) {
			operand.mustBound("Operand of record of template concatenation is an unbound value.");
			return operand.valueElements.size();
		}


		private int get_length_for_concat(final template_sel operand) {
			if (operand == template_sel.ANY_VALUE) {
				// ? => { * }
				return 1;
			}
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}

		//TODO: simplify, just use value_elements.add()
		private void concat(final AtomicInteger pos, final TitanLog_sequence__list_0_event__list_template operand) {
			// all errors should have already been caught by the operand's
			// get_length_for_concat() call;
			// the result template (this) should already be set to SPECIFIC_VALUE and
			// single_value.value_elements should already be allocated
			switch (operand.templateSelection) {
			case SPECIFIC_VALUE:
				for (int i = 0; i < operand.value_elements.size(); ++i) {
					value_elements.set( pos.get() + i, new TitanLogEvent_template(operand.value_elements.get(i)) );
				}
				pos.addAndGet( operand.value_elements.size() );
				break;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (operand.length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					// ? => { * }
					value_elements.set( pos.get(), new TitanLogEvent_template( template_sel.ANY_OR_OMIT ) );
					pos.incrementAndGet();
					break;
				case RANGE_LENGTH_RESTRICTION:
				case SINGLE_LENGTH_RESTRICTION: {
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
					for (int i = 0; i < N; ++i) {
						value_elements.set( pos.get() + i, new TitanLogEvent_template( template_sel.ANY_VALUE ) );
					}
					pos.addAndGet( N );
					break; }
				}
			default:
				break;
			}
		}

		public void setSize(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			final template_sel old_selection = templateSelection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanLogEvent_template>();
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanLogEvent_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanLogEvent_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				final int oldSize = value_elements.size();
				for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
					value_elements.remove( new_size );
				}
			}
		}

		public TitanInteger sizeOf() {
			return sizeOf(true);
		}

		public TitanInteger lengthOf() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (templateSelection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.size()<1) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).getInt();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanLogEvent_template"));
		}

		public TitanInteger n_elem() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type TitanLog_sequence__list_0_event__list containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.");
		}

		private boolean matchv(final TitanLog_sequence__list_0_event__list other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).matchv(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.");
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).isValue()) {
					return false;
				}
			}
			return true;
		}

		public void setType(final template_sel template_type, final int list_length) {
			cleanUp();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new TitanLog_sequence__list_0_event__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			set_selection(template_type);
		}

		public TitanLog_sequence__list_0_event__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			return list_value.get(list_index);
		}

		public TitanLog_sequence__list_0_event__list_template get_list_item(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			if (list_index < 0) {
				throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index ({0}).", list_index ) );
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			return list_value.get( list_index );
		}

		public TitanLog_sequence__list_0_event__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_event__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final TitanLog_sequence__list_0_event__list match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog_sequence__list_0_event__list) {
				log_match((TitanLog_sequence__list_0_event__list)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}

		public void log_match(final TitanLog_sequence__list_0_event__list match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
				}
				value_elements = new ArrayList<TitanLogEvent_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanLogEvent_template temp2 = new TitanLogEvent_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_sequence__list_0_event__list_template temp2 = new TitanLog_sequence__list_0_event__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					setSize(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					getAt(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				setSize(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							getAt(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						getAt(current_index).set_param(param.get_elem(i));
						current_index++;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list");
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (templateSelection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++)
					value_elements.get(i).check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list" : name, false);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) return;
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list" : name));
		}
	}
	public static void TitanLog_sequence__list_0_event__list_encoder(final TitanLog_sequence__list_0_event__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_sequence__list_0_event__list_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_sequence__list_0_event__list_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list_0_event__list output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_sequence__list_0_event__list_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class LogEventType_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_actionEvent,  ALT_defaultEvent,  ALT_errorLog,  ALT_executorEvent,  ALT_functionEvent,  ALT_parallelEvent,  ALT_testcaseOp,  ALT_portEvent,  ALT_statistics,  ALT_timerEvent,  ALT_userLog,  ALT_verdictOp,  ALT_warningLog,  ALT_matchingEvent,  ALT_debugLog,  ALT_executionSummary,  ALT_unhandledEvent };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public LogEventType_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public LogEventType_choice(final LogEventType_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final LogEventType_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_actionEvent:
				field = new Strings((Strings)otherValue.field);
				break;
			case ALT_defaultEvent:
				field = new DefaultEvent((DefaultEvent)otherValue.field);
				break;
			case ALT_errorLog:
				field = new Categorized((Categorized)otherValue.field);
				break;
			case ALT_executorEvent:
				field = new ExecutorEvent((ExecutorEvent)otherValue.field);
				break;
			case ALT_functionEvent:
				field = new FunctionEvent((FunctionEvent)otherValue.field);
				break;
			case ALT_parallelEvent:
				field = new ParallelEvent((ParallelEvent)otherValue.field);
				break;
			case ALT_testcaseOp:
				field = new TestcaseEvent((TestcaseEvent)otherValue.field);
				break;
			case ALT_portEvent:
				field = new PortEvent((PortEvent)otherValue.field);
				break;
			case ALT_statistics:
				field = new StatisticsType((StatisticsType)otherValue.field);
				break;
			case ALT_timerEvent:
				field = new TimerEvent((TimerEvent)otherValue.field);
				break;
			case ALT_userLog:
				field = new Strings((Strings)otherValue.field);
				break;
			case ALT_verdictOp:
				field = new VerdictOp((VerdictOp)otherValue.field);
				break;
			case ALT_warningLog:
				field = new Categorized((Categorized)otherValue.field);
				break;
			case ALT_matchingEvent:
				field = new MatchingEvent((MatchingEvent)otherValue.field);
				break;
			case ALT_debugLog:
				field = new Categorized((Categorized)otherValue.field);
				break;
			case ALT_executionSummary:
				field = new ExecutionSummaryType((ExecutionSummaryType)otherValue.field);
				break;
			case ALT_unhandledEvent:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.LogEventType.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public LogEventType_choice assign( final LogEventType_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public LogEventType_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof LogEventType_choice) {
				return assign((LogEventType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_actionEvent:
				return field.isValue();
			case ALT_defaultEvent:
				return field.isValue();
			case ALT_errorLog:
				return field.isValue();
			case ALT_executorEvent:
				return field.isValue();
			case ALT_functionEvent:
				return field.isValue();
			case ALT_parallelEvent:
				return field.isValue();
			case ALT_testcaseOp:
				return field.isValue();
			case ALT_portEvent:
				return field.isValue();
			case ALT_statistics:
				return field.isValue();
			case ALT_timerEvent:
				return field.isValue();
			case ALT_userLog:
				return field.isValue();
			case ALT_verdictOp:
				return field.isValue();
			case ALT_warningLog:
				return field.isValue();
			case ALT_matchingEvent:
				return field.isValue();
			case ALT_debugLog:
				return field.isValue();
			case ALT_executionSummary:
				return field.isValue();
			case ALT_unhandledEvent:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final LogEventType_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.LogEventType.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.LogEventType.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_actionEvent:
				return ((Strings)field).operatorEquals((Strings)otherValue.field);
			case ALT_defaultEvent:
				return ((DefaultEvent)field).operatorEquals((DefaultEvent)otherValue.field);
			case ALT_errorLog:
				return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
			case ALT_executorEvent:
				return ((ExecutorEvent)field).operatorEquals((ExecutorEvent)otherValue.field);
			case ALT_functionEvent:
				return ((FunctionEvent)field).operatorEquals((FunctionEvent)otherValue.field);
			case ALT_parallelEvent:
				return ((ParallelEvent)field).operatorEquals((ParallelEvent)otherValue.field);
			case ALT_testcaseOp:
				return ((TestcaseEvent)field).operatorEquals((TestcaseEvent)otherValue.field);
			case ALT_portEvent:
				return ((PortEvent)field).operatorEquals((PortEvent)otherValue.field);
			case ALT_statistics:
				return ((StatisticsType)field).operatorEquals((StatisticsType)otherValue.field);
			case ALT_timerEvent:
				return ((TimerEvent)field).operatorEquals((TimerEvent)otherValue.field);
			case ALT_userLog:
				return ((Strings)field).operatorEquals((Strings)otherValue.field);
			case ALT_verdictOp:
				return ((VerdictOp)field).operatorEquals((VerdictOp)otherValue.field);
			case ALT_warningLog:
				return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
			case ALT_matchingEvent:
				return ((MatchingEvent)field).operatorEquals((MatchingEvent)otherValue.field);
			case ALT_debugLog:
				return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
			case ALT_executionSummary:
				return ((ExecutionSummaryType)field).operatorEquals((ExecutionSummaryType)otherValue.field);
			case ALT_unhandledEvent:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof LogEventType_choice) {
				return operatorEquals((LogEventType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final LogEventType_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public Strings getactionEvent() {
			if (union_selection != union_selection_type.ALT_actionEvent) {
				cleanUp();
				field = new Strings();
				union_selection = union_selection_type.ALT_actionEvent;
			}
			return (Strings)field;
		}

		public Strings constGetactionEvent() {
			if (union_selection != union_selection_type.ALT_actionEvent) {
				throw new TtcnError("Using non-selected field actionEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Strings)field;
		}

		public DefaultEvent getdefaultEvent() {
			if (union_selection != union_selection_type.ALT_defaultEvent) {
				cleanUp();
				field = new DefaultEvent();
				union_selection = union_selection_type.ALT_defaultEvent;
			}
			return (DefaultEvent)field;
		}

		public DefaultEvent constGetdefaultEvent() {
			if (union_selection != union_selection_type.ALT_defaultEvent) {
				throw new TtcnError("Using non-selected field defaultEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (DefaultEvent)field;
		}

		public Categorized geterrorLog() {
			if (union_selection != union_selection_type.ALT_errorLog) {
				cleanUp();
				field = new Categorized();
				union_selection = union_selection_type.ALT_errorLog;
			}
			return (Categorized)field;
		}

		public Categorized constGeterrorLog() {
			if (union_selection != union_selection_type.ALT_errorLog) {
				throw new TtcnError("Using non-selected field errorLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized)field;
		}

		public ExecutorEvent getexecutorEvent() {
			if (union_selection != union_selection_type.ALT_executorEvent) {
				cleanUp();
				field = new ExecutorEvent();
				union_selection = union_selection_type.ALT_executorEvent;
			}
			return (ExecutorEvent)field;
		}

		public ExecutorEvent constGetexecutorEvent() {
			if (union_selection != union_selection_type.ALT_executorEvent) {
				throw new TtcnError("Using non-selected field executorEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ExecutorEvent)field;
		}

		public FunctionEvent getfunctionEvent() {
			if (union_selection != union_selection_type.ALT_functionEvent) {
				cleanUp();
				field = new FunctionEvent();
				union_selection = union_selection_type.ALT_functionEvent;
			}
			return (FunctionEvent)field;
		}

		public FunctionEvent constGetfunctionEvent() {
			if (union_selection != union_selection_type.ALT_functionEvent) {
				throw new TtcnError("Using non-selected field functionEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (FunctionEvent)field;
		}

		public ParallelEvent getparallelEvent() {
			if (union_selection != union_selection_type.ALT_parallelEvent) {
				cleanUp();
				field = new ParallelEvent();
				union_selection = union_selection_type.ALT_parallelEvent;
			}
			return (ParallelEvent)field;
		}

		public ParallelEvent constGetparallelEvent() {
			if (union_selection != union_selection_type.ALT_parallelEvent) {
				throw new TtcnError("Using non-selected field parallelEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ParallelEvent)field;
		}

		public TestcaseEvent gettestcaseOp() {
			if (union_selection != union_selection_type.ALT_testcaseOp) {
				cleanUp();
				field = new TestcaseEvent();
				union_selection = union_selection_type.ALT_testcaseOp;
			}
			return (TestcaseEvent)field;
		}

		public TestcaseEvent constGettestcaseOp() {
			if (union_selection != union_selection_type.ALT_testcaseOp) {
				throw new TtcnError("Using non-selected field testcaseOp in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TestcaseEvent)field;
		}

		public PortEvent getportEvent() {
			if (union_selection != union_selection_type.ALT_portEvent) {
				cleanUp();
				field = new PortEvent();
				union_selection = union_selection_type.ALT_portEvent;
			}
			return (PortEvent)field;
		}

		public PortEvent constGetportEvent() {
			if (union_selection != union_selection_type.ALT_portEvent) {
				throw new TtcnError("Using non-selected field portEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (PortEvent)field;
		}

		public StatisticsType getstatistics() {
			if (union_selection != union_selection_type.ALT_statistics) {
				cleanUp();
				field = new StatisticsType();
				union_selection = union_selection_type.ALT_statistics;
			}
			return (StatisticsType)field;
		}

		public StatisticsType constGetstatistics() {
			if (union_selection != union_selection_type.ALT_statistics) {
				throw new TtcnError("Using non-selected field statistics in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (StatisticsType)field;
		}

		public TimerEvent gettimerEvent() {
			if (union_selection != union_selection_type.ALT_timerEvent) {
				cleanUp();
				field = new TimerEvent();
				union_selection = union_selection_type.ALT_timerEvent;
			}
			return (TimerEvent)field;
		}

		public TimerEvent constGettimerEvent() {
			if (union_selection != union_selection_type.ALT_timerEvent) {
				throw new TtcnError("Using non-selected field timerEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TimerEvent)field;
		}

		public Strings getuserLog() {
			if (union_selection != union_selection_type.ALT_userLog) {
				cleanUp();
				field = new Strings();
				union_selection = union_selection_type.ALT_userLog;
			}
			return (Strings)field;
		}

		public Strings constGetuserLog() {
			if (union_selection != union_selection_type.ALT_userLog) {
				throw new TtcnError("Using non-selected field userLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Strings)field;
		}

		public VerdictOp getverdictOp() {
			if (union_selection != union_selection_type.ALT_verdictOp) {
				cleanUp();
				field = new VerdictOp();
				union_selection = union_selection_type.ALT_verdictOp;
			}
			return (VerdictOp)field;
		}

		public VerdictOp constGetverdictOp() {
			if (union_selection != union_selection_type.ALT_verdictOp) {
				throw new TtcnError("Using non-selected field verdictOp in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (VerdictOp)field;
		}

		public Categorized getwarningLog() {
			if (union_selection != union_selection_type.ALT_warningLog) {
				cleanUp();
				field = new Categorized();
				union_selection = union_selection_type.ALT_warningLog;
			}
			return (Categorized)field;
		}

		public Categorized constGetwarningLog() {
			if (union_selection != union_selection_type.ALT_warningLog) {
				throw new TtcnError("Using non-selected field warningLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized)field;
		}

		public MatchingEvent getmatchingEvent() {
			if (union_selection != union_selection_type.ALT_matchingEvent) {
				cleanUp();
				field = new MatchingEvent();
				union_selection = union_selection_type.ALT_matchingEvent;
			}
			return (MatchingEvent)field;
		}

		public MatchingEvent constGetmatchingEvent() {
			if (union_selection != union_selection_type.ALT_matchingEvent) {
				throw new TtcnError("Using non-selected field matchingEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (MatchingEvent)field;
		}

		public Categorized getdebugLog() {
			if (union_selection != union_selection_type.ALT_debugLog) {
				cleanUp();
				field = new Categorized();
				union_selection = union_selection_type.ALT_debugLog;
			}
			return (Categorized)field;
		}

		public Categorized constGetdebugLog() {
			if (union_selection != union_selection_type.ALT_debugLog) {
				throw new TtcnError("Using non-selected field debugLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized)field;
		}

		public ExecutionSummaryType getexecutionSummary() {
			if (union_selection != union_selection_type.ALT_executionSummary) {
				cleanUp();
				field = new ExecutionSummaryType();
				union_selection = union_selection_type.ALT_executionSummary;
			}
			return (ExecutionSummaryType)field;
		}

		public ExecutionSummaryType constGetexecutionSummary() {
			if (union_selection != union_selection_type.ALT_executionSummary) {
				throw new TtcnError("Using non-selected field executionSummary in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ExecutionSummaryType)field;
		}

		public TitanCharString getunhandledEvent() {
			if (union_selection != union_selection_type.ALT_unhandledEvent) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_unhandledEvent;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetunhandledEvent() {
			if (union_selection != union_selection_type.ALT_unhandledEvent) {
				throw new TtcnError("Using non-selected field unhandledEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TitanCharString)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_actionEvent:
				TTCN_Logger.log_event_str("{ actionEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_defaultEvent:
				TTCN_Logger.log_event_str("{ defaultEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_errorLog:
				TTCN_Logger.log_event_str("{ errorLog := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_executorEvent:
				TTCN_Logger.log_event_str("{ executorEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_functionEvent:
				TTCN_Logger.log_event_str("{ functionEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_parallelEvent:
				TTCN_Logger.log_event_str("{ parallelEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_testcaseOp:
				TTCN_Logger.log_event_str("{ testcaseOp := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_portEvent:
				TTCN_Logger.log_event_str("{ portEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_statistics:
				TTCN_Logger.log_event_str("{ statistics := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_timerEvent:
				TTCN_Logger.log_event_str("{ timerEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_userLog:
				TTCN_Logger.log_event_str("{ userLog := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_verdictOp:
				TTCN_Logger.log_event_str("{ verdictOp := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_warningLog:
				TTCN_Logger.log_event_str("{ warningLog := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_matchingEvent:
				TTCN_Logger.log_event_str("{ matchingEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_debugLog:
				TTCN_Logger.log_event_str("{ debugLog := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_executionSummary:
				TTCN_Logger.log_event_str("{ executionSummary := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_unhandledEvent:
				TTCN_Logger.log_event_str("{ unhandledEvent := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("actionEvent".equals(last_name)) {
				getactionEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("defaultEvent".equals(last_name)) {
				getdefaultEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("errorLog".equals(last_name)) {
				geterrorLog().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("executorEvent".equals(last_name)) {
				getexecutorEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("functionEvent".equals(last_name)) {
				getfunctionEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("parallelEvent".equals(last_name)) {
				getparallelEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("testcaseOp".equals(last_name)) {
				gettestcaseOp().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("portEvent".equals(last_name)) {
				getportEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("statistics".equals(last_name)) {
				getstatistics().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("timerEvent".equals(last_name)) {
				gettimerEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("userLog".equals(last_name)) {
				getuserLog().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("verdictOp".equals(last_name)) {
				getverdictOp().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("warningLog".equals(last_name)) {
				getwarningLog().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("matchingEvent".equals(last_name)) {
				getmatchingEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("debugLog".equals(last_name)) {
				getdebugLog().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("executionSummary".equals(last_name)) {
				getexecutionSummary().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("unhandledEvent".equals(last_name)) {
				getunhandledEvent().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.LogEventType.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_actionEvent:
			case ALT_defaultEvent:
			case ALT_errorLog:
			case ALT_executorEvent:
			case ALT_functionEvent:
			case ALT_parallelEvent:
			case ALT_testcaseOp:
			case ALT_portEvent:
			case ALT_statistics:
			case ALT_timerEvent:
			case ALT_userLog:
			case ALT_verdictOp:
			case ALT_warningLog:
			case ALT_matchingEvent:
			case ALT_debugLog:
			case ALT_executionSummary:
			case ALT_unhandledEvent:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_actionEvent:
				text_buf.push_int(0);
				break;
			case ALT_defaultEvent:
				text_buf.push_int(1);
				break;
			case ALT_errorLog:
				text_buf.push_int(2);
				break;
			case ALT_executorEvent:
				text_buf.push_int(3);
				break;
			case ALT_functionEvent:
				text_buf.push_int(4);
				break;
			case ALT_parallelEvent:
				text_buf.push_int(5);
				break;
			case ALT_testcaseOp:
				text_buf.push_int(6);
				break;
			case ALT_portEvent:
				text_buf.push_int(7);
				break;
			case ALT_statistics:
				text_buf.push_int(8);
				break;
			case ALT_timerEvent:
				text_buf.push_int(9);
				break;
			case ALT_userLog:
				text_buf.push_int(10);
				break;
			case ALT_verdictOp:
				text_buf.push_int(11);
				break;
			case ALT_warningLog:
				text_buf.push_int(12);
				break;
			case ALT_matchingEvent:
				text_buf.push_int(13);
				break;
			case ALT_debugLog:
				text_buf.push_int(14);
				break;
			case ALT_executionSummary:
				text_buf.push_int(15);
				break;
			case ALT_unhandledEvent:
				text_buf.push_int(16);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.LogEventType.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getactionEvent().decode_text(text_buf);
				break;
			case 1:
				getdefaultEvent().decode_text(text_buf);
				break;
			case 2:
				geterrorLog().decode_text(text_buf);
				break;
			case 3:
				getexecutorEvent().decode_text(text_buf);
				break;
			case 4:
				getfunctionEvent().decode_text(text_buf);
				break;
			case 5:
				getparallelEvent().decode_text(text_buf);
				break;
			case 6:
				gettestcaseOp().decode_text(text_buf);
				break;
			case 7:
				getportEvent().decode_text(text_buf);
				break;
			case 8:
				getstatistics().decode_text(text_buf);
				break;
			case 9:
				gettimerEvent().decode_text(text_buf);
				break;
			case 10:
				getuserLog().decode_text(text_buf);
				break;
			case 11:
				getverdictOp().decode_text(text_buf);
				break;
			case 12:
				getwarningLog().decode_text(text_buf);
				break;
			case 13:
				getmatchingEvent().decode_text(text_buf);
				break;
			case 14:
				getdebugLog().decode_text(text_buf);
				break;
			case 15:
				getexecutionSummary().decode_text(text_buf);
				break;
			case 16:
				getunhandledEvent().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.LogEventType.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class LogEventType_choice_template extends Base_Template {
		//if single value which value?
		private LogEventType_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<LogEventType_choice_template> value_list;

		private void copy_value(final LogEventType_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_actionEvent:
				single_value = new Strings_template(other_value.constGetactionEvent());
				break;
			case ALT_defaultEvent:
				single_value = new DefaultEvent_template(other_value.constGetdefaultEvent());
				break;
			case ALT_errorLog:
				single_value = new Categorized_template(other_value.constGeterrorLog());
				break;
			case ALT_executorEvent:
				single_value = new ExecutorEvent_template(other_value.constGetexecutorEvent());
				break;
			case ALT_functionEvent:
				single_value = new FunctionEvent_template(other_value.constGetfunctionEvent());
				break;
			case ALT_parallelEvent:
				single_value = new ParallelEvent_template(other_value.constGetparallelEvent());
				break;
			case ALT_testcaseOp:
				single_value = new TestcaseEvent_template(other_value.constGettestcaseOp());
				break;
			case ALT_portEvent:
				single_value = new PortEvent_template(other_value.constGetportEvent());
				break;
			case ALT_statistics:
				single_value = new StatisticsType_template(other_value.constGetstatistics());
				break;
			case ALT_timerEvent:
				single_value = new TimerEvent_template(other_value.constGettimerEvent());
				break;
			case ALT_userLog:
				single_value = new Strings_template(other_value.constGetuserLog());
				break;
			case ALT_verdictOp:
				single_value = new VerdictOp_template(other_value.constGetverdictOp());
				break;
			case ALT_warningLog:
				single_value = new Categorized_template(other_value.constGetwarningLog());
				break;
			case ALT_matchingEvent:
				single_value = new MatchingEvent_template(other_value.constGetmatchingEvent());
				break;
			case ALT_debugLog:
				single_value = new Categorized_template(other_value.constGetdebugLog());
				break;
			case ALT_executionSummary:
				single_value = new ExecutionSummaryType_template(other_value.constGetexecutionSummary());
				break;
			case ALT_unhandledEvent:
				single_value = new TitanCharString_template(other_value.constGetunhandledEvent());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.LogEventType.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final LogEventType_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_actionEvent:
					single_value = new Strings_template(other_value.constGetactionEvent());
					break;
				case ALT_defaultEvent:
					single_value = new DefaultEvent_template(other_value.constGetdefaultEvent());
					break;
				case ALT_errorLog:
					single_value = new Categorized_template(other_value.constGeterrorLog());
					break;
				case ALT_executorEvent:
					single_value = new ExecutorEvent_template(other_value.constGetexecutorEvent());
					break;
				case ALT_functionEvent:
					single_value = new FunctionEvent_template(other_value.constGetfunctionEvent());
					break;
				case ALT_parallelEvent:
					single_value = new ParallelEvent_template(other_value.constGetparallelEvent());
					break;
				case ALT_testcaseOp:
					single_value = new TestcaseEvent_template(other_value.constGettestcaseOp());
					break;
				case ALT_portEvent:
					single_value = new PortEvent_template(other_value.constGetportEvent());
					break;
				case ALT_statistics:
					single_value = new StatisticsType_template(other_value.constGetstatistics());
					break;
				case ALT_timerEvent:
					single_value = new TimerEvent_template(other_value.constGettimerEvent());
					break;
				case ALT_userLog:
					single_value = new Strings_template(other_value.constGetuserLog());
					break;
				case ALT_verdictOp:
					single_value = new VerdictOp_template(other_value.constGetverdictOp());
					break;
				case ALT_warningLog:
					single_value = new Categorized_template(other_value.constGetwarningLog());
					break;
				case ALT_matchingEvent:
					single_value = new MatchingEvent_template(other_value.constGetmatchingEvent());
					break;
				case ALT_debugLog:
					single_value = new Categorized_template(other_value.constGetdebugLog());
					break;
				case ALT_executionSummary:
					single_value = new ExecutionSummaryType_template(other_value.constGetexecutionSummary());
					break;
				case ALT_unhandledEvent:
					single_value = new TitanCharString_template(other_value.constGetunhandledEvent());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.LogEventType.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<LogEventType_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final LogEventType_choice_template temp = new LogEventType_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			set_selection(other_value);
		}

		public LogEventType_choice_template() {
			// do nothing
		}
		public LogEventType_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public LogEventType_choice_template(final LogEventType_choice other_value) {
			copy_value(other_value);
		}
		public LogEventType_choice_template(final LogEventType_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_actionEvent:
					((Strings_template)single_value).cleanUp();
					break;
				case ALT_defaultEvent:
					((DefaultEvent_template)single_value).cleanUp();
					break;
				case ALT_errorLog:
					((Categorized_template)single_value).cleanUp();
					break;
				case ALT_executorEvent:
					((ExecutorEvent_template)single_value).cleanUp();
					break;
				case ALT_functionEvent:
					((FunctionEvent_template)single_value).cleanUp();
					break;
				case ALT_parallelEvent:
					((ParallelEvent_template)single_value).cleanUp();
					break;
				case ALT_testcaseOp:
					((TestcaseEvent_template)single_value).cleanUp();
					break;
				case ALT_portEvent:
					((PortEvent_template)single_value).cleanUp();
					break;
				case ALT_statistics:
					((StatisticsType_template)single_value).cleanUp();
					break;
				case ALT_timerEvent:
					((TimerEvent_template)single_value).cleanUp();
					break;
				case ALT_userLog:
					((Strings_template)single_value).cleanUp();
					break;
				case ALT_verdictOp:
					((VerdictOp_template)single_value).cleanUp();
					break;
				case ALT_warningLog:
					((Categorized_template)single_value).cleanUp();
					break;
				case ALT_matchingEvent:
					((MatchingEvent_template)single_value).cleanUp();
					break;
				case ALT_debugLog:
					((Categorized_template)single_value).cleanUp();
					break;
				case ALT_executionSummary:
					((ExecutionSummaryType_template)single_value).cleanUp();
					break;
				case ALT_unhandledEvent:
					((TitanCharString_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public LogEventType_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public LogEventType_choice_template assign( final LogEventType_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public LogEventType_choice_template assign( final LogEventType_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public LogEventType_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof LogEventType_choice) {
				return assign((LogEventType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to LogEventType_choice.");
		}

		@Override
		public LogEventType_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof LogEventType_choice_template) {
				return assign((LogEventType_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to LogEventType_choice_template.");
		}

		// originally match
		public boolean match(final LogEventType_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final LogEventType_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final LogEventType_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_actionEvent:
					return ((Strings_template)single_value).match(other_value.getactionEvent(), legacy);
				case ALT_defaultEvent:
					return ((DefaultEvent_template)single_value).match(other_value.getdefaultEvent(), legacy);
				case ALT_errorLog:
					return ((Categorized_template)single_value).match(other_value.geterrorLog(), legacy);
				case ALT_executorEvent:
					return ((ExecutorEvent_template)single_value).match(other_value.getexecutorEvent(), legacy);
				case ALT_functionEvent:
					return ((FunctionEvent_template)single_value).match(other_value.getfunctionEvent(), legacy);
				case ALT_parallelEvent:
					return ((ParallelEvent_template)single_value).match(other_value.getparallelEvent(), legacy);
				case ALT_testcaseOp:
					return ((TestcaseEvent_template)single_value).match(other_value.gettestcaseOp(), legacy);
				case ALT_portEvent:
					return ((PortEvent_template)single_value).match(other_value.getportEvent(), legacy);
				case ALT_statistics:
					return ((StatisticsType_template)single_value).match(other_value.getstatistics(), legacy);
				case ALT_timerEvent:
					return ((TimerEvent_template)single_value).match(other_value.gettimerEvent(), legacy);
				case ALT_userLog:
					return ((Strings_template)single_value).match(other_value.getuserLog(), legacy);
				case ALT_verdictOp:
					return ((VerdictOp_template)single_value).match(other_value.getverdictOp(), legacy);
				case ALT_warningLog:
					return ((Categorized_template)single_value).match(other_value.getwarningLog(), legacy);
				case ALT_matchingEvent:
					return ((MatchingEvent_template)single_value).match(other_value.getmatchingEvent(), legacy);
				case ALT_debugLog:
					return ((Categorized_template)single_value).match(other_value.getdebugLog(), legacy);
				case ALT_executionSummary:
					return ((ExecutionSummaryType_template)single_value).match(other_value.getexecutionSummary(), legacy);
				case ALT_unhandledEvent:
					return ((TitanCharString_template)single_value).match(other_value.getunhandledEvent(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.LogEventType.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof LogEventType_choice) {
				return match((LogEventType_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type LogEventType_choice.");
		}
		public boolean isChosen(final LogEventType_choice.union_selection_type checked_selection) {
			if(checked_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.LogEventType.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.LogEventType.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_actionEvent:
				return ((Strings_template)single_value).isValue();
			case ALT_defaultEvent:
				return ((DefaultEvent_template)single_value).isValue();
			case ALT_errorLog:
				return ((Categorized_template)single_value).isValue();
			case ALT_executorEvent:
				return ((ExecutorEvent_template)single_value).isValue();
			case ALT_functionEvent:
				return ((FunctionEvent_template)single_value).isValue();
			case ALT_parallelEvent:
				return ((ParallelEvent_template)single_value).isValue();
			case ALT_testcaseOp:
				return ((TestcaseEvent_template)single_value).isValue();
			case ALT_portEvent:
				return ((PortEvent_template)single_value).isValue();
			case ALT_statistics:
				return ((StatisticsType_template)single_value).isValue();
			case ALT_timerEvent:
				return ((TimerEvent_template)single_value).isValue();
			case ALT_userLog:
				return ((Strings_template)single_value).isValue();
			case ALT_verdictOp:
				return ((VerdictOp_template)single_value).isValue();
			case ALT_warningLog:
				return ((Categorized_template)single_value).isValue();
			case ALT_matchingEvent:
				return ((MatchingEvent_template)single_value).isValue();
			case ALT_debugLog:
				return ((Categorized_template)single_value).isValue();
			case ALT_executionSummary:
				return ((ExecutionSummaryType_template)single_value).isValue();
			case ALT_unhandledEvent:
				return ((TitanCharString_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
		}

		public LogEventType_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			final LogEventType_choice ret_val = new LogEventType_choice();
			switch (single_value_union_selection) {
			case ALT_actionEvent:
				ret_val.getactionEvent().assign(((Strings_template)single_value).valueOf());
				break;
			case ALT_defaultEvent:
				ret_val.getdefaultEvent().assign(((DefaultEvent_template)single_value).valueOf());
				break;
			case ALT_errorLog:
				ret_val.geterrorLog().assign(((Categorized_template)single_value).valueOf());
				break;
			case ALT_executorEvent:
				ret_val.getexecutorEvent().assign(((ExecutorEvent_template)single_value).valueOf());
				break;
			case ALT_functionEvent:
				ret_val.getfunctionEvent().assign(((FunctionEvent_template)single_value).valueOf());
				break;
			case ALT_parallelEvent:
				ret_val.getparallelEvent().assign(((ParallelEvent_template)single_value).valueOf());
				break;
			case ALT_testcaseOp:
				ret_val.gettestcaseOp().assign(((TestcaseEvent_template)single_value).valueOf());
				break;
			case ALT_portEvent:
				ret_val.getportEvent().assign(((PortEvent_template)single_value).valueOf());
				break;
			case ALT_statistics:
				ret_val.getstatistics().assign(((StatisticsType_template)single_value).valueOf());
				break;
			case ALT_timerEvent:
				ret_val.gettimerEvent().assign(((TimerEvent_template)single_value).valueOf());
				break;
			case ALT_userLog:
				ret_val.getuserLog().assign(((Strings_template)single_value).valueOf());
				break;
			case ALT_verdictOp:
				ret_val.getverdictOp().assign(((VerdictOp_template)single_value).valueOf());
				break;
			case ALT_warningLog:
				ret_val.getwarningLog().assign(((Categorized_template)single_value).valueOf());
				break;
			case ALT_matchingEvent:
				ret_val.getmatchingEvent().assign(((MatchingEvent_template)single_value).valueOf());
				break;
			case ALT_debugLog:
				ret_val.getdebugLog().assign(((Categorized_template)single_value).valueOf());
				break;
			case ALT_executionSummary:
				ret_val.getexecutionSummary().assign(((ExecutionSummaryType_template)single_value).valueOf());
				break;
			case ALT_unhandledEvent:
				ret_val.getunhandledEvent().assign(((TitanCharString_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<LogEventType_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new LogEventType_choice_template());
			}
		}

		public LogEventType_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public Strings_template getactionEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_actionEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Strings_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Strings_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_actionEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Strings_template)single_value;
		}

		public Strings_template constGetactionEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field actionEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_actionEvent) {
				throw new TtcnError("Accessing non-selected field actionEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Strings_template)single_value;
		}

		public DefaultEvent_template getdefaultEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_defaultEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new DefaultEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new DefaultEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_defaultEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (DefaultEvent_template)single_value;
		}

		public DefaultEvent_template constGetdefaultEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field defaultEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_defaultEvent) {
				throw new TtcnError("Accessing non-selected field defaultEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (DefaultEvent_template)single_value;
		}

		public Categorized_template geterrorLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_errorLog) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Categorized_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Categorized_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_errorLog;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Categorized_template)single_value;
		}

		public Categorized_template constGeterrorLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field errorLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_errorLog) {
				throw new TtcnError("Accessing non-selected field errorLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized_template)single_value;
		}

		public ExecutorEvent_template getexecutorEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_executorEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutorEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutorEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_executorEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutorEvent_template)single_value;
		}

		public ExecutorEvent_template constGetexecutorEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executorEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_executorEvent) {
				throw new TtcnError("Accessing non-selected field executorEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ExecutorEvent_template)single_value;
		}

		public FunctionEvent_template getfunctionEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_functionEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new FunctionEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new FunctionEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_functionEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (FunctionEvent_template)single_value;
		}

		public FunctionEvent_template constGetfunctionEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field functionEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_functionEvent) {
				throw new TtcnError("Accessing non-selected field functionEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (FunctionEvent_template)single_value;
		}

		public ParallelEvent_template getparallelEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_parallelEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ParallelEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ParallelEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_parallelEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ParallelEvent_template)single_value;
		}

		public ParallelEvent_template constGetparallelEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parallelEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_parallelEvent) {
				throw new TtcnError("Accessing non-selected field parallelEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ParallelEvent_template)single_value;
		}

		public TestcaseEvent_template gettestcaseOp() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_testcaseOp) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TestcaseEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TestcaseEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_testcaseOp;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TestcaseEvent_template)single_value;
		}

		public TestcaseEvent_template constGettestcaseOp() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field testcaseOp in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_testcaseOp) {
				throw new TtcnError("Accessing non-selected field testcaseOp in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TestcaseEvent_template)single_value;
		}

		public PortEvent_template getportEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_portEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new PortEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new PortEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_portEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (PortEvent_template)single_value;
		}

		public PortEvent_template constGetportEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field portEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_portEvent) {
				throw new TtcnError("Accessing non-selected field portEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (PortEvent_template)single_value;
		}

		public StatisticsType_template getstatistics() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_statistics) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new StatisticsType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new StatisticsType_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_statistics;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (StatisticsType_template)single_value;
		}

		public StatisticsType_template constGetstatistics() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field statistics in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_statistics) {
				throw new TtcnError("Accessing non-selected field statistics in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (StatisticsType_template)single_value;
		}

		public TimerEvent_template gettimerEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_timerEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_timerEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerEvent_template)single_value;
		}

		public TimerEvent_template constGettimerEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field timerEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_timerEvent) {
				throw new TtcnError("Accessing non-selected field timerEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TimerEvent_template)single_value;
		}

		public Strings_template getuserLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_userLog) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Strings_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Strings_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_userLog;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Strings_template)single_value;
		}

		public Strings_template constGetuserLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field userLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_userLog) {
				throw new TtcnError("Accessing non-selected field userLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Strings_template)single_value;
		}

		public VerdictOp_template getverdictOp() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_verdictOp) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new VerdictOp_template(template_sel.ANY_VALUE);
				} else {
					single_value = new VerdictOp_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_verdictOp;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (VerdictOp_template)single_value;
		}

		public VerdictOp_template constGetverdictOp() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field verdictOp in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_verdictOp) {
				throw new TtcnError("Accessing non-selected field verdictOp in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (VerdictOp_template)single_value;
		}

		public Categorized_template getwarningLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_warningLog) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Categorized_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Categorized_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_warningLog;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Categorized_template)single_value;
		}

		public Categorized_template constGetwarningLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field warningLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_warningLog) {
				throw new TtcnError("Accessing non-selected field warningLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized_template)single_value;
		}

		public MatchingEvent_template getmatchingEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_matchingEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingEvent_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingEvent_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_matchingEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingEvent_template)single_value;
		}

		public MatchingEvent_template constGetmatchingEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_matchingEvent) {
				throw new TtcnError("Accessing non-selected field matchingEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (MatchingEvent_template)single_value;
		}

		public Categorized_template getdebugLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_debugLog) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Categorized_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Categorized_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_debugLog;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Categorized_template)single_value;
		}

		public Categorized_template constGetdebugLog() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field debugLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_debugLog) {
				throw new TtcnError("Accessing non-selected field debugLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (Categorized_template)single_value;
		}

		public ExecutionSummaryType_template getexecutionSummary() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_executionSummary) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ExecutionSummaryType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ExecutionSummaryType_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_executionSummary;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ExecutionSummaryType_template)single_value;
		}

		public ExecutionSummaryType_template constGetexecutionSummary() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field executionSummary in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_executionSummary) {
				throw new TtcnError("Accessing non-selected field executionSummary in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (ExecutionSummaryType_template)single_value;
		}

		public TitanCharString_template getunhandledEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_unhandledEvent) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = LogEventType_choice.union_selection_type.ALT_unhandledEvent;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetunhandledEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field unhandledEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_unhandledEvent) {
				throw new TtcnError("Accessing non-selected field unhandledEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LogEventType_choice) {
				log_match((LogEventType_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
		}

		public void log_match(final LogEventType_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_actionEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".actionEvent");
						single_value.log_match(match_value.getactionEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ actionEvent := ");
						single_value.log_match(match_value.getactionEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_defaultEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".defaultEvent");
						single_value.log_match(match_value.getdefaultEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ defaultEvent := ");
						single_value.log_match(match_value.getdefaultEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_errorLog:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".errorLog");
						single_value.log_match(match_value.geterrorLog(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ errorLog := ");
						single_value.log_match(match_value.geterrorLog(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_executorEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executorEvent");
						single_value.log_match(match_value.getexecutorEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executorEvent := ");
						single_value.log_match(match_value.getexecutorEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_functionEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".functionEvent");
						single_value.log_match(match_value.getfunctionEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ functionEvent := ");
						single_value.log_match(match_value.getfunctionEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_parallelEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".parallelEvent");
						single_value.log_match(match_value.getparallelEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ parallelEvent := ");
						single_value.log_match(match_value.getparallelEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_testcaseOp:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".testcaseOp");
						single_value.log_match(match_value.gettestcaseOp(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ testcaseOp := ");
						single_value.log_match(match_value.gettestcaseOp(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_portEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".portEvent");
						single_value.log_match(match_value.getportEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ portEvent := ");
						single_value.log_match(match_value.getportEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_statistics:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".statistics");
						single_value.log_match(match_value.getstatistics(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ statistics := ");
						single_value.log_match(match_value.getstatistics(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_timerEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".timerEvent");
						single_value.log_match(match_value.gettimerEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ timerEvent := ");
						single_value.log_match(match_value.gettimerEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_userLog:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".userLog");
						single_value.log_match(match_value.getuserLog(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ userLog := ");
						single_value.log_match(match_value.getuserLog(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_verdictOp:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".verdictOp");
						single_value.log_match(match_value.getverdictOp(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ verdictOp := ");
						single_value.log_match(match_value.getverdictOp(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_warningLog:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".warningLog");
						single_value.log_match(match_value.getwarningLog(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ warningLog := ");
						single_value.log_match(match_value.getwarningLog(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_matchingEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingEvent");
						single_value.log_match(match_value.getmatchingEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingEvent := ");
						single_value.log_match(match_value.getmatchingEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_debugLog:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".debugLog");
						single_value.log_match(match_value.getdebugLog(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ debugLog := ");
						single_value.log_match(match_value.getdebugLog(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_executionSummary:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".executionSummary");
						single_value.log_match(match_value.getexecutionSummary(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ executionSummary := ");
						single_value.log_match(match_value.getexecutionSummary(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_unhandledEvent:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".unhandledEvent");
						single_value.log_match(match_value.getunhandledEvent(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ unhandledEvent := ");
						single_value.log_match(match_value.getunhandledEvent(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.LogEventType.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new Strings_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new DefaultEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new Categorized_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new ExecutorEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new FunctionEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new ParallelEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new TestcaseEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 7:
					single_value = new PortEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 8:
					single_value = new StatisticsType_template();
					single_value.decode_text(text_buf);
					break;
				case 9:
					single_value = new TimerEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 10:
					single_value = new Strings_template();
					single_value.decode_text(text_buf);
					break;
				case 11:
					single_value = new VerdictOp_template();
					single_value.decode_text(text_buf);
					break;
				case 12:
					single_value = new Categorized_template();
					single_value.decode_text(text_buf);
					break;
				case 13:
					single_value = new MatchingEvent_template();
					single_value.decode_text(text_buf);
					break;
				case 14:
					single_value = new Categorized_template();
					single_value.decode_text(text_buf);
					break;
				case 15:
					single_value = new ExecutionSummaryType_template();
					single_value.decode_text(text_buf);
					break;
				case 16:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<LogEventType_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final LogEventType_choice_template temp2 = new LogEventType_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.LogEventType.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.LogEventType.choice");
				}
				if("actionEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("defaultEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("errorLog".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("executorEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("functionEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("parallelEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("testcaseOp".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("portEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("statistics".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("timerEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("userLog".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("verdictOp".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("warningLog".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("matchingEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("debugLog".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("executionSummary".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("unhandledEvent".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.LogEventType.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("actionEvent".equals(last_name)) {
					getactionEvent().set_param(mp_last);
					break;
				}
				if("defaultEvent".equals(last_name)) {
					getdefaultEvent().set_param(mp_last);
					break;
				}
				if("errorLog".equals(last_name)) {
					geterrorLog().set_param(mp_last);
					break;
				}
				if("executorEvent".equals(last_name)) {
					getexecutorEvent().set_param(mp_last);
					break;
				}
				if("functionEvent".equals(last_name)) {
					getfunctionEvent().set_param(mp_last);
					break;
				}
				if("parallelEvent".equals(last_name)) {
					getparallelEvent().set_param(mp_last);
					break;
				}
				if("testcaseOp".equals(last_name)) {
					gettestcaseOp().set_param(mp_last);
					break;
				}
				if("portEvent".equals(last_name)) {
					getportEvent().set_param(mp_last);
					break;
				}
				if("statistics".equals(last_name)) {
					getstatistics().set_param(mp_last);
					break;
				}
				if("timerEvent".equals(last_name)) {
					gettimerEvent().set_param(mp_last);
					break;
				}
				if("userLog".equals(last_name)) {
					getuserLog().set_param(mp_last);
					break;
				}
				if("verdictOp".equals(last_name)) {
					getverdictOp().set_param(mp_last);
					break;
				}
				if("warningLog".equals(last_name)) {
					getwarningLog().set_param(mp_last);
					break;
				}
				if("matchingEvent".equals(last_name)) {
					getmatchingEvent().set_param(mp_last);
					break;
				}
				if("debugLog".equals(last_name)) {
					getdebugLog().set_param(mp_last);
					break;
				}
				if("executionSummary".equals(last_name)) {
					getexecutionSummary().set_param(mp_last);
					break;
				}
				if("unhandledEvent".equals(last_name)) {
					getunhandledEvent().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.LogEventType.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.LogEventType.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_actionEvent:
					((Strings_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_defaultEvent:
					((DefaultEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_errorLog:
					((Categorized_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_executorEvent:
					((ExecutorEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_functionEvent:
					((FunctionEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_parallelEvent:
					((ParallelEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_testcaseOp:
					((TestcaseEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_portEvent:
					((PortEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_statistics:
					((StatisticsType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_timerEvent:
					((TimerEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_userLog:
					((Strings_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_verdictOp:
					((VerdictOp_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_warningLog:
					((Categorized_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_matchingEvent:
					((MatchingEvent_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_debugLog:
					((Categorized_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_executionSummary:
					((ExecutionSummaryType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				case ALT_unhandledEvent:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.LogEventType.choice" : name));
		}
	}
	public static void LogEventType_choice_encoder(final LogEventType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_decoder( final TitanOctetString input_stream, final LogEventType_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingDoneType_type___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingDoneType_type___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingDoneType_type___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingDoneType_type___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_ptc__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_ptc__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_ptc__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_ptc__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class DefaultEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_defaultopActivate,  ALT_defaultopDeactivate,  ALT_defaultopExit };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public DefaultEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public DefaultEvent_choice(final DefaultEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final DefaultEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_defaultopActivate:
				field = new DefaultOp((DefaultOp)otherValue.field);
				break;
			case ALT_defaultopDeactivate:
				field = new DefaultOp((DefaultOp)otherValue.field);
				break;
			case ALT_defaultopExit:
				field = new DefaultOp((DefaultOp)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.DefaultEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public DefaultEvent_choice assign( final DefaultEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public DefaultEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof DefaultEvent_choice) {
				return assign((DefaultEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_defaultopActivate:
				return field.isValue();
			case ALT_defaultopDeactivate:
				return field.isValue();
			case ALT_defaultopExit:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final DefaultEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.DefaultEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.DefaultEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_defaultopActivate:
				return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
			case ALT_defaultopDeactivate:
				return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
			case ALT_defaultopExit:
				return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof DefaultEvent_choice) {
				return operatorEquals((DefaultEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final DefaultEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public DefaultOp getdefaultopActivate() {
			if (union_selection != union_selection_type.ALT_defaultopActivate) {
				cleanUp();
				field = new DefaultOp();
				union_selection = union_selection_type.ALT_defaultopActivate;
			}
			return (DefaultOp)field;
		}

		public DefaultOp constGetdefaultopActivate() {
			if (union_selection != union_selection_type.ALT_defaultopActivate) {
				throw new TtcnError("Using non-selected field defaultopActivate in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp)field;
		}

		public DefaultOp getdefaultopDeactivate() {
			if (union_selection != union_selection_type.ALT_defaultopDeactivate) {
				cleanUp();
				field = new DefaultOp();
				union_selection = union_selection_type.ALT_defaultopDeactivate;
			}
			return (DefaultOp)field;
		}

		public DefaultOp constGetdefaultopDeactivate() {
			if (union_selection != union_selection_type.ALT_defaultopDeactivate) {
				throw new TtcnError("Using non-selected field defaultopDeactivate in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp)field;
		}

		public DefaultOp getdefaultopExit() {
			if (union_selection != union_selection_type.ALT_defaultopExit) {
				cleanUp();
				field = new DefaultOp();
				union_selection = union_selection_type.ALT_defaultopExit;
			}
			return (DefaultOp)field;
		}

		public DefaultOp constGetdefaultopExit() {
			if (union_selection != union_selection_type.ALT_defaultopExit) {
				throw new TtcnError("Using non-selected field defaultopExit in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_defaultopActivate:
				TTCN_Logger.log_event_str("{ defaultopActivate := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_defaultopDeactivate:
				TTCN_Logger.log_event_str("{ defaultopDeactivate := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_defaultopExit:
				TTCN_Logger.log_event_str("{ defaultopExit := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("defaultopActivate".equals(last_name)) {
				getdefaultopActivate().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("defaultopDeactivate".equals(last_name)) {
				getdefaultopDeactivate().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("defaultopExit".equals(last_name)) {
				getdefaultopExit().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.DefaultEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_defaultopActivate:
			case ALT_defaultopDeactivate:
			case ALT_defaultopExit:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_defaultopActivate:
				text_buf.push_int(0);
				break;
			case ALT_defaultopDeactivate:
				text_buf.push_int(1);
				break;
			case ALT_defaultopExit:
				text_buf.push_int(2);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getdefaultopActivate().decode_text(text_buf);
				break;
			case 1:
				getdefaultopDeactivate().decode_text(text_buf);
				break;
			case 2:
				getdefaultopExit().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.DefaultEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class DefaultEvent_choice_template extends Base_Template {
		//if single value which value?
		private DefaultEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<DefaultEvent_choice_template> value_list;

		private void copy_value(final DefaultEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_defaultopActivate:
				single_value = new DefaultOp_template(other_value.constGetdefaultopActivate());
				break;
			case ALT_defaultopDeactivate:
				single_value = new DefaultOp_template(other_value.constGetdefaultopDeactivate());
				break;
			case ALT_defaultopExit:
				single_value = new DefaultOp_template(other_value.constGetdefaultopExit());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.DefaultEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final DefaultEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_defaultopActivate:
					single_value = new DefaultOp_template(other_value.constGetdefaultopActivate());
					break;
				case ALT_defaultopDeactivate:
					single_value = new DefaultOp_template(other_value.constGetdefaultopDeactivate());
					break;
				case ALT_defaultopExit:
					single_value = new DefaultOp_template(other_value.constGetdefaultopExit());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.DefaultEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<DefaultEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final DefaultEvent_choice_template temp = new DefaultEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			set_selection(other_value);
		}

		public DefaultEvent_choice_template() {
			// do nothing
		}
		public DefaultEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public DefaultEvent_choice_template(final DefaultEvent_choice other_value) {
			copy_value(other_value);
		}
		public DefaultEvent_choice_template(final DefaultEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_defaultopActivate:
					((DefaultOp_template)single_value).cleanUp();
					break;
				case ALT_defaultopDeactivate:
					((DefaultOp_template)single_value).cleanUp();
					break;
				case ALT_defaultopExit:
					((DefaultOp_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public DefaultEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public DefaultEvent_choice_template assign( final DefaultEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public DefaultEvent_choice_template assign( final DefaultEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public DefaultEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof DefaultEvent_choice) {
				return assign((DefaultEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to DefaultEvent_choice.");
		}

		@Override
		public DefaultEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof DefaultEvent_choice_template) {
				return assign((DefaultEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to DefaultEvent_choice_template.");
		}

		// originally match
		public boolean match(final DefaultEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final DefaultEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final DefaultEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_defaultopActivate:
					return ((DefaultOp_template)single_value).match(other_value.getdefaultopActivate(), legacy);
				case ALT_defaultopDeactivate:
					return ((DefaultOp_template)single_value).match(other_value.getdefaultopDeactivate(), legacy);
				case ALT_defaultopExit:
					return ((DefaultOp_template)single_value).match(other_value.getdefaultopExit(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.DefaultEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof DefaultEvent_choice) {
				return match((DefaultEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultEvent_choice.");
		}
		public boolean isChosen(final DefaultEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.DefaultEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_defaultopActivate:
				return ((DefaultOp_template)single_value).isValue();
			case ALT_defaultopDeactivate:
				return ((DefaultOp_template)single_value).isValue();
			case ALT_defaultopExit:
				return ((DefaultOp_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
		}

		public DefaultEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			final DefaultEvent_choice ret_val = new DefaultEvent_choice();
			switch (single_value_union_selection) {
			case ALT_defaultopActivate:
				ret_val.getdefaultopActivate().assign(((DefaultOp_template)single_value).valueOf());
				break;
			case ALT_defaultopDeactivate:
				ret_val.getdefaultopDeactivate().assign(((DefaultOp_template)single_value).valueOf());
				break;
			case ALT_defaultopExit:
				ret_val.getdefaultopExit().assign(((DefaultOp_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<DefaultEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new DefaultEvent_choice_template());
			}
		}

		public DefaultEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public DefaultOp_template getdefaultopActivate() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopActivate) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new DefaultOp_template(template_sel.ANY_VALUE);
				} else {
					single_value = new DefaultOp_template();
				}
				single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_defaultopActivate;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (DefaultOp_template)single_value;
		}

		public DefaultOp_template constGetdefaultopActivate() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field defaultopActivate in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopActivate) {
				throw new TtcnError("Accessing non-selected field defaultopActivate in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp_template)single_value;
		}

		public DefaultOp_template getdefaultopDeactivate() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopDeactivate) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new DefaultOp_template(template_sel.ANY_VALUE);
				} else {
					single_value = new DefaultOp_template();
				}
				single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_defaultopDeactivate;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (DefaultOp_template)single_value;
		}

		public DefaultOp_template constGetdefaultopDeactivate() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field defaultopDeactivate in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopDeactivate) {
				throw new TtcnError("Accessing non-selected field defaultopDeactivate in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp_template)single_value;
		}

		public DefaultOp_template getdefaultopExit() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopExit) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new DefaultOp_template(template_sel.ANY_VALUE);
				} else {
					single_value = new DefaultOp_template();
				}
				single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_defaultopExit;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (DefaultOp_template)single_value;
		}

		public DefaultOp_template constGetdefaultopExit() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field defaultopExit in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_defaultopExit) {
				throw new TtcnError("Accessing non-selected field defaultopExit in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
			}
			return (DefaultOp_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultEvent_choice) {
				log_match((DefaultEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
		}

		public void log_match(final DefaultEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_defaultopActivate:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".defaultopActivate");
						single_value.log_match(match_value.getdefaultopActivate(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ defaultopActivate := ");
						single_value.log_match(match_value.getdefaultopActivate(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_defaultopDeactivate:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".defaultopDeactivate");
						single_value.log_match(match_value.getdefaultopDeactivate(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ defaultopDeactivate := ");
						single_value.log_match(match_value.getdefaultopDeactivate(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_defaultopExit:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".defaultopExit");
						single_value.log_match(match_value.getdefaultopExit(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ defaultopExit := ");
						single_value.log_match(match_value.getdefaultopExit(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.DefaultEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new DefaultOp_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new DefaultOp_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new DefaultOp_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<DefaultEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final DefaultEvent_choice_template temp2 = new DefaultEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.DefaultEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.DefaultEvent.choice");
				}
				if("defaultopActivate".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("defaultopDeactivate".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("defaultopExit".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.DefaultEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("defaultopActivate".equals(last_name)) {
					getdefaultopActivate().set_param(mp_last);
					break;
				}
				if("defaultopDeactivate".equals(last_name)) {
					getdefaultopDeactivate().set_param(mp_last);
					break;
				}
				if("defaultopExit".equals(last_name)) {
					getdefaultopExit().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.DefaultEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.DefaultEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_defaultopActivate:
					((DefaultOp_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultEvent.choice" : name, legacy);
					return;
				case ALT_defaultopDeactivate:
					((DefaultOp_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultEvent.choice" : name, legacy);
					return;
				case ALT_defaultopExit:
					((DefaultOp_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.DefaultEvent.choice" : name));
		}
	}
	public static void DefaultEvent_choice_encoder(final DefaultEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEvent_choice_decoder( final TitanOctetString input_stream, final DefaultEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TestcaseEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_testcaseStarted,  ALT_testcaseFinished };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public TestcaseEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public TestcaseEvent_choice(final TestcaseEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final TestcaseEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_testcaseStarted:
				field = new QualifiedName((QualifiedName)otherValue.field);
				break;
			case ALT_testcaseFinished:
				field = new TestcaseType((TestcaseType)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public TestcaseEvent_choice assign( final TestcaseEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public TestcaseEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof TestcaseEvent_choice) {
				return assign((TestcaseEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_testcaseStarted:
				return field.isValue();
			case ALT_testcaseFinished:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final TestcaseEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_testcaseStarted:
				return ((QualifiedName)field).operatorEquals((QualifiedName)otherValue.field);
			case ALT_testcaseFinished:
				return ((TestcaseType)field).operatorEquals((TestcaseType)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof TestcaseEvent_choice) {
				return operatorEquals((TestcaseEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final TestcaseEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public QualifiedName gettestcaseStarted() {
			if (union_selection != union_selection_type.ALT_testcaseStarted) {
				cleanUp();
				field = new QualifiedName();
				union_selection = union_selection_type.ALT_testcaseStarted;
			}
			return (QualifiedName)field;
		}

		public QualifiedName constGettestcaseStarted() {
			if (union_selection != union_selection_type.ALT_testcaseStarted) {
				throw new TtcnError("Using non-selected field testcaseStarted in a value of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return (QualifiedName)field;
		}

		public TestcaseType gettestcaseFinished() {
			if (union_selection != union_selection_type.ALT_testcaseFinished) {
				cleanUp();
				field = new TestcaseType();
				union_selection = union_selection_type.ALT_testcaseFinished;
			}
			return (TestcaseType)field;
		}

		public TestcaseType constGettestcaseFinished() {
			if (union_selection != union_selection_type.ALT_testcaseFinished) {
				throw new TtcnError("Using non-selected field testcaseFinished in a value of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return (TestcaseType)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_testcaseStarted:
				TTCN_Logger.log_event_str("{ testcaseStarted := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_testcaseFinished:
				TTCN_Logger.log_event_str("{ testcaseFinished := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("testcaseStarted".equals(last_name)) {
				gettestcaseStarted().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("testcaseFinished".equals(last_name)) {
				gettestcaseFinished().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.TestcaseEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_testcaseStarted:
			case ALT_testcaseFinished:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_testcaseStarted:
				text_buf.push_int(0);
				break;
			case ALT_testcaseFinished:
				text_buf.push_int(1);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				gettestcaseStarted().decode_text(text_buf);
				break;
			case 1:
				gettestcaseFinished().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.TestcaseEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TestcaseEvent_choice_template extends Base_Template {
		//if single value which value?
		private TestcaseEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<TestcaseEvent_choice_template> value_list;

		private void copy_value(final TestcaseEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_testcaseStarted:
				single_value = new QualifiedName_template(other_value.constGettestcaseStarted());
				break;
			case ALT_testcaseFinished:
				single_value = new TestcaseType_template(other_value.constGettestcaseFinished());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final TestcaseEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_testcaseStarted:
					single_value = new QualifiedName_template(other_value.constGettestcaseStarted());
					break;
				case ALT_testcaseFinished:
					single_value = new TestcaseType_template(other_value.constGettestcaseFinished());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.TestcaseEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<TestcaseEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final TestcaseEvent_choice_template temp = new TestcaseEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			set_selection(other_value);
		}

		public TestcaseEvent_choice_template() {
			// do nothing
		}
		public TestcaseEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public TestcaseEvent_choice_template(final TestcaseEvent_choice other_value) {
			copy_value(other_value);
		}
		public TestcaseEvent_choice_template(final TestcaseEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_testcaseStarted:
					((QualifiedName_template)single_value).cleanUp();
					break;
				case ALT_testcaseFinished:
					((TestcaseType_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public TestcaseEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TestcaseEvent_choice_template assign( final TestcaseEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public TestcaseEvent_choice_template assign( final TestcaseEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public TestcaseEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof TestcaseEvent_choice) {
				return assign((TestcaseEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to TestcaseEvent_choice.");
		}

		@Override
		public TestcaseEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof TestcaseEvent_choice_template) {
				return assign((TestcaseEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to TestcaseEvent_choice_template.");
		}

		// originally match
		public boolean match(final TestcaseEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final TestcaseEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final TestcaseEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_testcaseStarted:
					return ((QualifiedName_template)single_value).match(other_value.gettestcaseStarted(), legacy);
				case ALT_testcaseFinished:
					return ((TestcaseType_template)single_value).match(other_value.gettestcaseFinished(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TestcaseEvent_choice) {
				return match((TestcaseEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseEvent_choice.");
		}
		public boolean isChosen(final TestcaseEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_testcaseStarted:
				return ((QualifiedName_template)single_value).isValue();
			case ALT_testcaseFinished:
				return ((TestcaseType_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
		}

		public TestcaseEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			final TestcaseEvent_choice ret_val = new TestcaseEvent_choice();
			switch (single_value_union_selection) {
			case ALT_testcaseStarted:
				ret_val.gettestcaseStarted().assign(((QualifiedName_template)single_value).valueOf());
				break;
			case ALT_testcaseFinished:
				ret_val.gettestcaseFinished().assign(((TestcaseType_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<TestcaseEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new TestcaseEvent_choice_template());
			}
		}

		public TestcaseEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public QualifiedName_template gettestcaseStarted() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_testcaseStarted) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new QualifiedName_template(template_sel.ANY_VALUE);
				} else {
					single_value = new QualifiedName_template();
				}
				single_value_union_selection = TestcaseEvent_choice.union_selection_type.ALT_testcaseStarted;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (QualifiedName_template)single_value;
		}

		public QualifiedName_template constGettestcaseStarted() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field testcaseStarted in a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			if (single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_testcaseStarted) {
				throw new TtcnError("Accessing non-selected field testcaseStarted in a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return (QualifiedName_template)single_value;
		}

		public TestcaseType_template gettestcaseFinished() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_testcaseFinished) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TestcaseType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TestcaseType_template();
				}
				single_value_union_selection = TestcaseEvent_choice.union_selection_type.ALT_testcaseFinished;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TestcaseType_template)single_value;
		}

		public TestcaseType_template constGettestcaseFinished() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field testcaseFinished in a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			if (single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_testcaseFinished) {
				throw new TtcnError("Accessing non-selected field testcaseFinished in a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
			}
			return (TestcaseType_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TestcaseEvent_choice) {
				log_match((TestcaseEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
		}

		public void log_match(final TestcaseEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_testcaseStarted:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".testcaseStarted");
						single_value.log_match(match_value.gettestcaseStarted(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ testcaseStarted := ");
						single_value.log_match(match_value.gettestcaseStarted(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_testcaseFinished:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".testcaseFinished");
						single_value.log_match(match_value.gettestcaseFinished(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ testcaseFinished := ");
						single_value.log_match(match_value.gettestcaseFinished(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.TestcaseEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new QualifiedName_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TestcaseType_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<TestcaseEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final TestcaseEvent_choice_template temp2 = new TestcaseEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.TestcaseEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.TestcaseEvent.choice");
				}
				if("testcaseStarted".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("testcaseFinished".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.TestcaseEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("testcaseStarted".equals(last_name)) {
					gettestcaseStarted().set_param(mp_last);
					break;
				}
				if("testcaseFinished".equals(last_name)) {
					gettestcaseFinished().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.TestcaseEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.TestcaseEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_testcaseStarted:
					((QualifiedName_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseEvent.choice" : name, legacy);
					return;
				case ALT_testcaseFinished:
					((TestcaseType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TestcaseEvent.choice" : name));
		}
	}
	public static void TestcaseEvent_choice_encoder(final TestcaseEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseEvent_choice_decoder( final TitanOctetString input_stream, final TestcaseEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void VerdictOp_choice_finalVerdict_encoder(final FinalVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictOp_choice_finalVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictOp_choice_finalVerdict_decoder( final TitanOctetString input_stream, final FinalVerdictType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictOp_choice_finalVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingDoneType_reason extends Base_Type {
		public enum enum_type {
			done__failed__wrong__return__type (0),
			done__failed__no__return (1),
			any__component__done__successful (2),
			any__component__done__failed (3),
			all__component__done__successful (4),
			any__component__killed__successful (5),
			any__component__killed__failed (6),
			all__component__killed__successful (7),
			UNKNOWN_VALUE(8),
			UNBOUND_VALUE(9);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return done__failed__wrong__return__type;
				case 1:  return done__failed__no__return;
				case 2:  return any__component__done__successful;
				case 3:  return any__component__done__failed;
				case 4:  return all__component__done__successful;
				case 5:  return any__component__killed__successful;
				case 6:  return any__component__killed__failed;
				case 7:  return all__component__killed__successful;
				case 8:  return UNKNOWN_VALUE;
				case 9:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public MatchingDoneType_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public MatchingDoneType_reason(final MatchingDoneType_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public MatchingDoneType_reason(final MatchingDoneType_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public MatchingDoneType_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingDoneType_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public MatchingDoneType_reason assign(final MatchingDoneType_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public MatchingDoneType_reason assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingDoneType_reason ) {
				return assign((MatchingDoneType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public MatchingDoneType_reason assign(final MatchingDoneType_reason.enum_type otherValue){
			return assign( new MatchingDoneType_reason(otherValue) );
		}

		//originally operator=
		public MatchingDoneType_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingDoneType_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final MatchingDoneType_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof MatchingDoneType_reason) {
				return operatorEquals( (MatchingDoneType_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final MatchingDoneType_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingDoneType_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingDoneType_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final MatchingDoneType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final MatchingDoneType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingDoneType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingDoneType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingDoneType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingDoneType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingDoneType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingDoneType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final MatchingDoneType_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final MatchingDoneType_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("done__failed__wrong__return__type".equals(strPar) || "done_failed_wrong_return_type".equals(strPar)) {
				return enum_type.done__failed__wrong__return__type;
			}
			if ("done__failed__no__return".equals(strPar) || "done_failed_no_return".equals(strPar)) {
				return enum_type.done__failed__no__return;
			}
			if ("any__component__done__successful".equals(strPar) || "any_component_done_successful".equals(strPar)) {
				return enum_type.any__component__done__successful;
			}
			if ("any__component__done__failed".equals(strPar) || "any_component_done_failed".equals(strPar)) {
				return enum_type.any__component__done__failed;
			}
			if ("all__component__done__successful".equals(strPar) || "all_component_done_successful".equals(strPar)) {
				return enum_type.all__component__done__successful;
			}
			if ("any__component__killed__successful".equals(strPar) || "any_component_killed_successful".equals(strPar)) {
				return enum_type.any__component__killed__successful;
			}
			if ("any__component__killed__failed".equals(strPar) || "any_component_killed_failed".equals(strPar)) {
				return enum_type.any__component__killed__failed;
			}
			if ("all__component__killed__successful".equals(strPar) || "all_component_killed_successful".equals(strPar)) {
				return enum_type.all__component__killed__successful;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.MatchingDoneType.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingDoneType.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingDoneType.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingDoneType_reason_template extends Base_Template {
		// single_value
		private MatchingDoneType_reason.enum_type single_value;
		// value_list part
		private ArrayList<MatchingDoneType_reason_template> value_list;

		private void copy_template(final MatchingDoneType_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingDoneType_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final MatchingDoneType_reason_template temp = new MatchingDoneType_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingDoneType_reason.");
			}
		}

		public MatchingDoneType_reason_template() {
			// do nothing
		}

		public MatchingDoneType_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public MatchingDoneType_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!MatchingDoneType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type MatchingDoneType_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = MatchingDoneType_reason.enum_type.getValue(otherValue);
		}

		public MatchingDoneType_reason_template(final MatchingDoneType_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == MatchingDoneType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingDoneType_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public MatchingDoneType_reason_template(final MatchingDoneType_reason_template otherValue) {
			copy_template(otherValue);
		}

		public MatchingDoneType_reason_template(final MatchingDoneType_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != MatchingDoneType_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public MatchingDoneType_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public MatchingDoneType_reason_template assign(final int otherValue) {
			if (!MatchingDoneType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingDoneType_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public MatchingDoneType_reason_template assign(final MatchingDoneType_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public MatchingDoneType_reason_template assign(final MatchingDoneType_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public MatchingDoneType_reason_template assign(final MatchingDoneType_reason otherValue){
			if (otherValue.enum_value == MatchingDoneType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type MatchingDoneType_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public MatchingDoneType_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingDoneType_reason ) {
				return assign((MatchingDoneType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingDoneType_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof MatchingDoneType_reason_template ) {
				return assign((MatchingDoneType_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final MatchingDoneType_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final MatchingDoneType_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingDoneType_reason.");
			}
		}

		// originally match
		public boolean match(final MatchingDoneType_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final MatchingDoneType_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof MatchingDoneType_reason ) {
				return match((MatchingDoneType_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
		}

		public MatchingDoneType_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingDoneType_reason.");
			}
			return new MatchingDoneType_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingDoneType_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<MatchingDoneType_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingDoneType_reason_template());
			}
		}

		public MatchingDoneType_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingDoneType_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type MatchingDoneType_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type MatchingDoneType_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(MatchingDoneType_reason.enum2str(single_value), MatchingDoneType_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingDoneType_reason) {
				log_match((MatchingDoneType_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.reason.");
		}
		public void log_match(final MatchingDoneType_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final MatchingDoneType_reason.enum_type enum_value = MatchingDoneType_reason.str_to_enum(param.get_enumerated());
				if (!MatchingDoneType_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingDoneType.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.MatchingDoneType.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!MatchingDoneType_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingDoneType.reason.", temp));
				}
				single_value = MatchingDoneType_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingDoneType_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingDoneType_reason_template temp = new MatchingDoneType_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingDoneType.reason" : name));
		}
	}
	public static void MatchingDoneType_reason_encoder(final MatchingDoneType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingDoneType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingDoneType_reason_decoder( final TitanOctetString input_stream, final MatchingDoneType_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingDoneType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Strings_str__list_0_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Strings_str__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Strings_str__list_0_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Strings_str__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorConfigdata extends Base_Type {
		private final ExecutorConfigdata_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanCharString> param__; //CharString_Type

		public ExecutorConfigdata() {
			this.reason = new ExecutorConfigdata_reason();
			this.param__ = new Optional<TitanCharString>(TitanCharString.class);
		}

		public ExecutorConfigdata(final ExecutorConfigdata_reason reason, final Optional<TitanCharString> param__ ) {
			this.reason = new ExecutorConfigdata_reason( reason );
			this.param__ = new Optional<TitanCharString>(TitanCharString.class);
			this.param__.assign( param__ );
		}

		public ExecutorConfigdata( final ExecutorConfigdata otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			reason = new ExecutorConfigdata_reason();
			param__ = new Optional<TitanCharString>(TitanCharString.class);
			assign( otherValue );
		}

		public ExecutorConfigdata assign(final ExecutorConfigdata otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorConfigdata");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getparam__().isBound() ) {
					this.param__.assign( otherValue.getparam__() );
				} else {
					this.param__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorConfigdata assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata ) {
				return assign((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorConfigdata", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			param__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(param__.get_selection()) || param__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(param__.get_selection()) && !param__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorConfigdata otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.param__.operatorEquals( otherValue.param__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata ) {
				return operatorEquals((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorConfigdata", otherValue));
		}

		public ExecutorConfigdata_reason getreason() {
			return reason;
		}

		public ExecutorConfigdata_reason constGetreason() {
			return reason;
		}

		public Optional<TitanCharString> getparam__() {
			return param__;
		}

		public Optional<TitanCharString> constGetparam__() {
			return param__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (param__.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" param_ := ");
			param__.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutorConfigdata has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparam__().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("param_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparam__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorConfigdata: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutorConfigdata");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (param__.isBound()) {
				param__.set_implicit_omit();
			} else {
				param__.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			param__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			param__.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorConfigdata_template extends Base_Template {

		private ExecutorConfigdata_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template param__; //CharString_Type
		//originally value_list/list_value
		private List<ExecutorConfigdata_template> list_value;

		public ExecutorConfigdata_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public ExecutorConfigdata_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			return reason;
		}

		public TitanCharString_template getparam__() {
			setSpecific();
			return param__;
		}

		public TitanCharString_template constGetparam__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field param_ of a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			return param__;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new ExecutorConfigdata_reason_template();
				param__ = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					param__.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public ExecutorConfigdata_template() {
			// do nothing
		}

		public ExecutorConfigdata_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutorConfigdata_template( final ExecutorConfigdata otherValue ) {
			copyValue(otherValue);
		}

		public ExecutorConfigdata_template( final ExecutorConfigdata_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutorConfigdata_template( final Optional<ExecutorConfigdata> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorConfigdata from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutorConfigdata_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_template assign( final ExecutorConfigdata other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_template assign( final ExecutorConfigdata_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutorConfigdata_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata) {
				return assign((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorConfigdata_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorConfigdata_template) {
				return assign((ExecutorConfigdata_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata' can not be cast to {1}_template", otherValue));
		}

		public ExecutorConfigdata_template assign( final Optional<ExecutorConfigdata> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			return this;
		}

		private void copyValue(final ExecutorConfigdata other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getparam__().isBound()) {
				if (other_value.getparam__().isPresent()) {
					getparam__().assign(other_value.getparam__().get());
				} else {
					getparam__().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getparam__().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutorConfigdata_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparam__().get_selection()) {
					getparam__().cleanUp();
				} else {
					getparam__().assign(other_value.getparam__());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutorConfigdata_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutorConfigdata_template temp = new ExecutorConfigdata_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorConfigdata valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			final ExecutorConfigdata ret_val = new ExecutorConfigdata();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (param__.isOmit()) {
				ret_val.getparam__().assign(template_sel.OMIT_VALUE);
			} else if (param__.isBound()) {
				ret_val.getparam__().assign(param__.valueOf());
			}
			return ret_val;
		}

		public ExecutorConfigdata_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorConfigdata_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorConfigdata_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (param__.isOmit() || param__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!param__.isOmit() && !param__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorConfigdata other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorConfigdata other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getparam__().isBound()) {
					return false;
				}
				if((other_value.getparam__().isPresent() ? !param__.match(other_value.getparam__().get(), legacy) : !param__.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorConfigdata) {
				return match((ExecutorConfigdata)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorConfigdata.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (param__.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" param_ := ");
				param__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorConfigdata match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorConfigdata) {
				log_match((ExecutorConfigdata)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.");
		}

		public void log_match(final ExecutorConfigdata match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetparam__().isPresent()) {
							if( !param__.match(match_value.constGetparam__().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".param_");
								param__.log_match(match_value.constGetparam__().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!param__.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".param_ := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								param__.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ param_ := ");
				param__.log_match(match_value.constGetparam__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				param__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorConfigdata_reason_template();
				reason.decode_text(text_buf);
				param__ = new TitanCharString_template();
				param__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorConfigdata_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorConfigdata_template temp = new ExecutorConfigdata_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutorConfigdata has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparam__().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("param_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparam__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorConfigdata: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutorConfigdata");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorConfigdata" : name, legacy);
				this.param__.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorConfigdata" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorConfigdata" : name));
		}
	}
	public static void ExecutorConfigdata_encoder(final ExecutorConfigdata input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorConfigdata_decoder( final TitanOctetString input_stream, final ExecutorConfigdata output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_timeoutTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_timeoutTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_timeoutTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_timeoutTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingSuccessType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingSuccessType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingSuccessType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingSuccessType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__State_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__State_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__State_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__State_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultOp_end_encoder(final DefaultEnd input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultOp_end_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultOp_end_decoder( final TitanOctetString input_stream, final DefaultEnd output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultOp_end_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorRuntime_pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_pid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_pid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__discard_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__discard_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__discard_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__discard_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class LocationInfo extends Base_Type {
		private final TitanCharString filename; //CharString_Type
		private final TitanInteger line; //Integer_Type
		private final TitanCharString ent__name; //CharString_Type
		private final LocationInfo_ent__type ent__type; //TTCN3_Enumerated_Type

		public LocationInfo() {
			this.filename = new TitanCharString();
			this.line = new TitanInteger();
			this.ent__name = new TitanCharString();
			this.ent__type = new LocationInfo_ent__type();
		}

		public LocationInfo(final TitanCharString filename, final TitanInteger line, final TitanCharString ent__name, final LocationInfo_ent__type ent__type ) {
			this.filename = new TitanCharString( filename );
			this.line = new TitanInteger( line );
			this.ent__name = new TitanCharString( ent__name );
			this.ent__type = new LocationInfo_ent__type( ent__type );
		}

		public LocationInfo( final LocationInfo otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.LocationInfo.");
			}
			filename = new TitanCharString();
			line = new TitanInteger();
			ent__name = new TitanCharString();
			ent__type = new LocationInfo_ent__type();
			assign( otherValue );
		}

		public LocationInfo assign(final LocationInfo otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.LocationInfo");
			}

			if (otherValue != this) {
				if ( otherValue.getfilename().isBound() ) {
					this.filename.assign( otherValue.getfilename() );
				} else {
					this.filename.cleanUp();
				}
				if ( otherValue.getline().isBound() ) {
					this.line.assign( otherValue.getline() );
				} else {
					this.line.cleanUp();
				}
				if ( otherValue.getent__name().isBound() ) {
					this.ent__name.assign( otherValue.getent__name() );
				} else {
					this.ent__name.cleanUp();
				}
				if ( otherValue.getent__type().isBound() ) {
					this.ent__type.assign( otherValue.getent__type() );
				} else {
					this.ent__type.cleanUp();
				}
			}

			return this;
		}

		@Override
		public LocationInfo assign(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo ) {
				return assign((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LocationInfo", otherValue));
		}

		public void cleanUp() {
			filename.cleanUp();
			line.cleanUp();
			ent__name.cleanUp();
			ent__type.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( filename.isBound() ) { return true; }
			if ( line.isBound() ) { return true; }
			if ( ent__name.isBound() ) { return true; }
			if ( ent__type.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !filename.isValue() ) { return false; }
			if ( !line.isValue() ) { return false; }
			if ( !ent__name.isValue() ) { return false; }
			if ( !ent__type.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final LocationInfo otherValue) {
			if ( !this.filename.operatorEquals( otherValue.filename ) ) { return false; }
			if ( !this.line.operatorEquals( otherValue.line ) ) { return false; }
			if ( !this.ent__name.operatorEquals( otherValue.ent__name ) ) { return false; }
			if ( !this.ent__type.operatorEquals( otherValue.ent__type ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo ) {
				return operatorEquals((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LocationInfo", otherValue));
		}

		public TitanCharString getfilename() {
			return filename;
		}

		public TitanCharString constGetfilename() {
			return filename;
		}

		public TitanInteger getline() {
			return line;
		}

		public TitanInteger constGetline() {
			return line;
		}

		public TitanCharString getent__name() {
			return ent__name;
		}

		public TitanCharString constGetent__name() {
			return ent__name;
		}

		public LocationInfo_ent__type getent__type() {
			return ent__type;
		}

		public LocationInfo_ent__type constGetent__type() {
			return ent__type;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" filename := ");
			filename.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" line := ");
			line.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ent_name := ");
			ent__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ent_type := ");
			ent__type.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.LocationInfo has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfilename().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getline().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getent__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getent__type().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("filename".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfilename().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("line".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getline().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ent_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getent__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ent_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getent__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.LocationInfo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.LocationInfo");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (filename.isBound()) {
				filename.set_implicit_omit();
			}
			if (line.isBound()) {
				line.set_implicit_omit();
			}
			if (ent__name.isBound()) {
				ent__name.set_implicit_omit();
			}
			if (ent__type.isBound()) {
				ent__type.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			filename.encode_text(text_buf);
			line.encode_text(text_buf);
			ent__name.encode_text(text_buf);
			ent__type.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			filename.decode_text(text_buf);
			line.decode_text(text_buf);
			ent__name.decode_text(text_buf);
			ent__type.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class LocationInfo_template extends Base_Template {

		private TitanCharString_template filename; //CharString_Type
		private TitanInteger_template line; //Integer_Type
		private TitanCharString_template ent__name; //CharString_Type
		private LocationInfo_ent__type_template ent__type; //TTCN3_Enumerated_Type
		//originally value_list/list_value
		private List<LocationInfo_template> list_value;

		public TitanCharString_template getfilename() {
			setSpecific();
			return filename;
		}

		public TitanCharString_template constGetfilename() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field filename of a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			return filename;
		}

		public TitanInteger_template getline() {
			setSpecific();
			return line;
		}

		public TitanInteger_template constGetline() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field line of a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			return line;
		}

		public TitanCharString_template getent__name() {
			setSpecific();
			return ent__name;
		}

		public TitanCharString_template constGetent__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ent_name of a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			return ent__name;
		}

		public LocationInfo_ent__type_template getent__type() {
			setSpecific();
			return ent__type;
		}

		public LocationInfo_ent__type_template constGetent__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ent_type of a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			return ent__type;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				filename = new TitanCharString_template();
				line = new TitanInteger_template();
				ent__name = new TitanCharString_template();
				ent__type = new LocationInfo_ent__type_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					filename.assign(template_sel.ANY_VALUE);
					line.assign(template_sel.ANY_VALUE);
					ent__name.assign(template_sel.ANY_VALUE);
					ent__type.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public LocationInfo_template() {
			// do nothing
		}

		public LocationInfo_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public LocationInfo_template( final LocationInfo otherValue ) {
			copyValue(otherValue);
		}

		public LocationInfo_template( final LocationInfo_template otherValue ) {
			copyTemplate( otherValue );
		}

		public LocationInfo_template( final Optional<LocationInfo> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.LocationInfo from an unbound optional field.");
			}
		}

		//originally operator=
		public LocationInfo_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public LocationInfo_template assign( final LocationInfo other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public LocationInfo_template assign( final LocationInfo_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public LocationInfo_template assign(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo) {
				return assign((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo' can not be cast to {1}", otherValue));
		}

		@Override
		public LocationInfo_template assign(final Base_Template otherValue) {
			if (otherValue instanceof LocationInfo_template) {
				return assign((LocationInfo_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo' can not be cast to {1}_template", otherValue));
		}

		public LocationInfo_template assign( final Optional<LocationInfo> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.LocationInfo.");
			}
			return this;
		}

		private void copyValue(final LocationInfo other_value) {
			if (other_value.getfilename().isBound()) {
				getfilename().assign(other_value.getfilename());
			} else {
				getfilename().cleanUp();
			}
			if (other_value.getline().isBound()) {
				getline().assign(other_value.getline());
			} else {
				getline().cleanUp();
			}
			if (other_value.getent__name().isBound()) {
				getent__name().assign(other_value.getent__name());
			} else {
				getent__name().cleanUp();
			}
			if (other_value.getent__type().isBound()) {
				getent__type().assign(other_value.getent__type());
			} else {
				getent__type().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final LocationInfo_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfilename().get_selection()) {
					getfilename().cleanUp();
				} else {
					getfilename().assign(other_value.getfilename());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getline().get_selection()) {
					getline().cleanUp();
				} else {
					getline().assign(other_value.getline());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getent__name().get_selection()) {
					getent__name().cleanUp();
				} else {
					getent__name().assign(other_value.getent__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getent__type().get_selection()) {
					getent__type().cleanUp();
				} else {
					getent__type().assign(other_value.getent__type());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<LocationInfo_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final LocationInfo_template temp = new LocationInfo_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.LocationInfo.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public LocationInfo valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			final LocationInfo ret_val = new LocationInfo();
			if (filename.isBound()) {
				ret_val.getfilename().assign(filename.valueOf());
			}
			if (line.isBound()) {
				ret_val.getline().assign(line.valueOf());
			}
			if (ent__name.isBound()) {
				ret_val.getent__name().assign(ent__name.valueOf());
			}
			if (ent__type.isBound()) {
				ret_val.getent__type().assign(ent__type.valueOf());
			}
			return ret_val;
		}

		public LocationInfo_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.LocationInfo.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.LocationInfo.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.LocationInfo.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<LocationInfo_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new LocationInfo_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (filename.isBound()) {
				return true;
			}
			if (line.isBound()) {
				return true;
			}
			if (ent__name.isBound()) {
				return true;
			}
			if (ent__type.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!filename.isValue()) {
				return false;
			}
			if (!line.isValue()) {
				return false;
			}
			if (!ent__name.isValue()) {
				return false;
			}
			if (!ent__type.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final LocationInfo other_value) {
			return match(other_value, false);
		}

		public boolean match(final LocationInfo other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getfilename().isBound()) {
					return false;
				}
				if(!filename.match(other_value.getfilename(), legacy)) {
					return false;
				}
				if(!other_value.getline().isBound()) {
					return false;
				}
				if(!line.match(other_value.getline(), legacy)) {
					return false;
				}
				if(!other_value.getent__name().isBound()) {
					return false;
				}
				if(!ent__name.match(other_value.getent__name(), legacy)) {
					return false;
				}
				if(!other_value.getent__type().isBound()) {
					return false;
				}
				if(!ent__type.match(other_value.getent__type(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof LocationInfo) {
				return match((LocationInfo)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type LocationInfo.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" filename := ");
				filename.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" line := ");
				line.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ent_name := ");
				ent__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ent_type := ");
				ent__type.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final LocationInfo match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LocationInfo) {
				log_match((LocationInfo)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.");
		}

		public void log_match(final LocationInfo match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !filename.match(match_value.constGetfilename(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".filename");
							filename.log_match(match_value.constGetfilename(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !line.match(match_value.constGetline(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".line");
							line.log_match(match_value.constGetline(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ent__name.match(match_value.constGetent__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ent_name");
							ent__name.log_match(match_value.constGetent__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ent__type.match(match_value.constGetent__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ent_type");
							ent__type.log_match(match_value.constGetent__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ filename := ");
				filename.log_match(match_value.constGetfilename(), legacy);
				TTCN_Logger.log_event_str("{ line := ");
				line.log_match(match_value.constGetline(), legacy);
				TTCN_Logger.log_event_str("{ ent_name := ");
				ent__name.log_match(match_value.constGetent__name(), legacy);
				TTCN_Logger.log_event_str("{ ent_type := ");
				ent__type.log_match(match_value.constGetent__type(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				filename.encode_text(text_buf);
				line.encode_text(text_buf);
				ent__name.encode_text(text_buf);
				ent__type.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				filename = new TitanCharString_template();
				filename.decode_text(text_buf);
				line = new TitanInteger_template();
				line.decode_text(text_buf);
				ent__name = new TitanCharString_template();
				ent__name.decode_text(text_buf);
				ent__type = new LocationInfo_ent__type_template();
				ent__type.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<LocationInfo_template>(size);
				for (int i = 0; i < size; i++) {
					final LocationInfo_template temp = new LocationInfo_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.LocationInfo has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfilename().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getline().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getent__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getent__type().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("filename".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfilename().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("line".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getline().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ent_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getent__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ent_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getent__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.LocationInfo: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.LocationInfo");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.filename.check_restriction(restriction, name == null ? "@TitanLoggerApi.LocationInfo" : name, legacy);
				this.line.check_restriction(restriction, name == null ? "@TitanLoggerApi.LocationInfo" : name, legacy);
				this.ent__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.LocationInfo" : name, legacy);
				this.ent__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.LocationInfo" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.LocationInfo" : name));
		}
	}
	public static void LocationInfo_encoder(final LocationInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LocationInfo_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LocationInfo_decoder( final TitanOctetString input_stream, final LocationInfo output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LocationInfo_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TestcaseEvent extends Base_Type {
		private final TestcaseEvent_choice choice; //TTCN3_Choice_Type

		public TestcaseEvent() {
			this.choice = new TestcaseEvent_choice();
		}

		public TestcaseEvent(final TestcaseEvent_choice choice ) {
			this.choice = new TestcaseEvent_choice( choice );
		}

		public TestcaseEvent( final TestcaseEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TestcaseEvent.");
			}
			choice = new TestcaseEvent_choice();
			assign( otherValue );
		}

		public TestcaseEvent assign(final TestcaseEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TestcaseEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TestcaseEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent ) {
				return assign((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TestcaseEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent ) {
				return operatorEquals((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseEvent", otherValue));
		}

		public TestcaseEvent_choice getchoice() {
			return choice;
		}

		public TestcaseEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TestcaseEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TestcaseEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TestcaseEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TestcaseEvent_template extends Base_Template {

		private TestcaseEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<TestcaseEvent_template> list_value;

		public TestcaseEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public TestcaseEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.TestcaseEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new TestcaseEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TestcaseEvent_template() {
			// do nothing
		}

		public TestcaseEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TestcaseEvent_template( final TestcaseEvent otherValue ) {
			copyValue(otherValue);
		}

		public TestcaseEvent_template( final TestcaseEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TestcaseEvent_template( final Optional<TestcaseEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TestcaseEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public TestcaseEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TestcaseEvent_template assign( final TestcaseEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TestcaseEvent_template assign( final TestcaseEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TestcaseEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent) {
				return assign((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TestcaseEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TestcaseEvent_template) {
				return assign((TestcaseEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseEvent' can not be cast to {1}_template", otherValue));
		}

		public TestcaseEvent_template assign( final Optional<TestcaseEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TestcaseEvent.");
			}
			return this;
		}

		private void copyValue(final TestcaseEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TestcaseEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TestcaseEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TestcaseEvent_template temp = new TestcaseEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TestcaseEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TestcaseEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TestcaseEvent.");
			}
			final TestcaseEvent ret_val = new TestcaseEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public TestcaseEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TestcaseEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TestcaseEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TestcaseEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TestcaseEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TestcaseEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TestcaseEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TestcaseEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TestcaseEvent) {
				return match((TestcaseEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TestcaseEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TestcaseEvent) {
				log_match((TestcaseEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.");
		}

		public void log_match(final TestcaseEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new TestcaseEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TestcaseEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final TestcaseEvent_template temp = new TestcaseEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TestcaseEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TestcaseEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TestcaseEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TestcaseEvent" : name));
		}
	}
	public static void TestcaseEvent_encoder(final TestcaseEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseEvent_decoder( final TitanOctetString input_stream, final TestcaseEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimerEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_readTimer,  ALT_startTimer,  ALT_guardTimer,  ALT_stopTimer,  ALT_timeoutTimer,  ALT_timeoutAnyTimer,  ALT_unqualifiedTimer };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public TimerEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public TimerEvent_choice(final TimerEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final TimerEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_readTimer:
				field = new TimerType((TimerType)otherValue.field);
				break;
			case ALT_startTimer:
				field = new TimerType((TimerType)otherValue.field);
				break;
			case ALT_guardTimer:
				field = new TimerGuardType((TimerGuardType)otherValue.field);
				break;
			case ALT_stopTimer:
				field = new TimerType((TimerType)otherValue.field);
				break;
			case ALT_timeoutTimer:
				field = new TimerType((TimerType)otherValue.field);
				break;
			case ALT_timeoutAnyTimer:
				field = new TimerAnyTimeoutType((TimerAnyTimeoutType)otherValue.field);
				break;
			case ALT_unqualifiedTimer:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.TimerEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public TimerEvent_choice assign( final TimerEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public TimerEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof TimerEvent_choice) {
				return assign((TimerEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_readTimer:
				return field.isValue();
			case ALT_startTimer:
				return field.isValue();
			case ALT_guardTimer:
				return field.isValue();
			case ALT_stopTimer:
				return field.isValue();
			case ALT_timeoutTimer:
				return field.isValue();
			case ALT_timeoutAnyTimer:
				return field.isValue();
			case ALT_unqualifiedTimer:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final TimerEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.TimerEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.TimerEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_readTimer:
				return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
			case ALT_startTimer:
				return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
			case ALT_guardTimer:
				return ((TimerGuardType)field).operatorEquals((TimerGuardType)otherValue.field);
			case ALT_stopTimer:
				return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
			case ALT_timeoutTimer:
				return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
			case ALT_timeoutAnyTimer:
				return ((TimerAnyTimeoutType)field).operatorEquals((TimerAnyTimeoutType)otherValue.field);
			case ALT_unqualifiedTimer:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof TimerEvent_choice) {
				return operatorEquals((TimerEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final TimerEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public TimerType getreadTimer() {
			if (union_selection != union_selection_type.ALT_readTimer) {
				cleanUp();
				field = new TimerType();
				union_selection = union_selection_type.ALT_readTimer;
			}
			return (TimerType)field;
		}

		public TimerType constGetreadTimer() {
			if (union_selection != union_selection_type.ALT_readTimer) {
				throw new TtcnError("Using non-selected field readTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType)field;
		}

		public TimerType getstartTimer() {
			if (union_selection != union_selection_type.ALT_startTimer) {
				cleanUp();
				field = new TimerType();
				union_selection = union_selection_type.ALT_startTimer;
			}
			return (TimerType)field;
		}

		public TimerType constGetstartTimer() {
			if (union_selection != union_selection_type.ALT_startTimer) {
				throw new TtcnError("Using non-selected field startTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType)field;
		}

		public TimerGuardType getguardTimer() {
			if (union_selection != union_selection_type.ALT_guardTimer) {
				cleanUp();
				field = new TimerGuardType();
				union_selection = union_selection_type.ALT_guardTimer;
			}
			return (TimerGuardType)field;
		}

		public TimerGuardType constGetguardTimer() {
			if (union_selection != union_selection_type.ALT_guardTimer) {
				throw new TtcnError("Using non-selected field guardTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerGuardType)field;
		}

		public TimerType getstopTimer() {
			if (union_selection != union_selection_type.ALT_stopTimer) {
				cleanUp();
				field = new TimerType();
				union_selection = union_selection_type.ALT_stopTimer;
			}
			return (TimerType)field;
		}

		public TimerType constGetstopTimer() {
			if (union_selection != union_selection_type.ALT_stopTimer) {
				throw new TtcnError("Using non-selected field stopTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType)field;
		}

		public TimerType gettimeoutTimer() {
			if (union_selection != union_selection_type.ALT_timeoutTimer) {
				cleanUp();
				field = new TimerType();
				union_selection = union_selection_type.ALT_timeoutTimer;
			}
			return (TimerType)field;
		}

		public TimerType constGettimeoutTimer() {
			if (union_selection != union_selection_type.ALT_timeoutTimer) {
				throw new TtcnError("Using non-selected field timeoutTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType)field;
		}

		public TimerAnyTimeoutType gettimeoutAnyTimer() {
			if (union_selection != union_selection_type.ALT_timeoutAnyTimer) {
				cleanUp();
				field = new TimerAnyTimeoutType();
				union_selection = union_selection_type.ALT_timeoutAnyTimer;
			}
			return (TimerAnyTimeoutType)field;
		}

		public TimerAnyTimeoutType constGettimeoutAnyTimer() {
			if (union_selection != union_selection_type.ALT_timeoutAnyTimer) {
				throw new TtcnError("Using non-selected field timeoutAnyTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerAnyTimeoutType)field;
		}

		public TitanCharString getunqualifiedTimer() {
			if (union_selection != union_selection_type.ALT_unqualifiedTimer) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_unqualifiedTimer;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetunqualifiedTimer() {
			if (union_selection != union_selection_type.ALT_unqualifiedTimer) {
				throw new TtcnError("Using non-selected field unqualifiedTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TitanCharString)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_readTimer:
				TTCN_Logger.log_event_str("{ readTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_startTimer:
				TTCN_Logger.log_event_str("{ startTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_guardTimer:
				TTCN_Logger.log_event_str("{ guardTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_stopTimer:
				TTCN_Logger.log_event_str("{ stopTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_timeoutTimer:
				TTCN_Logger.log_event_str("{ timeoutTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_timeoutAnyTimer:
				TTCN_Logger.log_event_str("{ timeoutAnyTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_unqualifiedTimer:
				TTCN_Logger.log_event_str("{ unqualifiedTimer := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("readTimer".equals(last_name)) {
				getreadTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("startTimer".equals(last_name)) {
				getstartTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("guardTimer".equals(last_name)) {
				getguardTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("stopTimer".equals(last_name)) {
				getstopTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("timeoutTimer".equals(last_name)) {
				gettimeoutTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("timeoutAnyTimer".equals(last_name)) {
				gettimeoutAnyTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("unqualifiedTimer".equals(last_name)) {
				getunqualifiedTimer().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.TimerEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_readTimer:
			case ALT_startTimer:
			case ALT_guardTimer:
			case ALT_stopTimer:
			case ALT_timeoutTimer:
			case ALT_timeoutAnyTimer:
			case ALT_unqualifiedTimer:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_readTimer:
				text_buf.push_int(0);
				break;
			case ALT_startTimer:
				text_buf.push_int(1);
				break;
			case ALT_guardTimer:
				text_buf.push_int(2);
				break;
			case ALT_stopTimer:
				text_buf.push_int(3);
				break;
			case ALT_timeoutTimer:
				text_buf.push_int(4);
				break;
			case ALT_timeoutAnyTimer:
				text_buf.push_int(5);
				break;
			case ALT_unqualifiedTimer:
				text_buf.push_int(6);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getreadTimer().decode_text(text_buf);
				break;
			case 1:
				getstartTimer().decode_text(text_buf);
				break;
			case 2:
				getguardTimer().decode_text(text_buf);
				break;
			case 3:
				getstopTimer().decode_text(text_buf);
				break;
			case 4:
				gettimeoutTimer().decode_text(text_buf);
				break;
			case 5:
				gettimeoutAnyTimer().decode_text(text_buf);
				break;
			case 6:
				getunqualifiedTimer().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.TimerEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TimerEvent_choice_template extends Base_Template {
		//if single value which value?
		private TimerEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<TimerEvent_choice_template> value_list;

		private void copy_value(final TimerEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_readTimer:
				single_value = new TimerType_template(other_value.constGetreadTimer());
				break;
			case ALT_startTimer:
				single_value = new TimerType_template(other_value.constGetstartTimer());
				break;
			case ALT_guardTimer:
				single_value = new TimerGuardType_template(other_value.constGetguardTimer());
				break;
			case ALT_stopTimer:
				single_value = new TimerType_template(other_value.constGetstopTimer());
				break;
			case ALT_timeoutTimer:
				single_value = new TimerType_template(other_value.constGettimeoutTimer());
				break;
			case ALT_timeoutAnyTimer:
				single_value = new TimerAnyTimeoutType_template(other_value.constGettimeoutAnyTimer());
				break;
			case ALT_unqualifiedTimer:
				single_value = new TitanCharString_template(other_value.constGetunqualifiedTimer());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.TimerEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final TimerEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_readTimer:
					single_value = new TimerType_template(other_value.constGetreadTimer());
					break;
				case ALT_startTimer:
					single_value = new TimerType_template(other_value.constGetstartTimer());
					break;
				case ALT_guardTimer:
					single_value = new TimerGuardType_template(other_value.constGetguardTimer());
					break;
				case ALT_stopTimer:
					single_value = new TimerType_template(other_value.constGetstopTimer());
					break;
				case ALT_timeoutTimer:
					single_value = new TimerType_template(other_value.constGettimeoutTimer());
					break;
				case ALT_timeoutAnyTimer:
					single_value = new TimerAnyTimeoutType_template(other_value.constGettimeoutAnyTimer());
					break;
				case ALT_unqualifiedTimer:
					single_value = new TitanCharString_template(other_value.constGetunqualifiedTimer());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.TimerEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<TimerEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final TimerEvent_choice_template temp = new TimerEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			set_selection(other_value);
		}

		public TimerEvent_choice_template() {
			// do nothing
		}
		public TimerEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public TimerEvent_choice_template(final TimerEvent_choice other_value) {
			copy_value(other_value);
		}
		public TimerEvent_choice_template(final TimerEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_readTimer:
					((TimerType_template)single_value).cleanUp();
					break;
				case ALT_startTimer:
					((TimerType_template)single_value).cleanUp();
					break;
				case ALT_guardTimer:
					((TimerGuardType_template)single_value).cleanUp();
					break;
				case ALT_stopTimer:
					((TimerType_template)single_value).cleanUp();
					break;
				case ALT_timeoutTimer:
					((TimerType_template)single_value).cleanUp();
					break;
				case ALT_timeoutAnyTimer:
					((TimerAnyTimeoutType_template)single_value).cleanUp();
					break;
				case ALT_unqualifiedTimer:
					((TitanCharString_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public TimerEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimerEvent_choice_template assign( final TimerEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public TimerEvent_choice_template assign( final TimerEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public TimerEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof TimerEvent_choice) {
				return assign((TimerEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to TimerEvent_choice.");
		}

		@Override
		public TimerEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof TimerEvent_choice_template) {
				return assign((TimerEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to TimerEvent_choice_template.");
		}

		// originally match
		public boolean match(final TimerEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final TimerEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final TimerEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_readTimer:
					return ((TimerType_template)single_value).match(other_value.getreadTimer(), legacy);
				case ALT_startTimer:
					return ((TimerType_template)single_value).match(other_value.getstartTimer(), legacy);
				case ALT_guardTimer:
					return ((TimerGuardType_template)single_value).match(other_value.getguardTimer(), legacy);
				case ALT_stopTimer:
					return ((TimerType_template)single_value).match(other_value.getstopTimer(), legacy);
				case ALT_timeoutTimer:
					return ((TimerType_template)single_value).match(other_value.gettimeoutTimer(), legacy);
				case ALT_timeoutAnyTimer:
					return ((TimerAnyTimeoutType_template)single_value).match(other_value.gettimeoutAnyTimer(), legacy);
				case ALT_unqualifiedTimer:
					return ((TitanCharString_template)single_value).match(other_value.getunqualifiedTimer(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.TimerEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TimerEvent_choice) {
				return match((TimerEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerEvent_choice.");
		}
		public boolean isChosen(final TimerEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.TimerEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_readTimer:
				return ((TimerType_template)single_value).isValue();
			case ALT_startTimer:
				return ((TimerType_template)single_value).isValue();
			case ALT_guardTimer:
				return ((TimerGuardType_template)single_value).isValue();
			case ALT_stopTimer:
				return ((TimerType_template)single_value).isValue();
			case ALT_timeoutTimer:
				return ((TimerType_template)single_value).isValue();
			case ALT_timeoutAnyTimer:
				return ((TimerAnyTimeoutType_template)single_value).isValue();
			case ALT_unqualifiedTimer:
				return ((TitanCharString_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
		}

		public TimerEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			final TimerEvent_choice ret_val = new TimerEvent_choice();
			switch (single_value_union_selection) {
			case ALT_readTimer:
				ret_val.getreadTimer().assign(((TimerType_template)single_value).valueOf());
				break;
			case ALT_startTimer:
				ret_val.getstartTimer().assign(((TimerType_template)single_value).valueOf());
				break;
			case ALT_guardTimer:
				ret_val.getguardTimer().assign(((TimerGuardType_template)single_value).valueOf());
				break;
			case ALT_stopTimer:
				ret_val.getstopTimer().assign(((TimerType_template)single_value).valueOf());
				break;
			case ALT_timeoutTimer:
				ret_val.gettimeoutTimer().assign(((TimerType_template)single_value).valueOf());
				break;
			case ALT_timeoutAnyTimer:
				ret_val.gettimeoutAnyTimer().assign(((TimerAnyTimeoutType_template)single_value).valueOf());
				break;
			case ALT_unqualifiedTimer:
				ret_val.getunqualifiedTimer().assign(((TitanCharString_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<TimerEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new TimerEvent_choice_template());
			}
		}

		public TimerEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public TimerType_template getreadTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_readTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_readTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template constGetreadTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field readTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_readTimer) {
				throw new TtcnError("Accessing non-selected field readTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template getstartTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_startTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_startTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template constGetstartTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field startTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_startTimer) {
				throw new TtcnError("Accessing non-selected field startTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType_template)single_value;
		}

		public TimerGuardType_template getguardTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_guardTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerGuardType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerGuardType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_guardTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerGuardType_template)single_value;
		}

		public TimerGuardType_template constGetguardTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field guardTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_guardTimer) {
				throw new TtcnError("Accessing non-selected field guardTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerGuardType_template)single_value;
		}

		public TimerType_template getstopTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_stopTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_stopTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template constGetstopTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field stopTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_stopTimer) {
				throw new TtcnError("Accessing non-selected field stopTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template gettimeoutTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_timeoutTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_timeoutTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerType_template)single_value;
		}

		public TimerType_template constGettimeoutTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field timeoutTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_timeoutTimer) {
				throw new TtcnError("Accessing non-selected field timeoutTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerType_template)single_value;
		}

		public TimerAnyTimeoutType_template gettimeoutAnyTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_timeoutAnyTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TimerAnyTimeoutType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TimerAnyTimeoutType_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_timeoutAnyTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TimerAnyTimeoutType_template)single_value;
		}

		public TimerAnyTimeoutType_template constGettimeoutAnyTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field timeoutAnyTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_timeoutAnyTimer) {
				throw new TtcnError("Accessing non-selected field timeoutAnyTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TimerAnyTimeoutType_template)single_value;
		}

		public TitanCharString_template getunqualifiedTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_unqualifiedTimer) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_unqualifiedTimer;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetunqualifiedTimer() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field unqualifiedTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_unqualifiedTimer) {
				throw new TtcnError("Accessing non-selected field unqualifiedTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerEvent_choice) {
				log_match((TimerEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
		}

		public void log_match(final TimerEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_readTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".readTimer");
						single_value.log_match(match_value.getreadTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ readTimer := ");
						single_value.log_match(match_value.getreadTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_startTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".startTimer");
						single_value.log_match(match_value.getstartTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ startTimer := ");
						single_value.log_match(match_value.getstartTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_guardTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".guardTimer");
						single_value.log_match(match_value.getguardTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ guardTimer := ");
						single_value.log_match(match_value.getguardTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_stopTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".stopTimer");
						single_value.log_match(match_value.getstopTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ stopTimer := ");
						single_value.log_match(match_value.getstopTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_timeoutTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".timeoutTimer");
						single_value.log_match(match_value.gettimeoutTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ timeoutTimer := ");
						single_value.log_match(match_value.gettimeoutTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_timeoutAnyTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".timeoutAnyTimer");
						single_value.log_match(match_value.gettimeoutAnyTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ timeoutAnyTimer := ");
						single_value.log_match(match_value.gettimeoutAnyTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_unqualifiedTimer:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".unqualifiedTimer");
						single_value.log_match(match_value.getunqualifiedTimer(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ unqualifiedTimer := ");
						single_value.log_match(match_value.getunqualifiedTimer(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.TimerEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new TimerType_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TimerType_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new TimerGuardType_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TimerType_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new TimerType_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new TimerAnyTimeoutType_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<TimerEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final TimerEvent_choice_template temp2 = new TimerEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.TimerEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.TimerEvent.choice");
				}
				if("readTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("startTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("guardTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("stopTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("timeoutTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("timeoutAnyTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("unqualifiedTimer".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.TimerEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("readTimer".equals(last_name)) {
					getreadTimer().set_param(mp_last);
					break;
				}
				if("startTimer".equals(last_name)) {
					getstartTimer().set_param(mp_last);
					break;
				}
				if("guardTimer".equals(last_name)) {
					getguardTimer().set_param(mp_last);
					break;
				}
				if("stopTimer".equals(last_name)) {
					getstopTimer().set_param(mp_last);
					break;
				}
				if("timeoutTimer".equals(last_name)) {
					gettimeoutTimer().set_param(mp_last);
					break;
				}
				if("timeoutAnyTimer".equals(last_name)) {
					gettimeoutAnyTimer().set_param(mp_last);
					break;
				}
				if("unqualifiedTimer".equals(last_name)) {
					getunqualifiedTimer().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.TimerEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.TimerEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_readTimer:
					((TimerType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_startTimer:
					((TimerType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_guardTimer:
					((TimerGuardType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_stopTimer:
					((TimerType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_timeoutTimer:
					((TimerType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_timeoutAnyTimer:
					((TimerAnyTimeoutType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				case ALT_unqualifiedTimer:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimerEvent.choice" : name));
		}
	}
	public static void TimerEvent_choice_encoder(final TimerEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_decoder( final TitanOctetString input_stream, final TimerEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class StatisticsType_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_verdictStatistics,  ALT_controlpartStart,  ALT_controlpartFinish,  ALT_controlpartErrors };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public StatisticsType_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public StatisticsType_choice(final StatisticsType_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final StatisticsType_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_verdictStatistics:
				field = new StatisticsType_choice_verdictStatistics((StatisticsType_choice_verdictStatistics)otherValue.field);
				break;
			case ALT_controlpartStart:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_controlpartFinish:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_controlpartErrors:
				field = new TitanInteger((TitanInteger)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.StatisticsType.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public StatisticsType_choice assign( final StatisticsType_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public StatisticsType_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof StatisticsType_choice) {
				return assign((StatisticsType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_verdictStatistics:
				return field.isValue();
			case ALT_controlpartStart:
				return field.isValue();
			case ALT_controlpartFinish:
				return field.isValue();
			case ALT_controlpartErrors:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final StatisticsType_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.StatisticsType.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.StatisticsType.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_verdictStatistics:
				return ((StatisticsType_choice_verdictStatistics)field).operatorEquals((StatisticsType_choice_verdictStatistics)otherValue.field);
			case ALT_controlpartStart:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_controlpartFinish:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_controlpartErrors:
				return ((TitanInteger)field).operatorEquals((TitanInteger)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof StatisticsType_choice) {
				return operatorEquals((StatisticsType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final StatisticsType_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public StatisticsType_choice_verdictStatistics getverdictStatistics() {
			if (union_selection != union_selection_type.ALT_verdictStatistics) {
				cleanUp();
				field = new StatisticsType_choice_verdictStatistics();
				union_selection = union_selection_type.ALT_verdictStatistics;
			}
			return (StatisticsType_choice_verdictStatistics)field;
		}

		public StatisticsType_choice_verdictStatistics constGetverdictStatistics() {
			if (union_selection != union_selection_type.ALT_verdictStatistics) {
				throw new TtcnError("Using non-selected field verdictStatistics in a value of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (StatisticsType_choice_verdictStatistics)field;
		}

		public TitanCharString getcontrolpartStart() {
			if (union_selection != union_selection_type.ALT_controlpartStart) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_controlpartStart;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetcontrolpartStart() {
			if (union_selection != union_selection_type.ALT_controlpartStart) {
				throw new TtcnError("Using non-selected field controlpartStart in a value of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanCharString)field;
		}

		public TitanCharString getcontrolpartFinish() {
			if (union_selection != union_selection_type.ALT_controlpartFinish) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_controlpartFinish;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetcontrolpartFinish() {
			if (union_selection != union_selection_type.ALT_controlpartFinish) {
				throw new TtcnError("Using non-selected field controlpartFinish in a value of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanCharString)field;
		}

		public TitanInteger getcontrolpartErrors() {
			if (union_selection != union_selection_type.ALT_controlpartErrors) {
				cleanUp();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_controlpartErrors;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGetcontrolpartErrors() {
			if (union_selection != union_selection_type.ALT_controlpartErrors) {
				throw new TtcnError("Using non-selected field controlpartErrors in a value of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanInteger)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_verdictStatistics:
				TTCN_Logger.log_event_str("{ verdictStatistics := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_controlpartStart:
				TTCN_Logger.log_event_str("{ controlpartStart := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_controlpartFinish:
				TTCN_Logger.log_event_str("{ controlpartFinish := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_controlpartErrors:
				TTCN_Logger.log_event_str("{ controlpartErrors := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("verdictStatistics".equals(last_name)) {
				getverdictStatistics().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("controlpartStart".equals(last_name)) {
				getcontrolpartStart().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("controlpartFinish".equals(last_name)) {
				getcontrolpartFinish().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("controlpartErrors".equals(last_name)) {
				getcontrolpartErrors().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.StatisticsType.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_verdictStatistics:
			case ALT_controlpartStart:
			case ALT_controlpartFinish:
			case ALT_controlpartErrors:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_verdictStatistics:
				text_buf.push_int(0);
				break;
			case ALT_controlpartStart:
				text_buf.push_int(1);
				break;
			case ALT_controlpartFinish:
				text_buf.push_int(2);
				break;
			case ALT_controlpartErrors:
				text_buf.push_int(3);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getverdictStatistics().decode_text(text_buf);
				break;
			case 1:
				getcontrolpartStart().decode_text(text_buf);
				break;
			case 2:
				getcontrolpartFinish().decode_text(text_buf);
				break;
			case 3:
				getcontrolpartErrors().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.StatisticsType.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class StatisticsType_choice_template extends Base_Template {
		//if single value which value?
		private StatisticsType_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<StatisticsType_choice_template> value_list;

		private void copy_value(final StatisticsType_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_verdictStatistics:
				single_value = new StatisticsType_choice_verdictStatistics_template(other_value.constGetverdictStatistics());
				break;
			case ALT_controlpartStart:
				single_value = new TitanCharString_template(other_value.constGetcontrolpartStart());
				break;
			case ALT_controlpartFinish:
				single_value = new TitanCharString_template(other_value.constGetcontrolpartFinish());
				break;
			case ALT_controlpartErrors:
				single_value = new TitanInteger_template(other_value.constGetcontrolpartErrors());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.StatisticsType.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final StatisticsType_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_verdictStatistics:
					single_value = new StatisticsType_choice_verdictStatistics_template(other_value.constGetverdictStatistics());
					break;
				case ALT_controlpartStart:
					single_value = new TitanCharString_template(other_value.constGetcontrolpartStart());
					break;
				case ALT_controlpartFinish:
					single_value = new TitanCharString_template(other_value.constGetcontrolpartFinish());
					break;
				case ALT_controlpartErrors:
					single_value = new TitanInteger_template(other_value.constGetcontrolpartErrors());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.StatisticsType.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<StatisticsType_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final StatisticsType_choice_template temp = new StatisticsType_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			set_selection(other_value);
		}

		public StatisticsType_choice_template() {
			// do nothing
		}
		public StatisticsType_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public StatisticsType_choice_template(final StatisticsType_choice other_value) {
			copy_value(other_value);
		}
		public StatisticsType_choice_template(final StatisticsType_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_verdictStatistics:
					((StatisticsType_choice_verdictStatistics_template)single_value).cleanUp();
					break;
				case ALT_controlpartStart:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_controlpartFinish:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_controlpartErrors:
					((TitanInteger_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public StatisticsType_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_choice_template assign( final StatisticsType_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_choice_template assign( final StatisticsType_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public StatisticsType_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof StatisticsType_choice) {
				return assign((StatisticsType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to StatisticsType_choice.");
		}

		@Override
		public StatisticsType_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof StatisticsType_choice_template) {
				return assign((StatisticsType_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to StatisticsType_choice_template.");
		}

		// originally match
		public boolean match(final StatisticsType_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final StatisticsType_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final StatisticsType_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_verdictStatistics:
					return ((StatisticsType_choice_verdictStatistics_template)single_value).match(other_value.getverdictStatistics(), legacy);
				case ALT_controlpartStart:
					return ((TitanCharString_template)single_value).match(other_value.getcontrolpartStart(), legacy);
				case ALT_controlpartFinish:
					return ((TitanCharString_template)single_value).match(other_value.getcontrolpartFinish(), legacy);
				case ALT_controlpartErrors:
					return ((TitanInteger_template)single_value).match(other_value.getcontrolpartErrors(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.StatisticsType.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof StatisticsType_choice) {
				return match((StatisticsType_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType_choice.");
		}
		public boolean isChosen(final StatisticsType_choice.union_selection_type checked_selection) {
			if(checked_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.StatisticsType.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_verdictStatistics:
				return ((StatisticsType_choice_verdictStatistics_template)single_value).isValue();
			case ALT_controlpartStart:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_controlpartFinish:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_controlpartErrors:
				return ((TitanInteger_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
		}

		public StatisticsType_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			final StatisticsType_choice ret_val = new StatisticsType_choice();
			switch (single_value_union_selection) {
			case ALT_verdictStatistics:
				ret_val.getverdictStatistics().assign(((StatisticsType_choice_verdictStatistics_template)single_value).valueOf());
				break;
			case ALT_controlpartStart:
				ret_val.getcontrolpartStart().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_controlpartFinish:
				ret_val.getcontrolpartFinish().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_controlpartErrors:
				ret_val.getcontrolpartErrors().assign(((TitanInteger_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<StatisticsType_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new StatisticsType_choice_template());
			}
		}

		public StatisticsType_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public StatisticsType_choice_verdictStatistics_template getverdictStatistics() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_verdictStatistics) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new StatisticsType_choice_verdictStatistics_template(template_sel.ANY_VALUE);
				} else {
					single_value = new StatisticsType_choice_verdictStatistics_template();
				}
				single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_verdictStatistics;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (StatisticsType_choice_verdictStatistics_template)single_value;
		}

		public StatisticsType_choice_verdictStatistics_template constGetverdictStatistics() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field verdictStatistics in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_verdictStatistics) {
				throw new TtcnError("Accessing non-selected field verdictStatistics in a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (StatisticsType_choice_verdictStatistics_template)single_value;
		}

		public TitanCharString_template getcontrolpartStart() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartStart) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_controlpartStart;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetcontrolpartStart() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field controlpartStart in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartStart) {
				throw new TtcnError("Accessing non-selected field controlpartStart in a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template getcontrolpartFinish() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartFinish) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_controlpartFinish;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetcontrolpartFinish() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field controlpartFinish in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartFinish) {
				throw new TtcnError("Accessing non-selected field controlpartFinish in a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public TitanInteger_template getcontrolpartErrors() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartErrors) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_controlpartErrors;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGetcontrolpartErrors() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field controlpartErrors in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_controlpartErrors) {
				throw new TtcnError("Accessing non-selected field controlpartErrors in a template of union type @TitanLoggerApi.StatisticsType.choice.");
			}
			return (TitanInteger_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StatisticsType_choice) {
				log_match((StatisticsType_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
		}

		public void log_match(final StatisticsType_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_verdictStatistics:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".verdictStatistics");
						single_value.log_match(match_value.getverdictStatistics(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ verdictStatistics := ");
						single_value.log_match(match_value.getverdictStatistics(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_controlpartStart:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".controlpartStart");
						single_value.log_match(match_value.getcontrolpartStart(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ controlpartStart := ");
						single_value.log_match(match_value.getcontrolpartStart(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_controlpartFinish:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".controlpartFinish");
						single_value.log_match(match_value.getcontrolpartFinish(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ controlpartFinish := ");
						single_value.log_match(match_value.getcontrolpartFinish(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_controlpartErrors:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".controlpartErrors");
						single_value.log_match(match_value.getcontrolpartErrors(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ controlpartErrors := ");
						single_value.log_match(match_value.getcontrolpartErrors(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.StatisticsType.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new StatisticsType_choice_verdictStatistics_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<StatisticsType_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final StatisticsType_choice_template temp2 = new StatisticsType_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.StatisticsType.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.StatisticsType.choice");
				}
				if("verdictStatistics".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("controlpartStart".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("controlpartFinish".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("controlpartErrors".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.StatisticsType.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("verdictStatistics".equals(last_name)) {
					getverdictStatistics().set_param(mp_last);
					break;
				}
				if("controlpartStart".equals(last_name)) {
					getcontrolpartStart().set_param(mp_last);
					break;
				}
				if("controlpartFinish".equals(last_name)) {
					getcontrolpartFinish().set_param(mp_last);
					break;
				}
				if("controlpartErrors".equals(last_name)) {
					getcontrolpartErrors().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.StatisticsType.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.StatisticsType.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_verdictStatistics:
					((StatisticsType_choice_verdictStatistics_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice" : name, legacy);
					return;
				case ALT_controlpartStart:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice" : name, legacy);
					return;
				case ALT_controlpartFinish:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice" : name, legacy);
					return;
				case ALT_controlpartErrors:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.StatisticsType.choice" : name));
		}
	}
	public static void StatisticsType_choice_encoder(final StatisticsType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_decoder( final TitanOctetString input_stream, final StatisticsType_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimestampType_microSeconds_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimestampType_microSeconds_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimestampType_microSeconds_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimestampType_microSeconds_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__Misc extends Base_Type {
		private final Port__Misc_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger remote__component; //Integer_Type
		private final TitanCharString remote__port; //CharString_Type
		private final TitanCharString ip__address; //CharString_Type
		private final TitanInteger tcp__port; //Integer_Type
		private final TitanInteger new__size; //Integer_Type

		public Port__Misc() {
			this.reason = new Port__Misc_reason();
			this.port__name = new TitanCharString();
			this.remote__component = new TitanInteger();
			this.remote__port = new TitanCharString();
			this.ip__address = new TitanCharString();
			this.tcp__port = new TitanInteger();
			this.new__size = new TitanInteger();
		}

		public Port__Misc(final Port__Misc_reason reason, final TitanCharString port__name, final TitanInteger remote__component, final TitanCharString remote__port, final TitanCharString ip__address, final TitanInteger tcp__port, final TitanInteger new__size ) {
			this.reason = new Port__Misc_reason( reason );
			this.port__name = new TitanCharString( port__name );
			this.remote__component = new TitanInteger( remote__component );
			this.remote__port = new TitanCharString( remote__port );
			this.ip__address = new TitanCharString( ip__address );
			this.tcp__port = new TitanInteger( tcp__port );
			this.new__size = new TitanInteger( new__size );
		}

		public Port__Misc( final Port__Misc otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_Misc.");
			}
			reason = new Port__Misc_reason();
			port__name = new TitanCharString();
			remote__component = new TitanInteger();
			remote__port = new TitanCharString();
			ip__address = new TitanCharString();
			tcp__port = new TitanInteger();
			new__size = new TitanInteger();
			assign( otherValue );
		}

		public Port__Misc assign(final Port__Misc otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_Misc");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getremote__component().isBound() ) {
					this.remote__component.assign( otherValue.getremote__component() );
				} else {
					this.remote__component.cleanUp();
				}
				if ( otherValue.getremote__port().isBound() ) {
					this.remote__port.assign( otherValue.getremote__port() );
				} else {
					this.remote__port.cleanUp();
				}
				if ( otherValue.getip__address().isBound() ) {
					this.ip__address.assign( otherValue.getip__address() );
				} else {
					this.ip__address.cleanUp();
				}
				if ( otherValue.gettcp__port().isBound() ) {
					this.tcp__port.assign( otherValue.gettcp__port() );
				} else {
					this.tcp__port.cleanUp();
				}
				if ( otherValue.getnew__size().isBound() ) {
					this.new__size.assign( otherValue.getnew__size() );
				} else {
					this.new__size.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__Misc assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc ) {
				return assign((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Misc", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			port__name.cleanUp();
			remote__component.cleanUp();
			remote__port.cleanUp();
			ip__address.cleanUp();
			tcp__port.cleanUp();
			new__size.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( remote__component.isBound() ) { return true; }
			if ( remote__port.isBound() ) { return true; }
			if ( ip__address.isBound() ) { return true; }
			if ( tcp__port.isBound() ) { return true; }
			if ( new__size.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !remote__component.isValue() ) { return false; }
			if ( !remote__port.isValue() ) { return false; }
			if ( !ip__address.isValue() ) { return false; }
			if ( !tcp__port.isValue() ) { return false; }
			if ( !new__size.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__Misc otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.remote__component.operatorEquals( otherValue.remote__component ) ) { return false; }
			if ( !this.remote__port.operatorEquals( otherValue.remote__port ) ) { return false; }
			if ( !this.ip__address.operatorEquals( otherValue.ip__address ) ) { return false; }
			if ( !this.tcp__port.operatorEquals( otherValue.tcp__port ) ) { return false; }
			if ( !this.new__size.operatorEquals( otherValue.new__size ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc ) {
				return operatorEquals((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Misc", otherValue));
		}

		public Port__Misc_reason getreason() {
			return reason;
		}

		public Port__Misc_reason constGetreason() {
			return reason;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanInteger getremote__component() {
			return remote__component;
		}

		public TitanInteger constGetremote__component() {
			return remote__component;
		}

		public TitanCharString getremote__port() {
			return remote__port;
		}

		public TitanCharString constGetremote__port() {
			return remote__port;
		}

		public TitanCharString getip__address() {
			return ip__address;
		}

		public TitanCharString constGetip__address() {
			return ip__address;
		}

		public TitanInteger gettcp__port() {
			return tcp__port;
		}

		public TitanInteger constGettcp__port() {
			return tcp__port;
		}

		public TitanInteger getnew__size() {
			return new__size;
		}

		public TitanInteger constGetnew__size() {
			return new__size;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(7);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remote_component := ");
			remote__component.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remote_port := ");
			remote__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ip_address := ");
			ip__address.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" tcp_port := ");
			tcp__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" new_size := ");
			new__size.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Port_Misc has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getremote__component().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getremote__port().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getip__address().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettcp__port().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnew__size().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remote_component".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getremote__component().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remote_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getremote__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ip_address".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getip__address().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("tcp_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettcp__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("new_size".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnew__size().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_Misc: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Port_Misc");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (remote__component.isBound()) {
				remote__component.set_implicit_omit();
			}
			if (remote__port.isBound()) {
				remote__port.set_implicit_omit();
			}
			if (ip__address.isBound()) {
				ip__address.set_implicit_omit();
			}
			if (tcp__port.isBound()) {
				tcp__port.set_implicit_omit();
			}
			if (new__size.isBound()) {
				new__size.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			port__name.encode_text(text_buf);
			remote__component.encode_text(text_buf);
			remote__port.encode_text(text_buf);
			ip__address.encode_text(text_buf);
			tcp__port.encode_text(text_buf);
			new__size.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			port__name.decode_text(text_buf);
			remote__component.decode_text(text_buf);
			remote__port.decode_text(text_buf);
			ip__address.decode_text(text_buf);
			tcp__port.decode_text(text_buf);
			new__size.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__Misc_template extends Base_Template {

		private Port__Misc_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template port__name; //CharString_Type
		private TitanInteger_template remote__component; //Integer_Type
		private TitanCharString_template remote__port; //CharString_Type
		private TitanCharString_template ip__address; //CharString_Type
		private TitanInteger_template tcp__port; //Integer_Type
		private TitanInteger_template new__size; //Integer_Type
		//originally value_list/list_value
		private List<Port__Misc_template> list_value;

		public Port__Misc_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public Port__Misc_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return reason;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return port__name;
		}

		public TitanInteger_template getremote__component() {
			setSpecific();
			return remote__component;
		}

		public TitanInteger_template constGetremote__component() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remote_component of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return remote__component;
		}

		public TitanCharString_template getremote__port() {
			setSpecific();
			return remote__port;
		}

		public TitanCharString_template constGetremote__port() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field remote_port of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return remote__port;
		}

		public TitanCharString_template getip__address() {
			setSpecific();
			return ip__address;
		}

		public TitanCharString_template constGetip__address() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ip_address of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return ip__address;
		}

		public TitanInteger_template gettcp__port() {
			setSpecific();
			return tcp__port;
		}

		public TitanInteger_template constGettcp__port() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field tcp_port of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return tcp__port;
		}

		public TitanInteger_template getnew__size() {
			setSpecific();
			return new__size;
		}

		public TitanInteger_template constGetnew__size() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field new_size of a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			return new__size;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new Port__Misc_reason_template();
				port__name = new TitanCharString_template();
				remote__component = new TitanInteger_template();
				remote__port = new TitanCharString_template();
				ip__address = new TitanCharString_template();
				tcp__port = new TitanInteger_template();
				new__size = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
					remote__component.assign(template_sel.ANY_VALUE);
					remote__port.assign(template_sel.ANY_VALUE);
					ip__address.assign(template_sel.ANY_VALUE);
					tcp__port.assign(template_sel.ANY_VALUE);
					new__size.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Port__Misc_template() {
			// do nothing
		}

		public Port__Misc_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Port__Misc_template( final Port__Misc otherValue ) {
			copyValue(otherValue);
		}

		public Port__Misc_template( final Port__Misc_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Port__Misc_template( final Optional<Port__Misc> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_Misc from an unbound optional field.");
			}
		}

		//originally operator=
		public Port__Misc_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Port__Misc_template assign( final Port__Misc other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Port__Misc_template assign( final Port__Misc_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Port__Misc_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc) {
				return assign((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Misc_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__Misc_template) {
				return assign((Port__Misc_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc' can not be cast to {1}_template", otherValue));
		}

		public Port__Misc_template assign( final Optional<Port__Misc> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_Misc.");
			}
			return this;
		}

		private void copyValue(final Port__Misc other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getremote__component().isBound()) {
				getremote__component().assign(other_value.getremote__component());
			} else {
				getremote__component().cleanUp();
			}
			if (other_value.getremote__port().isBound()) {
				getremote__port().assign(other_value.getremote__port());
			} else {
				getremote__port().cleanUp();
			}
			if (other_value.getip__address().isBound()) {
				getip__address().assign(other_value.getip__address());
			} else {
				getip__address().cleanUp();
			}
			if (other_value.gettcp__port().isBound()) {
				gettcp__port().assign(other_value.gettcp__port());
			} else {
				gettcp__port().cleanUp();
			}
			if (other_value.getnew__size().isBound()) {
				getnew__size().assign(other_value.getnew__size());
			} else {
				getnew__size().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Port__Misc_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getremote__component().get_selection()) {
					getremote__component().cleanUp();
				} else {
					getremote__component().assign(other_value.getremote__component());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getremote__port().get_selection()) {
					getremote__port().cleanUp();
				} else {
					getremote__port().assign(other_value.getremote__port());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getip__address().get_selection()) {
					getip__address().cleanUp();
				} else {
					getip__address().assign(other_value.getip__address());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettcp__port().get_selection()) {
					gettcp__port().cleanUp();
				} else {
					gettcp__port().assign(other_value.gettcp__port());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnew__size().get_selection()) {
					getnew__size().cleanUp();
				} else {
					getnew__size().assign(other_value.getnew__size());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Port__Misc_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Port__Misc_template temp = new Port__Misc_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_Misc.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__Misc valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			final Port__Misc ret_val = new Port__Misc();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (remote__component.isBound()) {
				ret_val.getremote__component().assign(remote__component.valueOf());
			}
			if (remote__port.isBound()) {
				ret_val.getremote__port().assign(remote__port.valueOf());
			}
			if (ip__address.isBound()) {
				ret_val.getip__address().assign(ip__address.valueOf());
			}
			if (tcp__port.isBound()) {
				ret_val.gettcp__port().assign(tcp__port.valueOf());
			}
			if (new__size.isBound()) {
				ret_val.getnew__size().assign(new__size.valueOf());
			}
			return ret_val;
		}

		public Port__Misc_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_Misc.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_Misc.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_Misc.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__Misc_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__Misc_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (remote__component.isBound()) {
				return true;
			}
			if (remote__port.isBound()) {
				return true;
			}
			if (ip__address.isBound()) {
				return true;
			}
			if (tcp__port.isBound()) {
				return true;
			}
			if (new__size.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!remote__component.isValue()) {
				return false;
			}
			if (!remote__port.isValue()) {
				return false;
			}
			if (!ip__address.isValue()) {
				return false;
			}
			if (!tcp__port.isValue()) {
				return false;
			}
			if (!new__size.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__Misc other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__Misc other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getremote__component().isBound()) {
					return false;
				}
				if(!remote__component.match(other_value.getremote__component(), legacy)) {
					return false;
				}
				if(!other_value.getremote__port().isBound()) {
					return false;
				}
				if(!remote__port.match(other_value.getremote__port(), legacy)) {
					return false;
				}
				if(!other_value.getip__address().isBound()) {
					return false;
				}
				if(!ip__address.match(other_value.getip__address(), legacy)) {
					return false;
				}
				if(!other_value.gettcp__port().isBound()) {
					return false;
				}
				if(!tcp__port.match(other_value.gettcp__port(), legacy)) {
					return false;
				}
				if(!other_value.getnew__size().isBound()) {
					return false;
				}
				if(!new__size.match(other_value.getnew__size(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Port__Misc) {
				return match((Port__Misc)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__Misc.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(7);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remote_component := ");
				remote__component.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remote_port := ");
				remote__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ip_address := ");
				ip__address.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" tcp_port := ");
				tcp__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" new_size := ");
				new__size.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__Misc match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Misc) {
				log_match((Port__Misc)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.");
		}

		public void log_match(final Port__Misc match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remote__component.match(match_value.constGetremote__component(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remote_component");
							remote__component.log_match(match_value.constGetremote__component(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remote__port.match(match_value.constGetremote__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remote_port");
							remote__port.log_match(match_value.constGetremote__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ip__address.match(match_value.constGetip__address(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ip_address");
							ip__address.log_match(match_value.constGetip__address(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !tcp__port.match(match_value.constGettcp__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".tcp_port");
							tcp__port.log_match(match_value.constGettcp__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !new__size.match(match_value.constGetnew__size(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".new_size");
							new__size.log_match(match_value.constGetnew__size(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ remote_component := ");
				remote__component.log_match(match_value.constGetremote__component(), legacy);
				TTCN_Logger.log_event_str("{ remote_port := ");
				remote__port.log_match(match_value.constGetremote__port(), legacy);
				TTCN_Logger.log_event_str("{ ip_address := ");
				ip__address.log_match(match_value.constGetip__address(), legacy);
				TTCN_Logger.log_event_str("{ tcp_port := ");
				tcp__port.log_match(match_value.constGettcp__port(), legacy);
				TTCN_Logger.log_event_str("{ new_size := ");
				new__size.log_match(match_value.constGetnew__size(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				port__name.encode_text(text_buf);
				remote__component.encode_text(text_buf);
				remote__port.encode_text(text_buf);
				ip__address.encode_text(text_buf);
				tcp__port.encode_text(text_buf);
				new__size.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new Port__Misc_reason_template();
				reason.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				remote__component = new TitanInteger_template();
				remote__component.decode_text(text_buf);
				remote__port = new TitanCharString_template();
				remote__port.decode_text(text_buf);
				ip__address = new TitanCharString_template();
				ip__address.decode_text(text_buf);
				tcp__port = new TitanInteger_template();
				tcp__port.decode_text(text_buf);
				new__size = new TitanInteger_template();
				new__size.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__Misc_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__Misc_template temp = new Port__Misc_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Port_Misc has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getremote__component().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getremote__port().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getip__address().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettcp__port().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnew__size().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remote_component".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getremote__component().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("remote_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getremote__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ip_address".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getip__address().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("tcp_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettcp__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("new_size".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnew__size().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_Misc: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Port_Misc");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.remote__component.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.remote__port.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.ip__address.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.tcp__port.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				this.new__size.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Misc" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_Misc" : name));
		}
	}
	public static void Port__Misc_encoder(final Port__Misc input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_decoder( final TitanOctetString input_stream, final Port__Misc output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_ip__address_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_ip__address_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_ip__address_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_ip__address_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParallelPTC extends Base_Type {
		private final ParallelPTC_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString module__; //CharString_Type
		private final TitanCharString name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString compname; //CharString_Type
		private final TitanCharString tc__loc; //CharString_Type
		private final TitanInteger alive__pid; //Integer_Type
		private final TitanInteger status; //Integer_Type

		public ParallelPTC() {
			this.reason = new ParallelPTC_reason();
			this.module__ = new TitanCharString();
			this.name = new TitanCharString();
			this.compref = new TitanInteger();
			this.compname = new TitanCharString();
			this.tc__loc = new TitanCharString();
			this.alive__pid = new TitanInteger();
			this.status = new TitanInteger();
		}

		public ParallelPTC(final ParallelPTC_reason reason, final TitanCharString module__, final TitanCharString name, final TitanInteger compref, final TitanCharString compname, final TitanCharString tc__loc, final TitanInteger alive__pid, final TitanInteger status ) {
			this.reason = new ParallelPTC_reason( reason );
			this.module__ = new TitanCharString( module__ );
			this.name = new TitanCharString( name );
			this.compref = new TitanInteger( compref );
			this.compname = new TitanCharString( compname );
			this.tc__loc = new TitanCharString( tc__loc );
			this.alive__pid = new TitanInteger( alive__pid );
			this.status = new TitanInteger( status );
		}

		public ParallelPTC( final ParallelPTC otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParallelPTC.");
			}
			reason = new ParallelPTC_reason();
			module__ = new TitanCharString();
			name = new TitanCharString();
			compref = new TitanInteger();
			compname = new TitanCharString();
			tc__loc = new TitanCharString();
			alive__pid = new TitanInteger();
			status = new TitanInteger();
			assign( otherValue );
		}

		public ParallelPTC assign(final ParallelPTC otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParallelPTC");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getmodule__().isBound() ) {
					this.module__.assign( otherValue.getmodule__() );
				} else {
					this.module__.cleanUp();
				}
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getcompname().isBound() ) {
					this.compname.assign( otherValue.getcompname() );
				} else {
					this.compname.cleanUp();
				}
				if ( otherValue.gettc__loc().isBound() ) {
					this.tc__loc.assign( otherValue.gettc__loc() );
				} else {
					this.tc__loc.cleanUp();
				}
				if ( otherValue.getalive__pid().isBound() ) {
					this.alive__pid.assign( otherValue.getalive__pid() );
				} else {
					this.alive__pid.cleanUp();
				}
				if ( otherValue.getstatus().isBound() ) {
					this.status.assign( otherValue.getstatus() );
				} else {
					this.status.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParallelPTC assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC ) {
				return assign((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelPTC", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			module__.cleanUp();
			name.cleanUp();
			compref.cleanUp();
			compname.cleanUp();
			tc__loc.cleanUp();
			alive__pid.cleanUp();
			status.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( module__.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( compname.isBound() ) { return true; }
			if ( tc__loc.isBound() ) { return true; }
			if ( alive__pid.isBound() ) { return true; }
			if ( status.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !module__.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !compname.isValue() ) { return false; }
			if ( !tc__loc.isValue() ) { return false; }
			if ( !alive__pid.isValue() ) { return false; }
			if ( !status.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParallelPTC otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.module__.operatorEquals( otherValue.module__ ) ) { return false; }
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.compname.operatorEquals( otherValue.compname ) ) { return false; }
			if ( !this.tc__loc.operatorEquals( otherValue.tc__loc ) ) { return false; }
			if ( !this.alive__pid.operatorEquals( otherValue.alive__pid ) ) { return false; }
			if ( !this.status.operatorEquals( otherValue.status ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC ) {
				return operatorEquals((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelPTC", otherValue));
		}

		public ParallelPTC_reason getreason() {
			return reason;
		}

		public ParallelPTC_reason constGetreason() {
			return reason;
		}

		public TitanCharString getmodule__() {
			return module__;
		}

		public TitanCharString constGetmodule__() {
			return module__;
		}

		public TitanCharString getname() {
			return name;
		}

		public TitanCharString constGetname() {
			return name;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanCharString getcompname() {
			return compname;
		}

		public TitanCharString constGetcompname() {
			return compname;
		}

		public TitanCharString gettc__loc() {
			return tc__loc;
		}

		public TitanCharString constGettc__loc() {
			return tc__loc;
		}

		public TitanInteger getalive__pid() {
			return alive__pid;
		}

		public TitanInteger constGetalive__pid() {
			return alive__pid;
		}

		public TitanInteger getstatus() {
			return status;
		}

		public TitanInteger constGetstatus() {
			return status;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(8);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" module_ := ");
			module__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compname := ");
			compname.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" tc_loc := ");
			tc__loc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" alive_pid := ");
			alive__pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" status := ");
			status.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 8) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ParallelPTC has 8 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompname().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettc__loc().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getalive__pid().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstatus().set_param(param.get_elem(7));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compname".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("tc_loc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettc__loc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("alive_pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getalive__pid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("status".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstatus().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParallelPTC: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ParallelPTC");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (module__.isBound()) {
				module__.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (compname.isBound()) {
				compname.set_implicit_omit();
			}
			if (tc__loc.isBound()) {
				tc__loc.set_implicit_omit();
			}
			if (alive__pid.isBound()) {
				alive__pid.set_implicit_omit();
			}
			if (status.isBound()) {
				status.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			module__.encode_text(text_buf);
			name.encode_text(text_buf);
			compref.encode_text(text_buf);
			compname.encode_text(text_buf);
			tc__loc.encode_text(text_buf);
			alive__pid.encode_text(text_buf);
			status.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			module__.decode_text(text_buf);
			name.decode_text(text_buf);
			compref.decode_text(text_buf);
			compname.decode_text(text_buf);
			tc__loc.decode_text(text_buf);
			alive__pid.decode_text(text_buf);
			status.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParallelPTC_template extends Base_Template {

		private ParallelPTC_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template module__; //CharString_Type
		private TitanCharString_template name; //CharString_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanCharString_template compname; //CharString_Type
		private TitanCharString_template tc__loc; //CharString_Type
		private TitanInteger_template alive__pid; //Integer_Type
		private TitanInteger_template status; //Integer_Type
		//originally value_list/list_value
		private List<ParallelPTC_template> list_value;

		public ParallelPTC_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public ParallelPTC_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return reason;
		}

		public TitanCharString_template getmodule__() {
			setSpecific();
			return module__;
		}

		public TitanCharString_template constGetmodule__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field module_ of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return module__;
		}

		public TitanCharString_template getname() {
			setSpecific();
			return name;
		}

		public TitanCharString_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return name;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return compref;
		}

		public TitanCharString_template getcompname() {
			setSpecific();
			return compname;
		}

		public TitanCharString_template constGetcompname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compname of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return compname;
		}

		public TitanCharString_template gettc__loc() {
			setSpecific();
			return tc__loc;
		}

		public TitanCharString_template constGettc__loc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field tc_loc of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return tc__loc;
		}

		public TitanInteger_template getalive__pid() {
			setSpecific();
			return alive__pid;
		}

		public TitanInteger_template constGetalive__pid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field alive_pid of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return alive__pid;
		}

		public TitanInteger_template getstatus() {
			setSpecific();
			return status;
		}

		public TitanInteger_template constGetstatus() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field status of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			return status;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new ParallelPTC_reason_template();
				module__ = new TitanCharString_template();
				name = new TitanCharString_template();
				compref = new TitanInteger_template();
				compname = new TitanCharString_template();
				tc__loc = new TitanCharString_template();
				alive__pid = new TitanInteger_template();
				status = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					module__.assign(template_sel.ANY_VALUE);
					name.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					compname.assign(template_sel.ANY_VALUE);
					tc__loc.assign(template_sel.ANY_VALUE);
					alive__pid.assign(template_sel.ANY_VALUE);
					status.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ParallelPTC_template() {
			// do nothing
		}

		public ParallelPTC_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ParallelPTC_template( final ParallelPTC otherValue ) {
			copyValue(otherValue);
		}

		public ParallelPTC_template( final ParallelPTC_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ParallelPTC_template( final Optional<ParallelPTC> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ParallelPTC from an unbound optional field.");
			}
		}

		//originally operator=
		public ParallelPTC_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ParallelPTC_template assign( final ParallelPTC other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ParallelPTC_template assign( final ParallelPTC_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ParallelPTC_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC) {
				return assign((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC' can not be cast to {1}", otherValue));
		}

		@Override
		public ParallelPTC_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParallelPTC_template) {
				return assign((ParallelPTC_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC' can not be cast to {1}_template", otherValue));
		}

		public ParallelPTC_template assign( final Optional<ParallelPTC> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParallelPTC.");
			}
			return this;
		}

		private void copyValue(final ParallelPTC other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getmodule__().isBound()) {
				getmodule__().assign(other_value.getmodule__());
			} else {
				getmodule__().cleanUp();
			}
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getcompname().isBound()) {
				getcompname().assign(other_value.getcompname());
			} else {
				getcompname().cleanUp();
			}
			if (other_value.gettc__loc().isBound()) {
				gettc__loc().assign(other_value.gettc__loc());
			} else {
				gettc__loc().cleanUp();
			}
			if (other_value.getalive__pid().isBound()) {
				getalive__pid().assign(other_value.getalive__pid());
			} else {
				getalive__pid().cleanUp();
			}
			if (other_value.getstatus().isBound()) {
				getstatus().assign(other_value.getstatus());
			} else {
				getstatus().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ParallelPTC_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmodule__().get_selection()) {
					getmodule__().cleanUp();
				} else {
					getmodule__().assign(other_value.getmodule__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompname().get_selection()) {
					getcompname().cleanUp();
				} else {
					getcompname().assign(other_value.getcompname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettc__loc().get_selection()) {
					gettc__loc().cleanUp();
				} else {
					gettc__loc().assign(other_value.gettc__loc());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getalive__pid().get_selection()) {
					getalive__pid().cleanUp();
				} else {
					getalive__pid().assign(other_value.getalive__pid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getstatus().get_selection()) {
					getstatus().cleanUp();
				} else {
					getstatus().assign(other_value.getstatus());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ParallelPTC_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ParallelPTC_template temp = new ParallelPTC_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParallelPTC.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParallelPTC valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			final ParallelPTC ret_val = new ParallelPTC();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (module__.isBound()) {
				ret_val.getmodule__().assign(module__.valueOf());
			}
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (compname.isBound()) {
				ret_val.getcompname().assign(compname.valueOf());
			}
			if (tc__loc.isBound()) {
				ret_val.gettc__loc().assign(tc__loc.valueOf());
			}
			if (alive__pid.isBound()) {
				ret_val.getalive__pid().assign(alive__pid.valueOf());
			}
			if (status.isBound()) {
				ret_val.getstatus().assign(status.valueOf());
			}
			return ret_val;
		}

		public ParallelPTC_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParallelPTC.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParallelPTC.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParallelPTC.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParallelPTC_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParallelPTC_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (module__.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (compname.isBound()) {
				return true;
			}
			if (tc__loc.isBound()) {
				return true;
			}
			if (alive__pid.isBound()) {
				return true;
			}
			if (status.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!module__.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!compname.isValue()) {
				return false;
			}
			if (!tc__loc.isValue()) {
				return false;
			}
			if (!alive__pid.isValue()) {
				return false;
			}
			if (!status.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParallelPTC other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParallelPTC other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getmodule__().isBound()) {
					return false;
				}
				if(!module__.match(other_value.getmodule__(), legacy)) {
					return false;
				}
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getcompname().isBound()) {
					return false;
				}
				if(!compname.match(other_value.getcompname(), legacy)) {
					return false;
				}
				if(!other_value.gettc__loc().isBound()) {
					return false;
				}
				if(!tc__loc.match(other_value.gettc__loc(), legacy)) {
					return false;
				}
				if(!other_value.getalive__pid().isBound()) {
					return false;
				}
				if(!alive__pid.match(other_value.getalive__pid(), legacy)) {
					return false;
				}
				if(!other_value.getstatus().isBound()) {
					return false;
				}
				if(!status.match(other_value.getstatus(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ParallelPTC) {
				return match((ParallelPTC)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelPTC.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(8);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" module_ := ");
				module__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compname := ");
				compname.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" tc_loc := ");
				tc__loc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" alive_pid := ");
				alive__pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" status := ");
				status.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParallelPTC match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelPTC) {
				log_match((ParallelPTC)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.");
		}

		public void log_match(final ParallelPTC match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !module__.match(match_value.constGetmodule__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".module_");
							module__.log_match(match_value.constGetmodule__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compname.match(match_value.constGetcompname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compname");
							compname.log_match(match_value.constGetcompname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !tc__loc.match(match_value.constGettc__loc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".tc_loc");
							tc__loc.log_match(match_value.constGettc__loc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !alive__pid.match(match_value.constGetalive__pid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".alive_pid");
							alive__pid.log_match(match_value.constGetalive__pid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !status.match(match_value.constGetstatus(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".status");
							status.log_match(match_value.constGetstatus(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ module_ := ");
				module__.log_match(match_value.constGetmodule__(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ compname := ");
				compname.log_match(match_value.constGetcompname(), legacy);
				TTCN_Logger.log_event_str("{ tc_loc := ");
				tc__loc.log_match(match_value.constGettc__loc(), legacy);
				TTCN_Logger.log_event_str("{ alive_pid := ");
				alive__pid.log_match(match_value.constGetalive__pid(), legacy);
				TTCN_Logger.log_event_str("{ status := ");
				status.log_match(match_value.constGetstatus(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				module__.encode_text(text_buf);
				name.encode_text(text_buf);
				compref.encode_text(text_buf);
				compname.encode_text(text_buf);
				tc__loc.encode_text(text_buf);
				alive__pid.encode_text(text_buf);
				status.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ParallelPTC_reason_template();
				reason.decode_text(text_buf);
				module__ = new TitanCharString_template();
				module__.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				compname = new TitanCharString_template();
				compname.decode_text(text_buf);
				tc__loc = new TitanCharString_template();
				tc__loc.decode_text(text_buf);
				alive__pid = new TitanInteger_template();
				alive__pid.decode_text(text_buf);
				status = new TitanInteger_template();
				status.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParallelPTC_template>(size);
				for (int i = 0; i < size; i++) {
					final ParallelPTC_template temp = new ParallelPTC_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 8) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ParallelPTC has 8 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompname().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettc__loc().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getalive__pid().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstatus().set_param(param.get_elem(7));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compname".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("tc_loc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettc__loc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("alive_pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getalive__pid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("status".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstatus().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParallelPTC: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ParallelPTC");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.module__.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.compname.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.tc__loc.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.alive__pid.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				this.status.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelPTC" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParallelPTC" : name));
		}
	}
	public static void ParallelPTC_encoder(final ParallelPTC input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_decoder( final TitanOctetString input_stream, final ParallelPTC output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class LocationInfo_ent__type extends Base_Type {
		public enum enum_type {
			unknown (0),
			controlpart (1),
			testcase__ (2),
			altstep__ (3),
			function__ (4),
			external__function (5),
			template__ (6),
			UNKNOWN_VALUE(7),
			UNBOUND_VALUE(8);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return unknown;
				case 1:  return controlpart;
				case 2:  return testcase__;
				case 3:  return altstep__;
				case 4:  return function__;
				case 5:  return external__function;
				case 6:  return template__;
				case 7:  return UNKNOWN_VALUE;
				case 8:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public LocationInfo_ent__type() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public LocationInfo_ent__type(final LocationInfo_ent__type otherValue) {
			enum_value = otherValue.enum_value;
		}

		public LocationInfo_ent__type(final LocationInfo_ent__type.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public LocationInfo_ent__type(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `LocationInfo_ent__type' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public LocationInfo_ent__type assign(final LocationInfo_ent__type otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public LocationInfo_ent__type assign(final Base_Type otherValue){
			if( otherValue instanceof LocationInfo_ent__type ) {
				return assign((LocationInfo_ent__type) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public LocationInfo_ent__type assign(final LocationInfo_ent__type.enum_type otherValue){
			return assign( new LocationInfo_ent__type(otherValue) );
		}

		//originally operator=
		public LocationInfo_ent__type assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `LocationInfo_ent__type'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final LocationInfo_ent__type otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof LocationInfo_ent__type) {
				return operatorEquals( (LocationInfo_ent__type) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.ent_type.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final LocationInfo_ent__type.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final LocationInfo_ent__type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final LocationInfo_ent__type.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final LocationInfo_ent__type.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final LocationInfo_ent__type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final LocationInfo_ent__type.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final LocationInfo_ent__type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final LocationInfo_ent__type.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final LocationInfo_ent__type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final LocationInfo_ent__type.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final LocationInfo_ent__type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final LocationInfo_ent__type.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final LocationInfo_ent__type enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("unknown".equals(strPar)) {
				return enum_type.unknown;
			}
			if ("controlpart".equals(strPar)) {
				return enum_type.controlpart;
			}
			if ("testcase__".equals(strPar) || "testcase_".equals(strPar)) {
				return enum_type.testcase__;
			}
			if ("altstep__".equals(strPar) || "altstep_".equals(strPar)) {
				return enum_type.altstep__;
			}
			if ("function__".equals(strPar) || "function_".equals(strPar)) {
				return enum_type.function__;
			}
			if ("external__function".equals(strPar) || "external_function".equals(strPar)) {
				return enum_type.external__function;
			}
			if ("template__".equals(strPar) || "template_".equals(strPar)) {
				return enum_type.template__;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.LocationInfo.ent_type");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.LocationInfo.ent_type.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.LocationInfo.ent_type.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class LocationInfo_ent__type_template extends Base_Template {
		// single_value
		private LocationInfo_ent__type.enum_type single_value;
		// value_list part
		private ArrayList<LocationInfo_ent__type_template> value_list;

		private void copy_template(final LocationInfo_ent__type_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<LocationInfo_ent__type_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final LocationInfo_ent__type_template temp = new LocationInfo_ent__type_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type LocationInfo_ent__type.");
			}
		}

		public LocationInfo_ent__type_template() {
			// do nothing
		}

		public LocationInfo_ent__type_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public LocationInfo_ent__type_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!LocationInfo_ent__type.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type LocationInfo_ent__type with unknown numeric value "+ otherValue +".");
			}
			single_value = LocationInfo_ent__type.enum_type.getValue(otherValue);
		}

		public LocationInfo_ent__type_template(final LocationInfo_ent__type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == LocationInfo_ent__type.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type LocationInfo_ent__type. ");
			}
			single_value = otherValue.enum_value;
		}

		public LocationInfo_ent__type_template(final LocationInfo_ent__type_template otherValue) {
			copy_template(otherValue);
		}

		public LocationInfo_ent__type_template(final LocationInfo_ent__type.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != LocationInfo_ent__type.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public LocationInfo_ent__type_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public LocationInfo_ent__type_template assign(final int otherValue) {
			if (!LocationInfo_ent__type.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type LocationInfo_ent__type.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public LocationInfo_ent__type_template assign(final LocationInfo_ent__type.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public LocationInfo_ent__type_template assign(final LocationInfo_ent__type_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public LocationInfo_ent__type_template assign(final LocationInfo_ent__type otherValue){
			if (otherValue.enum_value == LocationInfo_ent__type.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type LocationInfo_ent__type to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public LocationInfo_ent__type_template assign(final Base_Type otherValue){
			if( otherValue instanceof LocationInfo_ent__type ) {
				return assign((LocationInfo_ent__type) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
		}

		@Override
		public LocationInfo_ent__type_template assign(final Base_Template otherValue){
			if( otherValue instanceof LocationInfo_ent__type_template ) {
				return assign((LocationInfo_ent__type_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final LocationInfo_ent__type.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final LocationInfo_ent__type.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type LocationInfo_ent__type.");
			}
		}

		// originally match
		public boolean match(final LocationInfo_ent__type otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final LocationInfo_ent__type otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof LocationInfo_ent__type ) {
				return match((LocationInfo_ent__type) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
		}

		public LocationInfo_ent__type valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type LocationInfo_ent__type.");
			}
			return new LocationInfo_ent__type(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type LocationInfo_ent__type.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<LocationInfo_ent__type_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new LocationInfo_ent__type_template());
			}
		}

		public LocationInfo_ent__type_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type LocationInfo_ent__type.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type LocationInfo_ent__type.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type LocationInfo_ent__type.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(LocationInfo_ent__type.enum2str(single_value), LocationInfo_ent__type.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LocationInfo_ent__type) {
				log_match((LocationInfo_ent__type)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.ent_type.");
		}
		public void log_match(final LocationInfo_ent__type match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final LocationInfo_ent__type.enum_type enum_value = LocationInfo_ent__type.str_to_enum(param.get_enumerated());
				if (!LocationInfo_ent__type.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.LocationInfo.ent_type.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.LocationInfo.ent_type");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!LocationInfo_ent__type.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.LocationInfo.ent_type.", temp));
				}
				single_value = LocationInfo_ent__type.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<LocationInfo_ent__type_template>(size);
				for (int i = 0; i < size; i++) {
					final LocationInfo_ent__type_template temp = new LocationInfo_ent__type_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.LocationInfo.ent_type" : name));
		}
	}
	public static void LocationInfo_ent__type_encoder(final LocationInfo_ent__type input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo.ent_type' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LocationInfo_ent__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LocationInfo_ent__type_decoder( final TitanOctetString input_stream, final LocationInfo_ent__type output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo.ent_type' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LocationInfo_ent__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_operation_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_operation_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_inconc___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_inconc___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_inconc___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_inconc___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_parallelEvent_encoder(final ParallelEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_parallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_parallelEvent_decoder( final TitanOctetString input_stream, final ParallelEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_parallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TestcaseEvent_choice_testcaseFinished_encoder(final TestcaseType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseEvent_choice_testcaseFinished_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseEvent_choice_testcaseFinished_decoder( final TitanOctetString input_stream, final TestcaseType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseEvent_choice_testcaseFinished_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_remote__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_remote__port_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_remote__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_remote__port_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanSingleLogEvent_entityId_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanSingleLogEvent_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanSingleLogEvent_entityId_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanSingleLogEvent_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__out_operation_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_operation_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorConfigdata_param___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorConfigdata_param___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorConfigdata_param___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorConfigdata_param___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PTC__exit_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PTC__exit_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PTC__exit_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PTC__exit_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingTimeout extends Base_Type {
		private final Optional<TitanCharString> timer__name; //CharString_Type

		public MatchingTimeout() {
			this.timer__name = new Optional<TitanCharString>(TitanCharString.class);
		}

		public MatchingTimeout(final Optional<TitanCharString> timer__name ) {
			this.timer__name = new Optional<TitanCharString>(TitanCharString.class);
			this.timer__name.assign( timer__name );
		}

		public MatchingTimeout( final MatchingTimeout otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingTimeout.");
			}
			timer__name = new Optional<TitanCharString>(TitanCharString.class);
			assign( otherValue );
		}

		public MatchingTimeout assign(final MatchingTimeout otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingTimeout");
			}

			if (otherValue != this) {
				if ( otherValue.gettimer__name().isBound() ) {
					this.timer__name.assign( otherValue.gettimer__name() );
				} else {
					this.timer__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingTimeout assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout ) {
				return assign((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingTimeout", otherValue));
		}

		public void cleanUp() {
			timer__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( optional_sel.OPTIONAL_OMIT.equals(timer__name.get_selection()) || timer__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !optional_sel.OPTIONAL_OMIT.equals(timer__name.get_selection()) && !timer__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingTimeout otherValue) {
			if ( !this.timer__name.operatorEquals( otherValue.timer__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout ) {
				return operatorEquals((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingTimeout", otherValue));
		}

		public Optional<TitanCharString> gettimer__name() {
			return timer__name;
		}

		public Optional<TitanCharString> constGettimer__name() {
			return timer__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 0;
			if (timer__name.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" timer_name := ");
			timer__name.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingTimeout has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettimer__name().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("timer_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettimer__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingTimeout: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingTimeout");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (timer__name.isBound()) {
				timer__name.set_implicit_omit();
			} else {
				timer__name.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			timer__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			timer__name.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingTimeout_template extends Base_Template {

		private TitanCharString_template timer__name; //CharString_Type
		//originally value_list/list_value
		private List<MatchingTimeout_template> list_value;

		public TitanCharString_template gettimer__name() {
			setSpecific();
			return timer__name;
		}

		public TitanCharString_template constGettimer__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field timer_name of a non-specific template of type @TitanLoggerApi.MatchingTimeout.");
			}
			return timer__name;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				timer__name = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					timer__name.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public MatchingTimeout_template() {
			// do nothing
		}

		public MatchingTimeout_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingTimeout_template( final MatchingTimeout otherValue ) {
			copyValue(otherValue);
		}

		public MatchingTimeout_template( final MatchingTimeout_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingTimeout_template( final Optional<MatchingTimeout> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingTimeout from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingTimeout_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingTimeout_template assign( final MatchingTimeout other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingTimeout_template assign( final MatchingTimeout_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingTimeout_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout) {
				return assign((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingTimeout' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingTimeout_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingTimeout_template) {
				return assign((MatchingTimeout_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingTimeout' can not be cast to {1}_template", otherValue));
		}

		public MatchingTimeout_template assign( final Optional<MatchingTimeout> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingTimeout.");
			}
			return this;
		}

		private void copyValue(final MatchingTimeout other_value) {
			if (other_value.gettimer__name().isBound()) {
				if (other_value.gettimer__name().isPresent()) {
					gettimer__name().assign(other_value.gettimer__name().get());
				} else {
					gettimer__name().assign(template_sel.OMIT_VALUE);
				}
			} else {
				gettimer__name().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingTimeout_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettimer__name().get_selection()) {
					gettimer__name().cleanUp();
				} else {
					gettimer__name().assign(other_value.gettimer__name());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingTimeout_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingTimeout_template temp = new MatchingTimeout_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingTimeout.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingTimeout valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingTimeout.");
			}
			final MatchingTimeout ret_val = new MatchingTimeout();
			if (timer__name.isOmit()) {
				ret_val.gettimer__name().assign(template_sel.OMIT_VALUE);
			} else if (timer__name.isBound()) {
				ret_val.gettimer__name().assign(timer__name.valueOf());
			}
			return ret_val;
		}

		public MatchingTimeout_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingTimeout.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingTimeout.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingTimeout.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingTimeout_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingTimeout_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (timer__name.isOmit() || timer__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!timer__name.isOmit() && !timer__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingTimeout other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingTimeout other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.gettimer__name().isBound()) {
					return false;
				}
				if((other_value.gettimer__name().isPresent() ? !timer__name.match(other_value.gettimer__name().get(), legacy) : !timer__name.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingTimeout) {
				return match((MatchingTimeout)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingTimeout.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (timer__name.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" timer_name := ");
				timer__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingTimeout match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingTimeout) {
				log_match((MatchingTimeout)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingTimeout.");
		}

		public void log_match(final MatchingTimeout match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGettimer__name().isPresent()) {
							if( !timer__name.match(match_value.constGettimer__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".timer_name");
								timer__name.log_match(match_value.constGettimer__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!timer__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".timer_name := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								timer__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ timer_name := ");
				timer__name.log_match(match_value.constGettimer__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timer__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timer__name = new TitanCharString_template();
				timer__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingTimeout_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingTimeout_template temp = new MatchingTimeout_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingTimeout has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettimer__name().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("timer_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettimer__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingTimeout: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingTimeout");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.timer__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingTimeout" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingTimeout" : name));
		}
	}
	public static void MatchingTimeout_encoder(final MatchingTimeout input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingTimeout_decoder( final TitanOctetString input_stream, final MatchingTimeout output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class VerdictOp extends Base_Type {
		private final VerdictOp_choice choice; //TTCN3_Choice_Type

		public VerdictOp() {
			this.choice = new VerdictOp_choice();
		}

		public VerdictOp(final VerdictOp_choice choice ) {
			this.choice = new VerdictOp_choice( choice );
		}

		public VerdictOp( final VerdictOp otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.VerdictOp.");
			}
			choice = new VerdictOp_choice();
			assign( otherValue );
		}

		public VerdictOp assign(final VerdictOp otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.VerdictOp");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public VerdictOp assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp ) {
				return assign((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictOp", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final VerdictOp otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp ) {
				return operatorEquals((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictOp", otherValue));
		}

		public VerdictOp_choice getchoice() {
			return choice;
		}

		public VerdictOp_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.VerdictOp has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.VerdictOp: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.VerdictOp");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class VerdictOp_template extends Base_Template {

		private VerdictOp_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<VerdictOp_template> list_value;

		public VerdictOp_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public VerdictOp_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.VerdictOp.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new VerdictOp_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public VerdictOp_template() {
			// do nothing
		}

		public VerdictOp_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public VerdictOp_template( final VerdictOp otherValue ) {
			copyValue(otherValue);
		}

		public VerdictOp_template( final VerdictOp_template otherValue ) {
			copyTemplate( otherValue );
		}

		public VerdictOp_template( final Optional<VerdictOp> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.VerdictOp from an unbound optional field.");
			}
		}

		//originally operator=
		public VerdictOp_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public VerdictOp_template assign( final VerdictOp other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public VerdictOp_template assign( final VerdictOp_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public VerdictOp_template assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp) {
				return assign((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictOp' can not be cast to {1}", otherValue));
		}

		@Override
		public VerdictOp_template assign(final Base_Template otherValue) {
			if (otherValue instanceof VerdictOp_template) {
				return assign((VerdictOp_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictOp' can not be cast to {1}_template", otherValue));
		}

		public VerdictOp_template assign( final Optional<VerdictOp> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.VerdictOp.");
			}
			return this;
		}

		private void copyValue(final VerdictOp other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final VerdictOp_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<VerdictOp_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final VerdictOp_template temp = new VerdictOp_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.VerdictOp.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public VerdictOp valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.VerdictOp.");
			}
			final VerdictOp ret_val = new VerdictOp();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public VerdictOp_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.VerdictOp.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.VerdictOp.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.VerdictOp.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<VerdictOp_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new VerdictOp_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final VerdictOp other_value) {
			return match(other_value, false);
		}

		public boolean match(final VerdictOp other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof VerdictOp) {
				return match((VerdictOp)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictOp.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final VerdictOp match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof VerdictOp) {
				log_match((VerdictOp)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.");
		}

		public void log_match(final VerdictOp match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new VerdictOp_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<VerdictOp_template>(size);
				for (int i = 0; i < size; i++) {
					final VerdictOp_template temp = new VerdictOp_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.VerdictOp has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.VerdictOp: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.VerdictOp");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictOp" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.VerdictOp" : name));
		}
	}
	public static void VerdictOp_encoder(final VerdictOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictOp_decoder( final TitanOctetString input_stream, final VerdictOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingProblemType_reason extends Base_Type {
		public enum enum_type {
			port__not__started__and__queue__empty (0),
			no__incoming__types (1),
			no__incoming__signatures (2),
			no__outgoing__blocking__signatures (3),
			no__outgoing__blocking__signatures__that__support__exceptions (4),
			component__has__no__ports (5),
			UNKNOWN_VALUE(6),
			UNBOUND_VALUE(7);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return port__not__started__and__queue__empty;
				case 1:  return no__incoming__types;
				case 2:  return no__incoming__signatures;
				case 3:  return no__outgoing__blocking__signatures;
				case 4:  return no__outgoing__blocking__signatures__that__support__exceptions;
				case 5:  return component__has__no__ports;
				case 6:  return UNKNOWN_VALUE;
				case 7:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public MatchingProblemType_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public MatchingProblemType_reason(final MatchingProblemType_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public MatchingProblemType_reason(final MatchingProblemType_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public MatchingProblemType_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingProblemType_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public MatchingProblemType_reason assign(final MatchingProblemType_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public MatchingProblemType_reason assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingProblemType_reason ) {
				return assign((MatchingProblemType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public MatchingProblemType_reason assign(final MatchingProblemType_reason.enum_type otherValue){
			return assign( new MatchingProblemType_reason(otherValue) );
		}

		//originally operator=
		public MatchingProblemType_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingProblemType_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final MatchingProblemType_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof MatchingProblemType_reason) {
				return operatorEquals( (MatchingProblemType_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final MatchingProblemType_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingProblemType_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingProblemType_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final MatchingProblemType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final MatchingProblemType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingProblemType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingProblemType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingProblemType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingProblemType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingProblemType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingProblemType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final MatchingProblemType_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final MatchingProblemType_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("port__not__started__and__queue__empty".equals(strPar) || "port_not_started_and_queue_empty".equals(strPar)) {
				return enum_type.port__not__started__and__queue__empty;
			}
			if ("no__incoming__types".equals(strPar) || "no_incoming_types".equals(strPar)) {
				return enum_type.no__incoming__types;
			}
			if ("no__incoming__signatures".equals(strPar) || "no_incoming_signatures".equals(strPar)) {
				return enum_type.no__incoming__signatures;
			}
			if ("no__outgoing__blocking__signatures".equals(strPar) || "no_outgoing_blocking_signatures".equals(strPar)) {
				return enum_type.no__outgoing__blocking__signatures;
			}
			if ("no__outgoing__blocking__signatures__that__support__exceptions".equals(strPar) || "no_outgoing_blocking_signatures_that_support_exceptions".equals(strPar)) {
				return enum_type.no__outgoing__blocking__signatures__that__support__exceptions;
			}
			if ("component__has__no__ports".equals(strPar) || "component_has_no_ports".equals(strPar)) {
				return enum_type.component__has__no__ports;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.MatchingProblemType.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingProblemType.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingProblemType_reason_template extends Base_Template {
		// single_value
		private MatchingProblemType_reason.enum_type single_value;
		// value_list part
		private ArrayList<MatchingProblemType_reason_template> value_list;

		private void copy_template(final MatchingProblemType_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingProblemType_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final MatchingProblemType_reason_template temp = new MatchingProblemType_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingProblemType_reason.");
			}
		}

		public MatchingProblemType_reason_template() {
			// do nothing
		}

		public MatchingProblemType_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public MatchingProblemType_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!MatchingProblemType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type MatchingProblemType_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = MatchingProblemType_reason.enum_type.getValue(otherValue);
		}

		public MatchingProblemType_reason_template(final MatchingProblemType_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == MatchingProblemType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingProblemType_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public MatchingProblemType_reason_template(final MatchingProblemType_reason_template otherValue) {
			copy_template(otherValue);
		}

		public MatchingProblemType_reason_template(final MatchingProblemType_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != MatchingProblemType_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public MatchingProblemType_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public MatchingProblemType_reason_template assign(final int otherValue) {
			if (!MatchingProblemType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingProblemType_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public MatchingProblemType_reason_template assign(final MatchingProblemType_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public MatchingProblemType_reason_template assign(final MatchingProblemType_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public MatchingProblemType_reason_template assign(final MatchingProblemType_reason otherValue){
			if (otherValue.enum_value == MatchingProblemType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type MatchingProblemType_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public MatchingProblemType_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingProblemType_reason ) {
				return assign((MatchingProblemType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingProblemType_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof MatchingProblemType_reason_template ) {
				return assign((MatchingProblemType_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final MatchingProblemType_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final MatchingProblemType_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingProblemType_reason.");
			}
		}

		// originally match
		public boolean match(final MatchingProblemType_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final MatchingProblemType_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof MatchingProblemType_reason ) {
				return match((MatchingProblemType_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
		}

		public MatchingProblemType_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingProblemType_reason.");
			}
			return new MatchingProblemType_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingProblemType_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<MatchingProblemType_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingProblemType_reason_template());
			}
		}

		public MatchingProblemType_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingProblemType_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type MatchingProblemType_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type MatchingProblemType_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(MatchingProblemType_reason.enum2str(single_value), MatchingProblemType_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingProblemType_reason) {
				log_match((MatchingProblemType_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.reason.");
		}
		public void log_match(final MatchingProblemType_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final MatchingProblemType_reason.enum_type enum_value = MatchingProblemType_reason.str_to_enum(param.get_enumerated());
				if (!MatchingProblemType_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingProblemType.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.MatchingProblemType.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!MatchingProblemType_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.reason.", temp));
				}
				single_value = MatchingProblemType_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingProblemType_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingProblemType_reason_template temp = new MatchingProblemType_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingProblemType.reason" : name));
		}
	}
	public static void MatchingProblemType_reason_encoder(final MatchingProblemType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_reason_decoder( final TitanOctetString input_stream, final MatchingProblemType_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Queue_param___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_param___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_param___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_param___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorRuntime_reason extends Base_Type {
		public enum enum_type {
			connected__to__mc (0),
			disconnected__from__mc (1),
			initialization__of__modules__failed (2),
			exit__requested__from__mc__hc (3),
			exit__requested__from__mc__mtc (4),
			stop__was__requested__from__mc__ignored__on__idle__mtc (5),
			stop__was__requested__from__mc (6),
			stop__was__requested__from__mc__ignored__on__idle__ptc (7),
			executing__testcase__in__module (8),
			performing__error__recovery (9),
			initializing__module (10),
			initialization__of__module__finished (11),
			stopping__current__testcase (12),
			exiting (13),
			host__controller__started (14),
			host__controller__finished (15),
			stopping__control__part__execution (16),
			stopping__test__component__execution (17),
			waiting__for__ptcs__to__finish (18),
			user__paused__waiting__to__resume (19),
			resuming__execution (20),
			terminating__execution (21),
			mtc__created (22),
			overload__check (23),
			overload__check__fail (24),
			overloaded__no__more (25),
			executor__start__single__mode (26),
			executor__finish__single__mode (27),
			fd__limits (28),
			UNKNOWN_VALUE(29),
			UNBOUND_VALUE(30);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return connected__to__mc;
				case 1:  return disconnected__from__mc;
				case 2:  return initialization__of__modules__failed;
				case 3:  return exit__requested__from__mc__hc;
				case 4:  return exit__requested__from__mc__mtc;
				case 5:  return stop__was__requested__from__mc__ignored__on__idle__mtc;
				case 6:  return stop__was__requested__from__mc;
				case 7:  return stop__was__requested__from__mc__ignored__on__idle__ptc;
				case 8:  return executing__testcase__in__module;
				case 9:  return performing__error__recovery;
				case 10:  return initializing__module;
				case 11:  return initialization__of__module__finished;
				case 12:  return stopping__current__testcase;
				case 13:  return exiting;
				case 14:  return host__controller__started;
				case 15:  return host__controller__finished;
				case 16:  return stopping__control__part__execution;
				case 17:  return stopping__test__component__execution;
				case 18:  return waiting__for__ptcs__to__finish;
				case 19:  return user__paused__waiting__to__resume;
				case 20:  return resuming__execution;
				case 21:  return terminating__execution;
				case 22:  return mtc__created;
				case 23:  return overload__check;
				case 24:  return overload__check__fail;
				case 25:  return overloaded__no__more;
				case 26:  return executor__start__single__mode;
				case 27:  return executor__finish__single__mode;
				case 28:  return fd__limits;
				case 29:  return UNKNOWN_VALUE;
				case 30:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ExecutorRuntime_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ExecutorRuntime_reason(final ExecutorRuntime_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ExecutorRuntime_reason(final ExecutorRuntime_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ExecutorRuntime_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorRuntime_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ExecutorRuntime_reason assign(final ExecutorRuntime_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ExecutorRuntime_reason assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorRuntime_reason ) {
				return assign((ExecutorRuntime_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ExecutorRuntime_reason assign(final ExecutorRuntime_reason.enum_type otherValue){
			return assign( new ExecutorRuntime_reason(otherValue) );
		}

		//originally operator=
		public ExecutorRuntime_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorRuntime_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorRuntime_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ExecutorRuntime_reason) {
				return operatorEquals( (ExecutorRuntime_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorRuntime_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorRuntime_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorRuntime_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ExecutorRuntime_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ExecutorRuntime_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorRuntime_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorRuntime_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorRuntime_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorRuntime_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorRuntime_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorRuntime_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ExecutorRuntime_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ExecutorRuntime_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("connected__to__mc".equals(strPar) || "connected_to_mc".equals(strPar)) {
				return enum_type.connected__to__mc;
			}
			if ("disconnected__from__mc".equals(strPar) || "disconnected_from_mc".equals(strPar)) {
				return enum_type.disconnected__from__mc;
			}
			if ("initialization__of__modules__failed".equals(strPar) || "initialization_of_modules_failed".equals(strPar)) {
				return enum_type.initialization__of__modules__failed;
			}
			if ("exit__requested__from__mc__hc".equals(strPar) || "exit_requested_from_mc_hc".equals(strPar)) {
				return enum_type.exit__requested__from__mc__hc;
			}
			if ("exit__requested__from__mc__mtc".equals(strPar) || "exit_requested_from_mc_mtc".equals(strPar)) {
				return enum_type.exit__requested__from__mc__mtc;
			}
			if ("stop__was__requested__from__mc__ignored__on__idle__mtc".equals(strPar) || "stop_was_requested_from_mc_ignored_on_idle_mtc".equals(strPar)) {
				return enum_type.stop__was__requested__from__mc__ignored__on__idle__mtc;
			}
			if ("stop__was__requested__from__mc".equals(strPar) || "stop_was_requested_from_mc".equals(strPar)) {
				return enum_type.stop__was__requested__from__mc;
			}
			if ("stop__was__requested__from__mc__ignored__on__idle__ptc".equals(strPar) || "stop_was_requested_from_mc_ignored_on_idle_ptc".equals(strPar)) {
				return enum_type.stop__was__requested__from__mc__ignored__on__idle__ptc;
			}
			if ("executing__testcase__in__module".equals(strPar) || "executing_testcase_in_module".equals(strPar)) {
				return enum_type.executing__testcase__in__module;
			}
			if ("performing__error__recovery".equals(strPar) || "performing_error_recovery".equals(strPar)) {
				return enum_type.performing__error__recovery;
			}
			if ("initializing__module".equals(strPar) || "initializing_module".equals(strPar)) {
				return enum_type.initializing__module;
			}
			if ("initialization__of__module__finished".equals(strPar) || "initialization_of_module_finished".equals(strPar)) {
				return enum_type.initialization__of__module__finished;
			}
			if ("stopping__current__testcase".equals(strPar) || "stopping_current_testcase".equals(strPar)) {
				return enum_type.stopping__current__testcase;
			}
			if ("exiting".equals(strPar)) {
				return enum_type.exiting;
			}
			if ("host__controller__started".equals(strPar) || "host_controller_started".equals(strPar)) {
				return enum_type.host__controller__started;
			}
			if ("host__controller__finished".equals(strPar) || "host_controller_finished".equals(strPar)) {
				return enum_type.host__controller__finished;
			}
			if ("stopping__control__part__execution".equals(strPar) || "stopping_control_part_execution".equals(strPar)) {
				return enum_type.stopping__control__part__execution;
			}
			if ("stopping__test__component__execution".equals(strPar) || "stopping_test_component_execution".equals(strPar)) {
				return enum_type.stopping__test__component__execution;
			}
			if ("waiting__for__ptcs__to__finish".equals(strPar) || "waiting_for_ptcs_to_finish".equals(strPar)) {
				return enum_type.waiting__for__ptcs__to__finish;
			}
			if ("user__paused__waiting__to__resume".equals(strPar) || "user_paused_waiting_to_resume".equals(strPar)) {
				return enum_type.user__paused__waiting__to__resume;
			}
			if ("resuming__execution".equals(strPar) || "resuming_execution".equals(strPar)) {
				return enum_type.resuming__execution;
			}
			if ("terminating__execution".equals(strPar) || "terminating_execution".equals(strPar)) {
				return enum_type.terminating__execution;
			}
			if ("mtc__created".equals(strPar) || "mtc_created".equals(strPar)) {
				return enum_type.mtc__created;
			}
			if ("overload__check".equals(strPar) || "overload_check".equals(strPar)) {
				return enum_type.overload__check;
			}
			if ("overload__check__fail".equals(strPar) || "overload_check_fail".equals(strPar)) {
				return enum_type.overload__check__fail;
			}
			if ("overloaded__no__more".equals(strPar) || "overloaded_no_more".equals(strPar)) {
				return enum_type.overloaded__no__more;
			}
			if ("executor__start__single__mode".equals(strPar) || "executor_start_single_mode".equals(strPar)) {
				return enum_type.executor__start__single__mode;
			}
			if ("executor__finish__single__mode".equals(strPar) || "executor_finish_single_mode".equals(strPar)) {
				return enum_type.executor__finish__single__mode;
			}
			if ("fd__limits".equals(strPar) || "fd_limits".equals(strPar)) {
				return enum_type.fd__limits;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ExecutorRuntime.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorRuntime.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorRuntime.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorRuntime_reason_template extends Base_Template {
		// single_value
		private ExecutorRuntime_reason.enum_type single_value;
		// value_list part
		private ArrayList<ExecutorRuntime_reason_template> value_list;

		private void copy_template(final ExecutorRuntime_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ExecutorRuntime_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ExecutorRuntime_reason_template temp = new ExecutorRuntime_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorRuntime_reason.");
			}
		}

		public ExecutorRuntime_reason_template() {
			// do nothing
		}

		public ExecutorRuntime_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ExecutorRuntime_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ExecutorRuntime_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ExecutorRuntime_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = ExecutorRuntime_reason.enum_type.getValue(otherValue);
		}

		public ExecutorRuntime_reason_template(final ExecutorRuntime_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ExecutorRuntime_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorRuntime_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public ExecutorRuntime_reason_template(final ExecutorRuntime_reason_template otherValue) {
			copy_template(otherValue);
		}

		public ExecutorRuntime_reason_template(final ExecutorRuntime_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ExecutorRuntime_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ExecutorRuntime_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ExecutorRuntime_reason_template assign(final int otherValue) {
			if (!ExecutorRuntime_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorRuntime_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason otherValue){
			if (otherValue.enum_value == ExecutorRuntime_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorRuntime_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ExecutorRuntime_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorRuntime_reason ) {
				return assign((ExecutorRuntime_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorRuntime_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof ExecutorRuntime_reason_template ) {
				return assign((ExecutorRuntime_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ExecutorRuntime_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ExecutorRuntime_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorRuntime_reason.");
			}
		}

		// originally match
		public boolean match(final ExecutorRuntime_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ExecutorRuntime_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ExecutorRuntime_reason ) {
				return match((ExecutorRuntime_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
		}

		public ExecutorRuntime_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorRuntime_reason.");
			}
			return new ExecutorRuntime_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorRuntime_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ExecutorRuntime_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ExecutorRuntime_reason_template());
			}
		}

		public ExecutorRuntime_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorRuntime_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorRuntime_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorRuntime_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ExecutorRuntime_reason.enum2str(single_value), ExecutorRuntime_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorRuntime_reason) {
				log_match((ExecutorRuntime_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.reason.");
		}
		public void log_match(final ExecutorRuntime_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ExecutorRuntime_reason.enum_type enum_value = ExecutorRuntime_reason.str_to_enum(param.get_enumerated());
				if (!ExecutorRuntime_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorRuntime.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ExecutorRuntime.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ExecutorRuntime_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorRuntime.reason.", temp));
				}
				single_value = ExecutorRuntime_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ExecutorRuntime_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorRuntime_reason_template temp = new ExecutorRuntime_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorRuntime.reason" : name));
		}
	}
	public static void ExecutorRuntime_reason_encoder(final ExecutorRuntime_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_reason_decoder( final TitanOctetString input_stream, final ExecutorRuntime_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorRuntime_module__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_module__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingFailureType_reason extends Base_Type {
		public enum enum_type {
			sender__does__not__match__from__clause (0),
			sender__is__not__system (1),
			message__does__not__match__template (2),
			parameters__of__call__do__not__match__template (3),
			parameters__of__reply__do__not__match__template (4),
			exception__does__not__match__template (5),
			not__an__exception__for__signature (6),
			UNKNOWN_VALUE(7),
			UNBOUND_VALUE(8);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return sender__does__not__match__from__clause;
				case 1:  return sender__is__not__system;
				case 2:  return message__does__not__match__template;
				case 3:  return parameters__of__call__do__not__match__template;
				case 4:  return parameters__of__reply__do__not__match__template;
				case 5:  return exception__does__not__match__template;
				case 6:  return not__an__exception__for__signature;
				case 7:  return UNKNOWN_VALUE;
				case 8:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public MatchingFailureType_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public MatchingFailureType_reason(final MatchingFailureType_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public MatchingFailureType_reason(final MatchingFailureType_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public MatchingFailureType_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingFailureType_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public MatchingFailureType_reason assign(final MatchingFailureType_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public MatchingFailureType_reason assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingFailureType_reason ) {
				return assign((MatchingFailureType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public MatchingFailureType_reason assign(final MatchingFailureType_reason.enum_type otherValue){
			return assign( new MatchingFailureType_reason(otherValue) );
		}

		//originally operator=
		public MatchingFailureType_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingFailureType_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final MatchingFailureType_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof MatchingFailureType_reason) {
				return operatorEquals( (MatchingFailureType_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final MatchingFailureType_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingFailureType_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingFailureType_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final MatchingFailureType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final MatchingFailureType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingFailureType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingFailureType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingFailureType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingFailureType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingFailureType_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingFailureType_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final MatchingFailureType_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final MatchingFailureType_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("sender__does__not__match__from__clause".equals(strPar) || "sender_does_not_match_from_clause".equals(strPar)) {
				return enum_type.sender__does__not__match__from__clause;
			}
			if ("sender__is__not__system".equals(strPar) || "sender_is_not_system".equals(strPar)) {
				return enum_type.sender__is__not__system;
			}
			if ("message__does__not__match__template".equals(strPar) || "message_does_not_match_template".equals(strPar)) {
				return enum_type.message__does__not__match__template;
			}
			if ("parameters__of__call__do__not__match__template".equals(strPar) || "parameters_of_call_do_not_match_template".equals(strPar)) {
				return enum_type.parameters__of__call__do__not__match__template;
			}
			if ("parameters__of__reply__do__not__match__template".equals(strPar) || "parameters_of_reply_do_not_match_template".equals(strPar)) {
				return enum_type.parameters__of__reply__do__not__match__template;
			}
			if ("exception__does__not__match__template".equals(strPar) || "exception_does_not_match_template".equals(strPar)) {
				return enum_type.exception__does__not__match__template;
			}
			if ("not__an__exception__for__signature".equals(strPar) || "not_an_exception_for_signature".equals(strPar)) {
				return enum_type.not__an__exception__for__signature;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.MatchingFailureType.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingFailureType.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingFailureType.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingFailureType_reason_template extends Base_Template {
		// single_value
		private MatchingFailureType_reason.enum_type single_value;
		// value_list part
		private ArrayList<MatchingFailureType_reason_template> value_list;

		private void copy_template(final MatchingFailureType_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingFailureType_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final MatchingFailureType_reason_template temp = new MatchingFailureType_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingFailureType_reason.");
			}
		}

		public MatchingFailureType_reason_template() {
			// do nothing
		}

		public MatchingFailureType_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public MatchingFailureType_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!MatchingFailureType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type MatchingFailureType_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = MatchingFailureType_reason.enum_type.getValue(otherValue);
		}

		public MatchingFailureType_reason_template(final MatchingFailureType_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == MatchingFailureType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingFailureType_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public MatchingFailureType_reason_template(final MatchingFailureType_reason_template otherValue) {
			copy_template(otherValue);
		}

		public MatchingFailureType_reason_template(final MatchingFailureType_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != MatchingFailureType_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public MatchingFailureType_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public MatchingFailureType_reason_template assign(final int otherValue) {
			if (!MatchingFailureType_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingFailureType_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public MatchingFailureType_reason_template assign(final MatchingFailureType_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public MatchingFailureType_reason_template assign(final MatchingFailureType_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public MatchingFailureType_reason_template assign(final MatchingFailureType_reason otherValue){
			if (otherValue.enum_value == MatchingFailureType_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type MatchingFailureType_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public MatchingFailureType_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingFailureType_reason ) {
				return assign((MatchingFailureType_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingFailureType_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof MatchingFailureType_reason_template ) {
				return assign((MatchingFailureType_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final MatchingFailureType_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final MatchingFailureType_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingFailureType_reason.");
			}
		}

		// originally match
		public boolean match(final MatchingFailureType_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final MatchingFailureType_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof MatchingFailureType_reason ) {
				return match((MatchingFailureType_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
		}

		public MatchingFailureType_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingFailureType_reason.");
			}
			return new MatchingFailureType_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingFailureType_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<MatchingFailureType_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingFailureType_reason_template());
			}
		}

		public MatchingFailureType_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingFailureType_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type MatchingFailureType_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type MatchingFailureType_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(MatchingFailureType_reason.enum2str(single_value), MatchingFailureType_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingFailureType_reason) {
				log_match((MatchingFailureType_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.reason.");
		}
		public void log_match(final MatchingFailureType_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final MatchingFailureType_reason.enum_type enum_value = MatchingFailureType_reason.str_to_enum(param.get_enumerated());
				if (!MatchingFailureType_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingFailureType.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.MatchingFailureType.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!MatchingFailureType_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingFailureType.reason.", temp));
				}
				single_value = MatchingFailureType_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingFailureType_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingFailureType_reason_template temp = new MatchingFailureType_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingFailureType.reason" : name));
		}
	}
	public static void MatchingFailureType_reason_encoder(final MatchingFailureType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_reason_decoder( final TitanOctetString input_stream, final MatchingFailureType_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_procPortRecv_encoder(final Proc__port__in input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_procPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_procPortRecv_decoder( final TitanOctetString input_stream, final Proc__port__in output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_procPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingProblemType_operation extends Base_Type {
		public enum enum_type {
			receive__ (0),
			trigger__ (1),
			getcall__ (2),
			getreply__ (3),
			catch__ (4),
			check__ (5),
			UNKNOWN_VALUE(6),
			UNBOUND_VALUE(7);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return receive__;
				case 1:  return trigger__;
				case 2:  return getcall__;
				case 3:  return getreply__;
				case 4:  return catch__;
				case 5:  return check__;
				case 6:  return UNKNOWN_VALUE;
				case 7:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public MatchingProblemType_operation() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public MatchingProblemType_operation(final MatchingProblemType_operation otherValue) {
			enum_value = otherValue.enum_value;
		}

		public MatchingProblemType_operation(final MatchingProblemType_operation.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public MatchingProblemType_operation(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingProblemType_operation' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public MatchingProblemType_operation assign(final MatchingProblemType_operation otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public MatchingProblemType_operation assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingProblemType_operation ) {
				return assign((MatchingProblemType_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public MatchingProblemType_operation assign(final MatchingProblemType_operation.enum_type otherValue){
			return assign( new MatchingProblemType_operation(otherValue) );
		}

		//originally operator=
		public MatchingProblemType_operation assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingProblemType_operation'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final MatchingProblemType_operation otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof MatchingProblemType_operation) {
				return operatorEquals( (MatchingProblemType_operation) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.operation.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final MatchingProblemType_operation.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingProblemType_operation otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final MatchingProblemType_operation.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final MatchingProblemType_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final MatchingProblemType_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingProblemType_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final MatchingProblemType_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingProblemType_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final MatchingProblemType_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingProblemType_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final MatchingProblemType_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final MatchingProblemType_operation.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final MatchingProblemType_operation enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("receive__".equals(strPar) || "receive_".equals(strPar)) {
				return enum_type.receive__;
			}
			if ("trigger__".equals(strPar) || "trigger_".equals(strPar)) {
				return enum_type.trigger__;
			}
			if ("getcall__".equals(strPar) || "getcall_".equals(strPar)) {
				return enum_type.getcall__;
			}
			if ("getreply__".equals(strPar) || "getreply_".equals(strPar)) {
				return enum_type.getreply__;
			}
			if ("catch__".equals(strPar) || "catch_".equals(strPar)) {
				return enum_type.catch__;
			}
			if ("check__".equals(strPar) || "check_".equals(strPar)) {
				return enum_type.check__;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.MatchingProblemType.operation");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingProblemType.operation.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.operation.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingProblemType_operation_template extends Base_Template {
		// single_value
		private MatchingProblemType_operation.enum_type single_value;
		// value_list part
		private ArrayList<MatchingProblemType_operation_template> value_list;

		private void copy_template(final MatchingProblemType_operation_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingProblemType_operation_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final MatchingProblemType_operation_template temp = new MatchingProblemType_operation_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingProblemType_operation.");
			}
		}

		public MatchingProblemType_operation_template() {
			// do nothing
		}

		public MatchingProblemType_operation_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public MatchingProblemType_operation_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!MatchingProblemType_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type MatchingProblemType_operation with unknown numeric value "+ otherValue +".");
			}
			single_value = MatchingProblemType_operation.enum_type.getValue(otherValue);
		}

		public MatchingProblemType_operation_template(final MatchingProblemType_operation otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == MatchingProblemType_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingProblemType_operation. ");
			}
			single_value = otherValue.enum_value;
		}

		public MatchingProblemType_operation_template(final MatchingProblemType_operation_template otherValue) {
			copy_template(otherValue);
		}

		public MatchingProblemType_operation_template(final MatchingProblemType_operation.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != MatchingProblemType_operation.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public MatchingProblemType_operation_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public MatchingProblemType_operation_template assign(final int otherValue) {
			if (!MatchingProblemType_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingProblemType_operation.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public MatchingProblemType_operation_template assign(final MatchingProblemType_operation.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public MatchingProblemType_operation_template assign(final MatchingProblemType_operation_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public MatchingProblemType_operation_template assign(final MatchingProblemType_operation otherValue){
			if (otherValue.enum_value == MatchingProblemType_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type MatchingProblemType_operation to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public MatchingProblemType_operation_template assign(final Base_Type otherValue){
			if( otherValue instanceof MatchingProblemType_operation ) {
				return assign((MatchingProblemType_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingProblemType_operation_template assign(final Base_Template otherValue){
			if( otherValue instanceof MatchingProblemType_operation_template ) {
				return assign((MatchingProblemType_operation_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final MatchingProblemType_operation.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final MatchingProblemType_operation.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingProblemType_operation.");
			}
		}

		// originally match
		public boolean match(final MatchingProblemType_operation otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final MatchingProblemType_operation otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof MatchingProblemType_operation ) {
				return match((MatchingProblemType_operation) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
		}

		public MatchingProblemType_operation valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingProblemType_operation.");
			}
			return new MatchingProblemType_operation(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingProblemType_operation.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<MatchingProblemType_operation_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingProblemType_operation_template());
			}
		}

		public MatchingProblemType_operation_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingProblemType_operation.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type MatchingProblemType_operation.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type MatchingProblemType_operation.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(MatchingProblemType_operation.enum2str(single_value), MatchingProblemType_operation.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingProblemType_operation) {
				log_match((MatchingProblemType_operation)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.operation.");
		}
		public void log_match(final MatchingProblemType_operation match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final MatchingProblemType_operation.enum_type enum_value = MatchingProblemType_operation.str_to_enum(param.get_enumerated());
				if (!MatchingProblemType_operation.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.MatchingProblemType.operation.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.MatchingProblemType.operation");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!MatchingProblemType_operation.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.operation.", temp));
				}
				single_value = MatchingProblemType_operation.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingProblemType_operation_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingProblemType_operation_template temp = new MatchingProblemType_operation_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingProblemType.operation" : name));
		}
	}
	public static void MatchingProblemType_operation_encoder(final MatchingProblemType_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_operation_decoder( final TitanOctetString input_stream, final MatchingProblemType_operation output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanSingleLogEvent extends Base_Type {
		private final ComponentIDType entityId; //Referenced_Type
		private final TitanLogEvent event; //Referenced_Type

		public TitanSingleLogEvent() {
			this.entityId = new ComponentIDType();
			this.event = new TitanLogEvent();
		}

		public TitanSingleLogEvent(final ComponentIDType entityId, final TitanLogEvent event ) {
			this.entityId = new ComponentIDType( entityId );
			this.event = new TitanLogEvent( event );
		}

		public TitanSingleLogEvent( final TitanSingleLogEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			entityId = new ComponentIDType();
			event = new TitanLogEvent();
			assign( otherValue );
		}

		public TitanSingleLogEvent assign(final TitanSingleLogEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanSingleLogEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getentityId().isBound() ) {
					this.entityId.assign( otherValue.getentityId() );
				} else {
					this.entityId.cleanUp();
				}
				if ( otherValue.getevent().isBound() ) {
					this.event.assign( otherValue.getevent() );
				} else {
					this.event.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanSingleLogEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent ) {
				return assign((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanSingleLogEvent", otherValue));
		}

		public void cleanUp() {
			entityId.cleanUp();
			event.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( entityId.isBound() ) { return true; }
			if ( event.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !entityId.isValue() ) { return false; }
			if ( !event.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanSingleLogEvent otherValue) {
			if ( !this.entityId.operatorEquals( otherValue.entityId ) ) { return false; }
			if ( !this.event.operatorEquals( otherValue.event ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent ) {
				return operatorEquals((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanSingleLogEvent", otherValue));
		}

		public ComponentIDType getentityId() {
			return entityId;
		}

		public ComponentIDType constGetentityId() {
			return entityId;
		}

		public TitanLogEvent getevent() {
			return event;
		}

		public TitanLogEvent constGetevent() {
			return event;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" entityId := ");
			entityId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" event := ");
			event.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TitanSingleLogEvent has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getentityId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getevent().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("entityId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getentityId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getevent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanSingleLogEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TitanSingleLogEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (entityId.isBound()) {
				entityId.set_implicit_omit();
			}
			if (event.isBound()) {
				event.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			entityId.encode_text(text_buf);
			event.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			entityId.decode_text(text_buf);
			event.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanSingleLogEvent_template extends Base_Template {

		private ComponentIDType_template entityId; //Referenced_Type
		private TitanLogEvent_template event; //Referenced_Type
		//originally value_list/list_value
		private List<TitanSingleLogEvent_template> list_value;

		public ComponentIDType_template getentityId() {
			setSpecific();
			return entityId;
		}

		public ComponentIDType_template constGetentityId() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field entityId of a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			return entityId;
		}

		public TitanLogEvent_template getevent() {
			setSpecific();
			return event;
		}

		public TitanLogEvent_template constGetevent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field event of a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			return event;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				entityId = new ComponentIDType_template();
				event = new TitanLogEvent_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					entityId.assign(template_sel.ANY_VALUE);
					event.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TitanSingleLogEvent_template() {
			// do nothing
		}

		public TitanSingleLogEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanSingleLogEvent_template( final TitanSingleLogEvent otherValue ) {
			copyValue(otherValue);
		}

		public TitanSingleLogEvent_template( final TitanSingleLogEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanSingleLogEvent_template( final Optional<TitanSingleLogEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanSingleLogEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public TitanSingleLogEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanSingleLogEvent_template assign( final TitanSingleLogEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TitanSingleLogEvent_template assign( final TitanSingleLogEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanSingleLogEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent) {
				return assign((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanSingleLogEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanSingleLogEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanSingleLogEvent_template) {
				return assign((TitanSingleLogEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanSingleLogEvent' can not be cast to {1}_template", otherValue));
		}

		public TitanSingleLogEvent_template assign( final Optional<TitanSingleLogEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			return this;
		}

		private void copyValue(final TitanSingleLogEvent other_value) {
			if (other_value.getentityId().isBound()) {
				getentityId().assign(other_value.getentityId());
			} else {
				getentityId().cleanUp();
			}
			if (other_value.getevent().isBound()) {
				getevent().assign(other_value.getevent());
			} else {
				getevent().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanSingleLogEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getentityId().get_selection()) {
					getentityId().cleanUp();
				} else {
					getentityId().assign(other_value.getentityId());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getevent().get_selection()) {
					getevent().cleanUp();
				} else {
					getevent().assign(other_value.getevent());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanSingleLogEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanSingleLogEvent_template temp = new TitanSingleLogEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanSingleLogEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			final TitanSingleLogEvent ret_val = new TitanSingleLogEvent();
			if (entityId.isBound()) {
				ret_val.getentityId().assign(entityId.valueOf());
			}
			if (event.isBound()) {
				ret_val.getevent().assign(event.valueOf());
			}
			return ret_val;
		}

		public TitanSingleLogEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanSingleLogEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanSingleLogEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (entityId.isBound()) {
				return true;
			}
			if (event.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!entityId.isValue()) {
				return false;
			}
			if (!event.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanSingleLogEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanSingleLogEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getentityId().isBound()) {
					return false;
				}
				if(!entityId.match(other_value.getentityId(), legacy)) {
					return false;
				}
				if(!other_value.getevent().isBound()) {
					return false;
				}
				if(!event.match(other_value.getevent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanSingleLogEvent) {
				return match((TitanSingleLogEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanSingleLogEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" entityId := ");
				entityId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" event := ");
				event.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanSingleLogEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanSingleLogEvent) {
				log_match((TitanSingleLogEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanSingleLogEvent.");
		}

		public void log_match(final TitanSingleLogEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !entityId.match(match_value.constGetentityId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".entityId");
							entityId.log_match(match_value.constGetentityId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !event.match(match_value.constGetevent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".event");
							event.log_match(match_value.constGetevent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ entityId := ");
				entityId.log_match(match_value.constGetentityId(), legacy);
				TTCN_Logger.log_event_str("{ event := ");
				event.log_match(match_value.constGetevent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId.encode_text(text_buf);
				event.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId = new ComponentIDType_template();
				entityId.decode_text(text_buf);
				event = new TitanLogEvent_template();
				event.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanSingleLogEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanSingleLogEvent_template temp = new TitanSingleLogEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TitanSingleLogEvent has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getentityId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getevent().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("entityId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getentityId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("event".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getevent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanSingleLogEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TitanSingleLogEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.entityId.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanSingleLogEvent" : name, legacy);
				this.event.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanSingleLogEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanSingleLogEvent" : name));
		}
	}
	public static void TitanSingleLogEvent_encoder(final TitanSingleLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanSingleLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanSingleLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanSingleLogEvent_decoder( final TitanOctetString input_stream, final TitanSingleLogEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanSingleLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanSingleLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_msgPortSend_encoder(final Msg__port__send input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_msgPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_msgPortSend_decoder( final TitanOctetString input_stream, final Msg__port__send output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_msgPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LocationInfo_filename_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LocationInfo_filename_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LocationInfo_filename_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LocationInfo_filename_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_guardTimer_encoder(final TimerGuardType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_guardTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_guardTimer_decoder( final TitanOctetString input_stream, final TimerGuardType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_guardTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingFailureType_choice_system___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_choice_system___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_choice_system___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_choice_system___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingFailureType_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_system__,  ALT_compref };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public MatchingFailureType_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public MatchingFailureType_choice(final MatchingFailureType_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final MatchingFailureType_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_system__:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_compref:
				field = new TitanInteger((TitanInteger)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public MatchingFailureType_choice assign( final MatchingFailureType_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public MatchingFailureType_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingFailureType_choice) {
				return assign((MatchingFailureType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_system__:
				return field.isValue();
			case ALT_compref:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final MatchingFailureType_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_system__:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_compref:
				return ((TitanInteger)field).operatorEquals((TitanInteger)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingFailureType_choice) {
				return operatorEquals((MatchingFailureType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final MatchingFailureType_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public TitanCharString getsystem__() {
			if (union_selection != union_selection_type.ALT_system__) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_system__;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetsystem__() {
			if (union_selection != union_selection_type.ALT_system__) {
				throw new TtcnError("Using non-selected field system_ in a value of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return (TitanCharString)field;
		}

		public TitanInteger getcompref() {
			if (union_selection != union_selection_type.ALT_compref) {
				cleanUp();
				field = new TitanInteger();
				union_selection = union_selection_type.ALT_compref;
			}
			return (TitanInteger)field;
		}

		public TitanInteger constGetcompref() {
			if (union_selection != union_selection_type.ALT_compref) {
				throw new TtcnError("Using non-selected field compref in a value of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return (TitanInteger)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_system__:
				TTCN_Logger.log_event_str("{ system_ := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_compref:
				TTCN_Logger.log_event_str("{ compref := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("system_".equals(last_name)) {
				getsystem__().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("compref".equals(last_name)) {
				getcompref().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.MatchingFailureType.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_system__:
			case ALT_compref:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_system__:
				text_buf.push_int(0);
				break;
			case ALT_compref:
				text_buf.push_int(1);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getsystem__().decode_text(text_buf);
				break;
			case 1:
				getcompref().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.MatchingFailureType.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingFailureType_choice_template extends Base_Template {
		//if single value which value?
		private MatchingFailureType_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<MatchingFailureType_choice_template> value_list;

		private void copy_value(final MatchingFailureType_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_system__:
				single_value = new TitanCharString_template(other_value.constGetsystem__());
				break;
			case ALT_compref:
				single_value = new TitanInteger_template(other_value.constGetcompref());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final MatchingFailureType_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_system__:
					single_value = new TitanCharString_template(other_value.constGetsystem__());
					break;
				case ALT_compref:
					single_value = new TitanInteger_template(other_value.constGetcompref());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.MatchingFailureType.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingFailureType_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final MatchingFailureType_choice_template temp = new MatchingFailureType_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			set_selection(other_value);
		}

		public MatchingFailureType_choice_template() {
			// do nothing
		}
		public MatchingFailureType_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public MatchingFailureType_choice_template(final MatchingFailureType_choice other_value) {
			copy_value(other_value);
		}
		public MatchingFailureType_choice_template(final MatchingFailureType_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_system__:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_compref:
					((TitanInteger_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public MatchingFailureType_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingFailureType_choice_template assign( final MatchingFailureType_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public MatchingFailureType_choice_template assign( final MatchingFailureType_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public MatchingFailureType_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingFailureType_choice) {
				return assign((MatchingFailureType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to MatchingFailureType_choice.");
		}

		@Override
		public MatchingFailureType_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof MatchingFailureType_choice_template) {
				return assign((MatchingFailureType_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to MatchingFailureType_choice_template.");
		}

		// originally match
		public boolean match(final MatchingFailureType_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final MatchingFailureType_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final MatchingFailureType_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_system__:
					return ((TitanCharString_template)single_value).match(other_value.getsystem__(), legacy);
				case ALT_compref:
					return ((TitanInteger_template)single_value).match(other_value.getcompref(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingFailureType_choice) {
				return match((MatchingFailureType_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingFailureType_choice.");
		}
		public boolean isChosen(final MatchingFailureType_choice.union_selection_type checked_selection) {
			if(checked_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_system__:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_compref:
				return ((TitanInteger_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
		}

		public MatchingFailureType_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			final MatchingFailureType_choice ret_val = new MatchingFailureType_choice();
			switch (single_value_union_selection) {
			case ALT_system__:
				ret_val.getsystem__().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_compref:
				ret_val.getcompref().assign(((TitanInteger_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<MatchingFailureType_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingFailureType_choice_template());
			}
		}

		public MatchingFailureType_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public TitanCharString_template getsystem__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_system__) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = MatchingFailureType_choice.union_selection_type.ALT_system__;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetsystem__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field system_ in a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			if (single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_system__) {
				throw new TtcnError("Accessing non-selected field system_ in a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public TitanInteger_template getcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_compref) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanInteger_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanInteger_template();
				}
				single_value_union_selection = MatchingFailureType_choice.union_selection_type.ALT_compref;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanInteger_template)single_value;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref in a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			if (single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_compref) {
				throw new TtcnError("Accessing non-selected field compref in a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
			}
			return (TitanInteger_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingFailureType_choice) {
				log_match((MatchingFailureType_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
		}

		public void log_match(final MatchingFailureType_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_system__:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".system_");
						single_value.log_match(match_value.getsystem__(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ system_ := ");
						single_value.log_match(match_value.getsystem__(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_compref:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".compref");
						single_value.log_match(match_value.getcompref(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ compref := ");
						single_value.log_match(match_value.getcompref(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.MatchingFailureType.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new TitanInteger_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingFailureType_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingFailureType_choice_template temp2 = new MatchingFailureType_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.MatchingFailureType.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.MatchingFailureType.choice");
				}
				if("system_".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("compref".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.MatchingFailureType.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("system_".equals(last_name)) {
					getsystem__().set_param(mp_last);
					break;
				}
				if("compref".equals(last_name)) {
					getcompref().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.MatchingFailureType.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.MatchingFailureType.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_system__:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType.choice" : name, legacy);
					return;
				case ALT_compref:
					((TitanInteger_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingFailureType.choice" : name));
		}
	}
	public static void MatchingFailureType_choice_encoder(final MatchingFailureType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_choice_decoder( final TitanOctetString input_stream, final MatchingFailureType_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorConfigdata_reason extends Base_Type {
		public enum enum_type {
			received__from__mc (0),
			processing__failed (1),
			processing__succeeded (2),
			module__has__parameters (3),
			using__config__file (4),
			overriding__testcase__list (5),
			UNKNOWN_VALUE(6),
			UNBOUND_VALUE(7);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return received__from__mc;
				case 1:  return processing__failed;
				case 2:  return processing__succeeded;
				case 3:  return module__has__parameters;
				case 4:  return using__config__file;
				case 5:  return overriding__testcase__list;
				case 6:  return UNKNOWN_VALUE;
				case 7:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ExecutorConfigdata_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ExecutorConfigdata_reason(final ExecutorConfigdata_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ExecutorConfigdata_reason(final ExecutorConfigdata_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ExecutorConfigdata_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorConfigdata_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ExecutorConfigdata_reason assign(final ExecutorConfigdata_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ExecutorConfigdata_reason assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorConfigdata_reason ) {
				return assign((ExecutorConfigdata_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ExecutorConfigdata_reason assign(final ExecutorConfigdata_reason.enum_type otherValue){
			return assign( new ExecutorConfigdata_reason(otherValue) );
		}

		//originally operator=
		public ExecutorConfigdata_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorConfigdata_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorConfigdata_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ExecutorConfigdata_reason) {
				return operatorEquals( (ExecutorConfigdata_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorConfigdata_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorConfigdata_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorConfigdata_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ExecutorConfigdata_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ExecutorConfigdata_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorConfigdata_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorConfigdata_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorConfigdata_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorConfigdata_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorConfigdata_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorConfigdata_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ExecutorConfigdata_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ExecutorConfigdata_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("received__from__mc".equals(strPar) || "received_from_mc".equals(strPar)) {
				return enum_type.received__from__mc;
			}
			if ("processing__failed".equals(strPar) || "processing_failed".equals(strPar)) {
				return enum_type.processing__failed;
			}
			if ("processing__succeeded".equals(strPar) || "processing_succeeded".equals(strPar)) {
				return enum_type.processing__succeeded;
			}
			if ("module__has__parameters".equals(strPar) || "module_has_parameters".equals(strPar)) {
				return enum_type.module__has__parameters;
			}
			if ("using__config__file".equals(strPar) || "using_config_file".equals(strPar)) {
				return enum_type.using__config__file;
			}
			if ("overriding__testcase__list".equals(strPar) || "overriding_testcase_list".equals(strPar)) {
				return enum_type.overriding__testcase__list;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ExecutorConfigdata.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorConfigdata.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorConfigdata_reason_template extends Base_Template {
		// single_value
		private ExecutorConfigdata_reason.enum_type single_value;
		// value_list part
		private ArrayList<ExecutorConfigdata_reason_template> value_list;

		private void copy_template(final ExecutorConfigdata_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ExecutorConfigdata_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ExecutorConfigdata_reason_template temp = new ExecutorConfigdata_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorConfigdata_reason.");
			}
		}

		public ExecutorConfigdata_reason_template() {
			// do nothing
		}

		public ExecutorConfigdata_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ExecutorConfigdata_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ExecutorConfigdata_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ExecutorConfigdata_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = ExecutorConfigdata_reason.enum_type.getValue(otherValue);
		}

		public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorConfigdata_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason_template otherValue) {
			copy_template(otherValue);
		}

		public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ExecutorConfigdata_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_reason_template assign(final int otherValue) {
			if (!ExecutorConfigdata_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorConfigdata_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason otherValue){
			if (otherValue.enum_value == ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorConfigdata_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ExecutorConfigdata_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorConfigdata_reason ) {
				return assign((ExecutorConfigdata_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorConfigdata_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof ExecutorConfigdata_reason_template ) {
				return assign((ExecutorConfigdata_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ExecutorConfigdata_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ExecutorConfigdata_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorConfigdata_reason.");
			}
		}

		// originally match
		public boolean match(final ExecutorConfigdata_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ExecutorConfigdata_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ExecutorConfigdata_reason ) {
				return match((ExecutorConfigdata_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
		}

		public ExecutorConfigdata_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorConfigdata_reason.");
			}
			return new ExecutorConfigdata_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorConfigdata_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ExecutorConfigdata_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ExecutorConfigdata_reason_template());
			}
		}

		public ExecutorConfigdata_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorConfigdata_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorConfigdata_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorConfigdata_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ExecutorConfigdata_reason.enum2str(single_value), ExecutorConfigdata_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorConfigdata_reason) {
				log_match((ExecutorConfigdata_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.reason.");
		}
		public void log_match(final ExecutorConfigdata_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ExecutorConfigdata_reason.enum_type enum_value = ExecutorConfigdata_reason.str_to_enum(param.get_enumerated());
				if (!ExecutorConfigdata_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorConfigdata.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ExecutorConfigdata.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ExecutorConfigdata_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.", temp));
				}
				single_value = ExecutorConfigdata_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ExecutorConfigdata_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorConfigdata_reason_template temp = new ExecutorConfigdata_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorConfigdata.reason" : name));
		}
	}
	public static void ExecutorConfigdata_reason_encoder(final ExecutorConfigdata_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorConfigdata_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorConfigdata_reason_decoder( final TitanOctetString input_stream, final ExecutorConfigdata_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorConfigdata_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class QualifiedName extends Base_Type {
		private final TitanCharString module__name; //CharString_Type
		private final TitanCharString testcase__name; //CharString_Type

		public QualifiedName() {
			this.module__name = new TitanCharString();
			this.testcase__name = new TitanCharString();
		}

		public QualifiedName(final TitanCharString module__name, final TitanCharString testcase__name ) {
			this.module__name = new TitanCharString( module__name );
			this.testcase__name = new TitanCharString( testcase__name );
		}

		public QualifiedName( final QualifiedName otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.QualifiedName.");
			}
			module__name = new TitanCharString();
			testcase__name = new TitanCharString();
			assign( otherValue );
		}

		public QualifiedName assign(final QualifiedName otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.QualifiedName");
			}

			if (otherValue != this) {
				if ( otherValue.getmodule__name().isBound() ) {
					this.module__name.assign( otherValue.getmodule__name() );
				} else {
					this.module__name.cleanUp();
				}
				if ( otherValue.gettestcase__name().isBound() ) {
					this.testcase__name.assign( otherValue.gettestcase__name() );
				} else {
					this.testcase__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public QualifiedName assign(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName ) {
				return assign((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.QualifiedName", otherValue));
		}

		public void cleanUp() {
			module__name.cleanUp();
			testcase__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( module__name.isBound() ) { return true; }
			if ( testcase__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !module__name.isValue() ) { return false; }
			if ( !testcase__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final QualifiedName otherValue) {
			if ( !this.module__name.operatorEquals( otherValue.module__name ) ) { return false; }
			if ( !this.testcase__name.operatorEquals( otherValue.testcase__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName ) {
				return operatorEquals((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.QualifiedName", otherValue));
		}

		public TitanCharString getmodule__name() {
			return module__name;
		}

		public TitanCharString constGetmodule__name() {
			return module__name;
		}

		public TitanCharString gettestcase__name() {
			return testcase__name;
		}

		public TitanCharString constGettestcase__name() {
			return testcase__name;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" module_name := ");
			module__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" testcase_name := ");
			testcase__name.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.QualifiedName has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettestcase__name().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("testcase_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettestcase__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.QualifiedName: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.QualifiedName");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (module__name.isBound()) {
				module__name.set_implicit_omit();
			}
			if (testcase__name.isBound()) {
				testcase__name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			module__name.encode_text(text_buf);
			testcase__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			module__name.decode_text(text_buf);
			testcase__name.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class QualifiedName_template extends Base_Template {

		private TitanCharString_template module__name; //CharString_Type
		private TitanCharString_template testcase__name; //CharString_Type
		//originally value_list/list_value
		private List<QualifiedName_template> list_value;

		public TitanCharString_template getmodule__name() {
			setSpecific();
			return module__name;
		}

		public TitanCharString_template constGetmodule__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field module_name of a non-specific template of type @TitanLoggerApi.QualifiedName.");
			}
			return module__name;
		}

		public TitanCharString_template gettestcase__name() {
			setSpecific();
			return testcase__name;
		}

		public TitanCharString_template constGettestcase__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field testcase_name of a non-specific template of type @TitanLoggerApi.QualifiedName.");
			}
			return testcase__name;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				module__name = new TitanCharString_template();
				testcase__name = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					module__name.assign(template_sel.ANY_VALUE);
					testcase__name.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public QualifiedName_template() {
			// do nothing
		}

		public QualifiedName_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public QualifiedName_template( final QualifiedName otherValue ) {
			copyValue(otherValue);
		}

		public QualifiedName_template( final QualifiedName_template otherValue ) {
			copyTemplate( otherValue );
		}

		public QualifiedName_template( final Optional<QualifiedName> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.QualifiedName from an unbound optional field.");
			}
		}

		//originally operator=
		public QualifiedName_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public QualifiedName_template assign( final QualifiedName other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public QualifiedName_template assign( final QualifiedName_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public QualifiedName_template assign(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName) {
				return assign((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `QualifiedName' can not be cast to {1}", otherValue));
		}

		@Override
		public QualifiedName_template assign(final Base_Template otherValue) {
			if (otherValue instanceof QualifiedName_template) {
				return assign((QualifiedName_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `QualifiedName' can not be cast to {1}_template", otherValue));
		}

		public QualifiedName_template assign( final Optional<QualifiedName> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.QualifiedName.");
			}
			return this;
		}

		private void copyValue(final QualifiedName other_value) {
			if (other_value.getmodule__name().isBound()) {
				getmodule__name().assign(other_value.getmodule__name());
			} else {
				getmodule__name().cleanUp();
			}
			if (other_value.gettestcase__name().isBound()) {
				gettestcase__name().assign(other_value.gettestcase__name());
			} else {
				gettestcase__name().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final QualifiedName_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmodule__name().get_selection()) {
					getmodule__name().cleanUp();
				} else {
					getmodule__name().assign(other_value.getmodule__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettestcase__name().get_selection()) {
					gettestcase__name().cleanUp();
				} else {
					gettestcase__name().assign(other_value.gettestcase__name());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<QualifiedName_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final QualifiedName_template temp = new QualifiedName_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.QualifiedName.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public QualifiedName valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.QualifiedName.");
			}
			final QualifiedName ret_val = new QualifiedName();
			if (module__name.isBound()) {
				ret_val.getmodule__name().assign(module__name.valueOf());
			}
			if (testcase__name.isBound()) {
				ret_val.gettestcase__name().assign(testcase__name.valueOf());
			}
			return ret_val;
		}

		public QualifiedName_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.QualifiedName.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.QualifiedName.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.QualifiedName.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<QualifiedName_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new QualifiedName_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (module__name.isBound()) {
				return true;
			}
			if (testcase__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!module__name.isValue()) {
				return false;
			}
			if (!testcase__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final QualifiedName other_value) {
			return match(other_value, false);
		}

		public boolean match(final QualifiedName other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getmodule__name().isBound()) {
					return false;
				}
				if(!module__name.match(other_value.getmodule__name(), legacy)) {
					return false;
				}
				if(!other_value.gettestcase__name().isBound()) {
					return false;
				}
				if(!testcase__name.match(other_value.gettestcase__name(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof QualifiedName) {
				return match((QualifiedName)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type QualifiedName.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" module_name := ");
				module__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" testcase_name := ");
				testcase__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final QualifiedName match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof QualifiedName) {
				log_match((QualifiedName)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.QualifiedName.");
		}

		public void log_match(final QualifiedName match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !module__name.match(match_value.constGetmodule__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".module_name");
							module__name.log_match(match_value.constGetmodule__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !testcase__name.match(match_value.constGettestcase__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".testcase_name");
							testcase__name.log_match(match_value.constGettestcase__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ module_name := ");
				module__name.log_match(match_value.constGetmodule__name(), legacy);
				TTCN_Logger.log_event_str("{ testcase_name := ");
				testcase__name.log_match(match_value.constGettestcase__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				module__name.encode_text(text_buf);
				testcase__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				module__name = new TitanCharString_template();
				module__name.decode_text(text_buf);
				testcase__name = new TitanCharString_template();
				testcase__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<QualifiedName_template>(size);
				for (int i = 0; i < size; i++) {
					final QualifiedName_template temp = new QualifiedName_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.QualifiedName has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettestcase__name().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("testcase_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettestcase__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.QualifiedName: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.QualifiedName");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.module__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.QualifiedName" : name, legacy);
				this.testcase__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.QualifiedName" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.QualifiedName" : name));
		}
	}
	public static void QualifiedName_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(QualifiedName_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger QualifiedName_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(QualifiedName_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Queue_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FunctionEvent_choice_random extends Base_Type {
		private final RandomAction operation; //Referenced_Type
		private final TitanFloat retval; //Float_Type
		private final TitanInteger intseed; //Integer_Type

		public FunctionEvent_choice_random() {
			this.operation = new RandomAction();
			this.retval = new TitanFloat();
			this.intseed = new TitanInteger();
		}

		public FunctionEvent_choice_random(final RandomAction operation, final TitanFloat retval, final TitanInteger intseed ) {
			this.operation = new RandomAction( operation );
			this.retval = new TitanFloat( retval );
			this.intseed = new TitanInteger( intseed );
		}

		public FunctionEvent_choice_random( final FunctionEvent_choice_random otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			operation = new RandomAction();
			retval = new TitanFloat();
			intseed = new TitanInteger();
			assign( otherValue );
		}

		public FunctionEvent_choice_random assign(final FunctionEvent_choice_random otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FunctionEvent.choice.random");
			}

			if (otherValue != this) {
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getretval().isBound() ) {
					this.retval.assign( otherValue.getretval() );
				} else {
					this.retval.cleanUp();
				}
				if ( otherValue.getintseed().isBound() ) {
					this.intseed.assign( otherValue.getintseed() );
				} else {
					this.intseed.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FunctionEvent_choice_random assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random ) {
				return assign((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent.choice.random", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			retval.cleanUp();
			intseed.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( retval.isBound() ) { return true; }
			if ( intseed.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !retval.isValue() ) { return false; }
			if ( !intseed.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FunctionEvent_choice_random otherValue) {
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.retval.operatorEquals( otherValue.retval ) ) { return false; }
			if ( !this.intseed.operatorEquals( otherValue.intseed ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random ) {
				return operatorEquals((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent.choice.random", otherValue));
		}

		public RandomAction getoperation() {
			return operation;
		}

		public RandomAction constGetoperation() {
			return operation;
		}

		public TitanFloat getretval() {
			return retval;
		}

		public TitanFloat constGetretval() {
			return retval;
		}

		public TitanInteger getintseed() {
			return intseed;
		}

		public TitanInteger constGetintseed() {
			return intseed;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" retval := ");
			retval.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" intseed := ");
			intseed.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.FunctionEvent.choice.random has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getretval().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getintseed().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("retval".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getretval().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("intseed".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getintseed().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FunctionEvent.choice.random: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.FunctionEvent.choice.random");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (retval.isBound()) {
				retval.set_implicit_omit();
			}
			if (intseed.isBound()) {
				intseed.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			retval.encode_text(text_buf);
			intseed.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			retval.decode_text(text_buf);
			intseed.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FunctionEvent_choice_random_template extends Base_Template {

		private RandomAction_template operation; //Referenced_Type
		private TitanFloat_template retval; //Float_Type
		private TitanInteger_template intseed; //Integer_Type
		//originally value_list/list_value
		private List<FunctionEvent_choice_random_template> list_value;

		public RandomAction_template getoperation() {
			setSpecific();
			return operation;
		}

		public RandomAction_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return operation;
		}

		public TitanFloat_template getretval() {
			setSpecific();
			return retval;
		}

		public TitanFloat_template constGetretval() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field retval of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return retval;
		}

		public TitanInteger_template getintseed() {
			setSpecific();
			return intseed;
		}

		public TitanInteger_template constGetintseed() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field intseed of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return intseed;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				operation = new RandomAction_template();
				retval = new TitanFloat_template();
				intseed = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					operation.assign(template_sel.ANY_VALUE);
					retval.assign(template_sel.ANY_VALUE);
					intseed.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public FunctionEvent_choice_random_template() {
			// do nothing
		}

		public FunctionEvent_choice_random_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public FunctionEvent_choice_random_template( final FunctionEvent_choice_random otherValue ) {
			copyValue(otherValue);
		}

		public FunctionEvent_choice_random_template( final FunctionEvent_choice_random_template otherValue ) {
			copyTemplate( otherValue );
		}

		public FunctionEvent_choice_random_template( final Optional<FunctionEvent_choice_random> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.FunctionEvent.choice.random from an unbound optional field.");
			}
		}

		//originally operator=
		public FunctionEvent_choice_random_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_choice_random_template assign( final FunctionEvent_choice_random other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_choice_random_template assign( final FunctionEvent_choice_random_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public FunctionEvent_choice_random_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random) {
				return assign((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent_choice_random' can not be cast to {1}", otherValue));
		}

		@Override
		public FunctionEvent_choice_random_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random_template) {
				return assign((FunctionEvent_choice_random_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent_choice_random' can not be cast to {1}_template", otherValue));
		}

		public FunctionEvent_choice_random_template assign( final Optional<FunctionEvent_choice_random> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return this;
		}

		private void copyValue(final FunctionEvent_choice_random other_value) {
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getretval().isBound()) {
				getretval().assign(other_value.getretval());
			} else {
				getretval().cleanUp();
			}
			if (other_value.getintseed().isBound()) {
				getintseed().assign(other_value.getintseed());
			} else {
				getintseed().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final FunctionEvent_choice_random_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getretval().get_selection()) {
					getretval().cleanUp();
				} else {
					getretval().assign(other_value.getretval());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getintseed().get_selection()) {
					getintseed().cleanUp();
				} else {
					getintseed().assign(other_value.getintseed());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<FunctionEvent_choice_random_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final FunctionEvent_choice_random_template temp = new FunctionEvent_choice_random_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FunctionEvent_choice_random valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			final FunctionEvent_choice_random ret_val = new FunctionEvent_choice_random();
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (retval.isBound()) {
				ret_val.getretval().assign(retval.valueOf());
			}
			if (intseed.isBound()) {
				ret_val.getintseed().assign(intseed.valueOf());
			}
			return ret_val;
		}

		public FunctionEvent_choice_random_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FunctionEvent_choice_random_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FunctionEvent_choice_random_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (retval.isBound()) {
				return true;
			}
			if (intseed.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!retval.isValue()) {
				return false;
			}
			if (!intseed.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FunctionEvent_choice_random other_value) {
			return match(other_value, false);
		}

		public boolean match(final FunctionEvent_choice_random other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getretval().isBound()) {
					return false;
				}
				if(!retval.match(other_value.getretval(), legacy)) {
					return false;
				}
				if(!other_value.getintseed().isBound()) {
					return false;
				}
				if(!intseed.match(other_value.getintseed(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FunctionEvent_choice_random) {
				return match((FunctionEvent_choice_random)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent_choice_random.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" retval := ");
				retval.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" intseed := ");
				intseed.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FunctionEvent_choice_random match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FunctionEvent_choice_random) {
				log_match((FunctionEvent_choice_random)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.random.");
		}

		public void log_match(final FunctionEvent_choice_random match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !retval.match(match_value.constGetretval(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".retval");
							retval.log_match(match_value.constGetretval(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !intseed.match(match_value.constGetintseed(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".intseed");
							intseed.log_match(match_value.constGetintseed(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ retval := ");
				retval.log_match(match_value.constGetretval(), legacy);
				TTCN_Logger.log_event_str("{ intseed := ");
				intseed.log_match(match_value.constGetintseed(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				retval.encode_text(text_buf);
				intseed.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new RandomAction_template();
				operation.decode_text(text_buf);
				retval = new TitanFloat_template();
				retval.decode_text(text_buf);
				intseed = new TitanInteger_template();
				intseed.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FunctionEvent_choice_random_template>(size);
				for (int i = 0; i < size; i++) {
					final FunctionEvent_choice_random_template temp = new FunctionEvent_choice_random_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.FunctionEvent.choice.random has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getretval().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getintseed().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("retval".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getretval().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("intseed".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getintseed().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FunctionEvent.choice.random: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.FunctionEvent.choice.random");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent.choice.random" : name, legacy);
				this.retval.check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent.choice.random" : name, legacy);
				this.intseed.check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent.choice.random" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FunctionEvent.choice.random" : name));
		}
	}
	public static void FunctionEvent_choice_random_encoder(final FunctionEvent_choice_random input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice.random' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_random_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_random_decoder( final TitanOctetString input_stream, final FunctionEvent_choice_random output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice.random' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_random_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingEvent_choice_matchingTimeout_encoder(final MatchingTimeout input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_matchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_matchingTimeout_decoder( final TitanOctetString input_stream, final MatchingTimeout output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_matchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLogEvent_severity_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_severity_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_severity_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_severity_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__out_sys__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_sys__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_tcp__port_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_tcp__port_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_tcp__port_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_tcp__port_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerType_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerType_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Dualface__mapped extends Base_Type {
		private final TitanBoolean incoming; //Boolean_Type
		private final TitanCharString target__type; //CharString_Type
		private final TitanCharString value__; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Dualface__mapped() {
			this.incoming = new TitanBoolean();
			this.target__type = new TitanCharString();
			this.value__ = new TitanCharString();
			this.msgid = new TitanInteger();
		}

		public Dualface__mapped(final TitanBoolean incoming, final TitanCharString target__type, final TitanCharString value__, final TitanInteger msgid ) {
			this.incoming = new TitanBoolean( incoming );
			this.target__type = new TitanCharString( target__type );
			this.value__ = new TitanCharString( value__ );
			this.msgid = new TitanInteger( msgid );
		}

		public Dualface__mapped( final Dualface__mapped otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Dualface_mapped.");
			}
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			value__ = new TitanCharString();
			msgid = new TitanInteger();
			assign( otherValue );
		}

		public Dualface__mapped assign(final Dualface__mapped otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Dualface_mapped");
			}

			if (otherValue != this) {
				if ( otherValue.getincoming().isBound() ) {
					this.incoming.assign( otherValue.getincoming() );
				} else {
					this.incoming.cleanUp();
				}
				if ( otherValue.gettarget__type().isBound() ) {
					this.target__type.assign( otherValue.gettarget__type() );
				} else {
					this.target__type.cleanUp();
				}
				if ( otherValue.getvalue__().isBound() ) {
					this.value__.assign( otherValue.getvalue__() );
				} else {
					this.value__.cleanUp();
				}
				if ( otherValue.getmsgid().isBound() ) {
					this.msgid.assign( otherValue.getmsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Dualface__mapped assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped ) {
				return assign((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_mapped", otherValue));
		}

		public void cleanUp() {
			incoming.cleanUp();
			target__type.cleanUp();
			value__.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( incoming.isBound() ) { return true; }
			if ( target__type.isBound() ) { return true; }
			if ( value__.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !incoming.isValue() ) { return false; }
			if ( !target__type.isValue() ) { return false; }
			if ( !value__.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Dualface__mapped otherValue) {
			if ( !this.incoming.operatorEquals( otherValue.incoming ) ) { return false; }
			if ( !this.target__type.operatorEquals( otherValue.target__type ) ) { return false; }
			if ( !this.value__.operatorEquals( otherValue.value__ ) ) { return false; }
			if ( !this.msgid.operatorEquals( otherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped ) {
				return operatorEquals((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_mapped", otherValue));
		}

		public TitanBoolean getincoming() {
			return incoming;
		}

		public TitanBoolean constGetincoming() {
			return incoming;
		}

		public TitanCharString gettarget__type() {
			return target__type;
		}

		public TitanCharString constGettarget__type() {
			return target__type;
		}

		public TitanCharString getvalue__() {
			return value__;
		}

		public TitanCharString constGetvalue__() {
			return value__;
		}

		public TitanInteger getmsgid() {
			return msgid;
		}

		public TitanInteger constGetmsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" incoming := ");
			incoming.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" target_type := ");
			target__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Dualface_mapped has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getincoming().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettarget__type().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("incoming".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getincoming().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("target_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettarget__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Dualface_mapped: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Dualface_mapped");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (incoming.isBound()) {
				incoming.set_implicit_omit();
			}
			if (target__type.isBound()) {
				target__type.set_implicit_omit();
			}
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			incoming.encode_text(text_buf);
			target__type.encode_text(text_buf);
			value__.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			incoming.decode_text(text_buf);
			target__type.decode_text(text_buf);
			value__.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Dualface__mapped_template extends Base_Template {

		private TitanBoolean_template incoming; //Boolean_Type
		private TitanCharString_template target__type; //CharString_Type
		private TitanCharString_template value__; //CharString_Type
		private TitanInteger_template msgid; //Integer_Type
		//originally value_list/list_value
		private List<Dualface__mapped_template> list_value;

		public TitanBoolean_template getincoming() {
			setSpecific();
			return incoming;
		}

		public TitanBoolean_template constGetincoming() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field incoming of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return incoming;
		}

		public TitanCharString_template gettarget__type() {
			setSpecific();
			return target__type;
		}

		public TitanCharString_template constGettarget__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field target_type of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return target__type;
		}

		public TitanCharString_template getvalue__() {
			setSpecific();
			return value__;
		}

		public TitanCharString_template constGetvalue__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return value__;
		}

		public TitanInteger_template getmsgid() {
			setSpecific();
			return msgid;
		}

		public TitanInteger_template constGetmsgid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return msgid;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				incoming = new TitanBoolean_template();
				target__type = new TitanCharString_template();
				value__ = new TitanCharString_template();
				msgid = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					incoming.assign(template_sel.ANY_VALUE);
					target__type.assign(template_sel.ANY_VALUE);
					value__.assign(template_sel.ANY_VALUE);
					msgid.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Dualface__mapped_template() {
			// do nothing
		}

		public Dualface__mapped_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Dualface__mapped_template( final Dualface__mapped otherValue ) {
			copyValue(otherValue);
		}

		public Dualface__mapped_template( final Dualface__mapped_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Dualface__mapped_template( final Optional<Dualface__mapped> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Dualface_mapped from an unbound optional field.");
			}
		}

		//originally operator=
		public Dualface__mapped_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Dualface__mapped_template assign( final Dualface__mapped other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Dualface__mapped_template assign( final Dualface__mapped_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Dualface__mapped_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped) {
				return assign((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__mapped' can not be cast to {1}", otherValue));
		}

		@Override
		public Dualface__mapped_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Dualface__mapped_template) {
				return assign((Dualface__mapped_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__mapped' can not be cast to {1}_template", otherValue));
		}

		public Dualface__mapped_template assign( final Optional<Dualface__mapped> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return this;
		}

		private void copyValue(final Dualface__mapped other_value) {
			if (other_value.getincoming().isBound()) {
				getincoming().assign(other_value.getincoming());
			} else {
				getincoming().cleanUp();
			}
			if (other_value.gettarget__type().isBound()) {
				gettarget__type().assign(other_value.gettarget__type());
			} else {
				gettarget__type().cleanUp();
			}
			if (other_value.getvalue__().isBound()) {
				getvalue__().assign(other_value.getvalue__());
			} else {
				getvalue__().cleanUp();
			}
			if (other_value.getmsgid().isBound()) {
				getmsgid().assign(other_value.getmsgid());
			} else {
				getmsgid().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Dualface__mapped_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getincoming().get_selection()) {
					getincoming().cleanUp();
				} else {
					getincoming().assign(other_value.getincoming());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettarget__type().get_selection()) {
					gettarget__type().cleanUp();
				} else {
					gettarget__type().assign(other_value.gettarget__type());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getvalue__().get_selection()) {
					getvalue__().cleanUp();
				} else {
					getvalue__().assign(other_value.getvalue__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmsgid().get_selection()) {
					getmsgid().cleanUp();
				} else {
					getmsgid().assign(other_value.getmsgid());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Dualface__mapped_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Dualface__mapped_template temp = new Dualface__mapped_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Dualface_mapped.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Dualface__mapped valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			final Dualface__mapped ret_val = new Dualface__mapped();
			if (incoming.isBound()) {
				ret_val.getincoming().assign(incoming.valueOf());
			}
			if (target__type.isBound()) {
				ret_val.gettarget__type().assign(target__type.valueOf());
			}
			if (value__.isBound()) {
				ret_val.getvalue__().assign(value__.valueOf());
			}
			if (msgid.isBound()) {
				ret_val.getmsgid().assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Dualface__mapped_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Dualface_mapped.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Dualface_mapped.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Dualface__mapped_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Dualface__mapped_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (incoming.isBound()) {
				return true;
			}
			if (target__type.isBound()) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!incoming.isValue()) {
				return false;
			}
			if (!target__type.isValue()) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Dualface__mapped other_value) {
			return match(other_value, false);
		}

		public boolean match(final Dualface__mapped other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getincoming().isBound()) {
					return false;
				}
				if(!incoming.match(other_value.getincoming(), legacy)) {
					return false;
				}
				if(!other_value.gettarget__type().isBound()) {
					return false;
				}
				if(!target__type.match(other_value.gettarget__type(), legacy)) {
					return false;
				}
				if(!other_value.getvalue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getvalue__(), legacy)) {
					return false;
				}
				if(!other_value.getmsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getmsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Dualface__mapped) {
				return match((Dualface__mapped)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Dualface__mapped.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" incoming := ");
				incoming.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" target_type := ");
				target__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Dualface__mapped match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Dualface__mapped) {
				log_match((Dualface__mapped)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Dualface_mapped.");
		}

		public void log_match(final Dualface__mapped match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !incoming.match(match_value.constGetincoming(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".incoming");
							incoming.log_match(match_value.constGetincoming(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !target__type.match(match_value.constGettarget__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".target_type");
							target__type.log_match(match_value.constGettarget__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !value__.match(match_value.constGetvalue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetvalue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetmsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetmsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ incoming := ");
				incoming.log_match(match_value.constGetincoming(), legacy);
				TTCN_Logger.log_event_str("{ target_type := ");
				target__type.log_match(match_value.constGettarget__type(), legacy);
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetvalue__(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetmsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming.encode_text(text_buf);
				target__type.encode_text(text_buf);
				value__.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming = new TitanBoolean_template();
				incoming.decode_text(text_buf);
				target__type = new TitanCharString_template();
				target__type.decode_text(text_buf);
				value__ = new TitanCharString_template();
				value__.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Dualface__mapped_template>(size);
				for (int i = 0; i < size; i++) {
					final Dualface__mapped_template temp = new Dualface__mapped_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Dualface_mapped has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getincoming().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettarget__type().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("incoming".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getincoming().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("target_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettarget__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Dualface_mapped: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Dualface_mapped");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.incoming.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_mapped" : name, legacy);
				this.target__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_mapped" : name, legacy);
				this.value__.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_mapped" : name, legacy);
				this.msgid.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_mapped" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Dualface_mapped" : name));
		}
	}
	public static void Dualface__mapped_encoder(final Dualface__mapped input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__mapped_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__mapped_decoder( final TitanOctetString input_stream, final Dualface__mapped output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__mapped_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLogEvent_sourceInfo__list extends Base_Type {

		private List<LocationInfo> valueElements;

		public TitanLogEvent_sourceInfo__list() {
			// do nothing
		}

		public TitanLogEvent_sourceInfo__list( final TitanLogEvent_sourceInfo__list otherValue ) {
			otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			valueElements = copyList( otherValue.valueElements );
		}

		public TitanLogEvent_sourceInfo__list(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<LocationInfo>();
		}

		private static final List<LocationInfo> copyList( final List<LocationInfo> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<LocationInfo> newList = new ArrayList<LocationInfo>( srcList.size() );
			for (final LocationInfo srcElem : srcList) {
				final LocationInfo newElem = getUnboundElem();
				if (srcElem.isBound()) {
					newElem.assign( srcElem );
				}
				newList.add( ( newElem ) );
			}
			return newList;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return valueElements != null;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !isBound() ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		@Override
		public boolean isValue() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final LocationInfo elem = valueElements.get(i);
				if (elem == null || !elem.isValue()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
				return operatorEquals((TitanLogEvent_sourceInfo__list)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLogEvent_sourceInfo__list.");
		}

		//originally operator==
		public boolean operatorEquals( final TitanLogEvent_sourceInfo__list otherValue ) {
			mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final LocationInfo leftElem = valueElements.get( i );
				final LocationInfo rightElem = otherValue.valueElements.get( i );
				if (leftElem.isBound()) {
					if (rightElem.isBound()) {
						if ( !leftElem.operatorEquals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.isBound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public TitanLogEvent_sourceInfo__list assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
				return assign((TitanLogEvent_sourceInfo__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
		}

		//originally operator=
		public TitanLogEvent_sourceInfo__list assign( final TitanLogEvent_sourceInfo__list aOtherValue ) {
			aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );

			valueElements = copyList( aOtherValue.valueElements );
			return this;
		}

		public TitanLogEvent_sourceInfo__list assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<LocationInfo>();
			return this;
		}

		//originally operator+
		public TitanLogEvent_sourceInfo__list concatenate(final TitanLogEvent_sourceInfo__list other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLogEvent.sourceInfo_list concatenation.");
			}
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final LocationInfo elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final LocationInfo elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			return ret_val;
		}

		public TitanLogEvent_sourceInfo__list concatenate(final TitanNull_Type nullValue) {
			return new TitanLogEvent_sourceInfo__list(this);
		}

		//originally operator<<=
		public TitanLogEvent_sourceInfo__list rotateLeft(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate left operator.");
			return rotateLeft(rotate_count.getInt());
		}

		//originally operator<<=
		public TitanLogEvent_sourceInfo__list rotateLeft(final int rotate_count) {
			return rotateRight(-rotate_count);
		}

		//originally operator>>=
		public TitanLogEvent_sourceInfo__list rotateRight(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate right operator.");
			return rotateRight(rotate_count.getInt());
		}

		//originally operator>>=
		public TitanLogEvent_sourceInfo__list rotateRight(final int rotate_count) {
			if (valueElements == null) {
				throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			final int size = valueElements.size();
			if (size == 0) {
				return new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new TitanLogEvent_sourceInfo__list(this);
			}
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final LocationInfo elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final LocationInfo elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			return ret_val;
		}

		//originally clean_up
		public void cleanUp() {
			valueElements = null;
		}

		//originally get_at(int)
		public LocationInfo getAt( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				setSize(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final LocationInfo newElem = getUnboundElem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		//originally get_at(const INTEGER&)
		public LocationInfo getAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
			return getAt( index_value.getInt() );
		}

		//originally get_at(int) const
		public LocationInfo constGetAt( final int index_value ) {
			if ( !isBound() ) {
				throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
			}
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().getInt();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final LocationInfo elem = valueElements.get( index_value );
			return ( elem != null ) ? elem : getUnboundElem();
		}

		//originally get_at(const INTEGER&) const
		public LocationInfo constGetAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
			return constGetAt( index_value.getInt() );
		}

		public TitanInteger sizeOf() {
			mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return sizeOf();
		}

		public TitanInteger lengthOf() {
			mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final LocationInfo elem = valueElements.get( i );
				if ( elem != null && elem.isBound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void setSize(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<LocationInfo>();
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new LocationInfo() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static LocationInfo getUnboundElem() {
			return new LocationInfo();
		}
		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */

		@Override
		public String toString() {
			if (!isBound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public TitanLogEvent_sourceInfo__list substr(final int index, final int returncount) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLogEvent.sourceInfo_list","element");
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new LocationInfo(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list repl) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			if (repl.valueElements == null) {
				throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLogEvent.sourceInfo_list","element");
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final LocationInfo elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final LocationInfo elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final LocationInfo elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new LocationInfo(elem));
				}
			}
			return ret_val;
		}

		public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueOf());
		}

		public TitanLogEvent_sourceInfo__list replace(final int index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.getInt(), repl.valueOf());
		}

		public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len, repl.valueOf());
		}

		public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len.getInt(), repl.valueOf());
		}
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					setSize(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(i).set_param(current);
							if (!constGetAt(i).isBound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						getAt(current.get_id().get_index()).set_param(current);
						if (!constGetAt(current.get_id().get_index()).isBound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLogEvent.sourceInfo_list");
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!isBound()) {
						assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthOf().getInt();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLogEvent.sourceInfo_list");
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<LocationInfo>(temp);
			for (int i = 0; i < temp; i++) {
				final LocationInfo temp2 = new LocationInfo();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLogEvent_sourceInfo__list_template extends Record_Of_Template {

		//originally single_value/value_elements
		private List<LocationInfo_template> value_elements;

		//originally value_list/list_value
		private List<TitanLogEvent_sourceInfo__list_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((TitanLogEvent_sourceInfo__list)value_ptr, value_index, (TitanLogEvent_sourceInfo__list_template)template_ptr, template_index, legacy);
			}
		};

		public TitanLogEvent_sourceInfo__list_template() {
			// do nothing
		}

		public TitanLogEvent_sourceInfo__list_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLogEvent_sourceInfo__list_template( final TitanLogEvent_sourceInfo__list otherValue ) {
			copy_value( otherValue );
		}

		public TitanLogEvent_sourceInfo__list_template( final TitanLogEvent_sourceInfo__list_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLogEvent_sourceInfo__list_template( final Optional<TitanLogEvent_sourceInfo__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list from an unbound optional field.");
			}
		}

		public TitanLogEvent_sourceInfo__list_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<LocationInfo_template>();
		}

		private void copy_value(final TitanLogEvent_sourceInfo__list other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list with an unbound value.");
			}
			value_elements = new ArrayList<LocationInfo_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new LocationInfo_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new LocationInfo_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLogEvent_sourceInfo__list_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<LocationInfo_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGetAt(elem_count).isBound()) {
						value_elements.add( new LocationInfo_template(other_value.constGetAt(elem_count)) );
					} else {
						value_elements.add( new LocationInfo_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLogEvent_sourceInfo__list_template temp = new TitanLogEvent_sourceInfo__list_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		// originally match
		public boolean match(final TitanLogEvent_sourceInfo__list other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final TitanLogEvent_sourceInfo__list other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
		}

		private boolean match_index(final TitanLogEvent_sourceInfo__list value_ptr, final int value_index, final TitanLogEvent_sourceInfo__list_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
				return match((TitanLogEvent_sourceInfo__list)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		//originally operator=
		public TitanLogEvent_sourceInfo__list_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLogEvent_sourceInfo__list_template assign( final TitanLogEvent_sourceInfo__list other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public TitanLogEvent_sourceInfo__list_template assign( final TitanLogEvent_sourceInfo__list_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLogEvent_sourceInfo__list_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
				return assign((TitanLogEvent_sourceInfo__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
		}

		@Override
		public TitanLogEvent_sourceInfo__list_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLogEvent_sourceInfo__list_template) {
				return assign((TitanLogEvent_sourceInfo__list_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list_template.");
		}

		public TitanLogEvent_sourceInfo__list_template assign( final Optional<TitanLogEvent_sourceInfo__list> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			return this;
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl.valueOf());
		}

		public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
		}

		public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl);
		}

		public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl);
		}

		public LocationInfo_template getAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: {0}.", index_value ) );
			}

			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				setSize(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			return value_elements.get(index_value);
		}

		public LocationInfo_template getAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}

			return getAt(index_value.getInt());
		}

		public LocationInfo_template constGetAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: {0}.", index_value ) );
			}

			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public LocationInfo_template constGetAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}

			return constGetAt(index_value.getInt());
		}

		private int get_length_for_concat(final AtomicBoolean is_any_value) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					if (templateSelection == template_sel.ANY_VALUE) {
						// ? => { * }
						is_any_value.set( true );
						return 1;
					}
					throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
				case RANGE_LENGTH_RESTRICTION:
					if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
						throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
					}
					// else fall through (range length restriction is allowed if the minimum
					// and maximum value are the same)
				case SINGLE_LENGTH_RESTRICTION:
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
				}
			default:
				throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
			}
		}

		private int get_length_for_concat(final TitanLogEvent_sourceInfo__list operand) {
			operand.mustBound("Operand of record of template concatenation is an unbound value.");
			return operand.valueElements.size();
		}


		private int get_length_for_concat(final template_sel operand) {
			if (operand == template_sel.ANY_VALUE) {
				// ? => { * }
				return 1;
			}
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}

		//TODO: simplify, just use value_elements.add()
		private void concat(final AtomicInteger pos, final TitanLogEvent_sourceInfo__list_template operand) {
			// all errors should have already been caught by the operand's
			// get_length_for_concat() call;
			// the result template (this) should already be set to SPECIFIC_VALUE and
			// single_value.value_elements should already be allocated
			switch (operand.templateSelection) {
			case SPECIFIC_VALUE:
				for (int i = 0; i < operand.value_elements.size(); ++i) {
					value_elements.set( pos.get() + i, new LocationInfo_template(operand.value_elements.get(i)) );
				}
				pos.addAndGet( operand.value_elements.size() );
				break;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (operand.length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					// ? => { * }
					value_elements.set( pos.get(), new LocationInfo_template( template_sel.ANY_OR_OMIT ) );
					pos.incrementAndGet();
					break;
				case RANGE_LENGTH_RESTRICTION:
				case SINGLE_LENGTH_RESTRICTION: {
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
					for (int i = 0; i < N; ++i) {
						value_elements.set( pos.get() + i, new LocationInfo_template( template_sel.ANY_VALUE ) );
					}
					pos.addAndGet( N );
					break; }
				}
			default:
				break;
			}
		}

		public void setSize(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			final template_sel old_selection = templateSelection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<LocationInfo_template>();
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new LocationInfo_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new LocationInfo_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				final int oldSize = value_elements.size();
				for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
					value_elements.remove( new_size );
				}
			}
		}

		public TitanInteger sizeOf() {
			return sizeOf(true);
		}

		public TitanInteger lengthOf() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (templateSelection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.size()<1) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).getInt();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "LocationInfo_template"));
		}

		public TitanInteger n_elem() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type TitanLogEvent_sourceInfo__list containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.");
		}

		private boolean matchv(final TitanLogEvent_sourceInfo__list other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).matchv(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.");
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).isValue()) {
					return false;
				}
			}
			return true;
		}

		public void setType(final template_sel template_type, final int list_length) {
			cleanUp();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new TitanLogEvent_sourceInfo__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			set_selection(template_type);
		}

		public TitanLogEvent_sourceInfo__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			return list_value.get(list_index);
		}

		public TitanLogEvent_sourceInfo__list_template get_list_item(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			if (list_index < 0) {
				throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index ({0}).", list_index ) );
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			return list_value.get( list_index );
		}

		public TitanLogEvent_sourceInfo__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLogEvent_sourceInfo__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final TitanLogEvent_sourceInfo__list match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLogEvent_sourceInfo__list) {
				log_match((TitanLogEvent_sourceInfo__list)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}

		public void log_match(final TitanLogEvent_sourceInfo__list match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
				}
				value_elements = new ArrayList<LocationInfo_template>(temp);
				for (int i = 0; i < temp; i++) {
					final LocationInfo_template temp2 = new LocationInfo_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLogEvent_sourceInfo__list_template temp2 = new TitanLogEvent_sourceInfo__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					setSize(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					getAt(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				setSize(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							getAt(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						getAt(current_index).set_param(param.get_elem(i));
						current_index++;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@TitanLoggerApi.TitanLogEvent.sourceInfo_list");
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (templateSelection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++)
					value_elements.get(i).check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLogEvent.sourceInfo_list" : name, false);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) return;
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLogEvent.sourceInfo_list" : name));
		}
	}
	public static void TitanLogEvent_sourceInfo__list_encoder(final TitanLogEvent_sourceInfo__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent.sourceInfo_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_sourceInfo__list_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_sourceInfo__list_decoder( final TitanOctetString input_stream, final TitanLogEvent_sourceInfo__list output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent.sourceInfo_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_sourceInfo__list_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class VerdictType extends Base_Type {
		private final Verdict fromVerdict; //Referenced_Type
		private final Verdict toVerdict; //Referenced_Type
		private final Optional<TitanCharString> verdictReason; //CharString_Type

		public VerdictType() {
			this.fromVerdict = new Verdict();
			this.toVerdict = new Verdict();
			this.verdictReason = new Optional<TitanCharString>(TitanCharString.class);
		}

		public VerdictType(final Verdict fromVerdict, final Verdict toVerdict, final Optional<TitanCharString> verdictReason ) {
			this.fromVerdict = new Verdict( fromVerdict );
			this.toVerdict = new Verdict( toVerdict );
			this.verdictReason = new Optional<TitanCharString>(TitanCharString.class);
			this.verdictReason.assign( verdictReason );
		}

		public VerdictType( final VerdictType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.VerdictType.");
			}
			fromVerdict = new Verdict();
			toVerdict = new Verdict();
			verdictReason = new Optional<TitanCharString>(TitanCharString.class);
			assign( otherValue );
		}

		public VerdictType assign(final VerdictType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.VerdictType");
			}

			if (otherValue != this) {
				if ( otherValue.getfromVerdict().isBound() ) {
					this.fromVerdict.assign( otherValue.getfromVerdict() );
				} else {
					this.fromVerdict.cleanUp();
				}
				if ( otherValue.gettoVerdict().isBound() ) {
					this.toVerdict.assign( otherValue.gettoVerdict() );
				} else {
					this.toVerdict.cleanUp();
				}
				if ( otherValue.getverdictReason().isBound() ) {
					this.verdictReason.assign( otherValue.getverdictReason() );
				} else {
					this.verdictReason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public VerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType ) {
				return assign((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictType", otherValue));
		}

		public void cleanUp() {
			fromVerdict.cleanUp();
			toVerdict.cleanUp();
			verdictReason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( fromVerdict.isBound() ) { return true; }
			if ( toVerdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(verdictReason.get_selection()) || verdictReason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !fromVerdict.isValue() ) { return false; }
			if ( !toVerdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(verdictReason.get_selection()) && !verdictReason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final VerdictType otherValue) {
			if ( !this.fromVerdict.operatorEquals( otherValue.fromVerdict ) ) { return false; }
			if ( !this.toVerdict.operatorEquals( otherValue.toVerdict ) ) { return false; }
			if ( !this.verdictReason.operatorEquals( otherValue.verdictReason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType ) {
				return operatorEquals((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictType", otherValue));
		}

		public Verdict getfromVerdict() {
			return fromVerdict;
		}

		public Verdict constGetfromVerdict() {
			return fromVerdict;
		}

		public Verdict gettoVerdict() {
			return toVerdict;
		}

		public Verdict constGettoVerdict() {
			return toVerdict;
		}

		public Optional<TitanCharString> getverdictReason() {
			return verdictReason;
		}

		public Optional<TitanCharString> constGetverdictReason() {
			return verdictReason;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			if (verdictReason.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" fromVerdict := ");
			fromVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" toVerdict := ");
			toVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdictReason := ");
			verdictReason.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.VerdictType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfromVerdict().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettoVerdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdictReason().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fromVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfromVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("toVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettoVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdictReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdictReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.VerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.VerdictType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (fromVerdict.isBound()) {
				fromVerdict.set_implicit_omit();
			}
			if (toVerdict.isBound()) {
				toVerdict.set_implicit_omit();
			}
			if (verdictReason.isBound()) {
				verdictReason.set_implicit_omit();
			} else {
				verdictReason.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			fromVerdict.encode_text(text_buf);
			toVerdict.encode_text(text_buf);
			verdictReason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			fromVerdict.decode_text(text_buf);
			toVerdict.decode_text(text_buf);
			verdictReason.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class VerdictType_template extends Base_Template {

		private Verdict_template fromVerdict; //Referenced_Type
		private Verdict_template toVerdict; //Referenced_Type
		private TitanCharString_template verdictReason; //CharString_Type
		//originally value_list/list_value
		private List<VerdictType_template> list_value;

		public Verdict_template getfromVerdict() {
			setSpecific();
			return fromVerdict;
		}

		public Verdict_template constGetfromVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field fromVerdict of a non-specific template of type @TitanLoggerApi.VerdictType.");
			}
			return fromVerdict;
		}

		public Verdict_template gettoVerdict() {
			setSpecific();
			return toVerdict;
		}

		public Verdict_template constGettoVerdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field toVerdict of a non-specific template of type @TitanLoggerApi.VerdictType.");
			}
			return toVerdict;
		}

		public TitanCharString_template getverdictReason() {
			setSpecific();
			return verdictReason;
		}

		public TitanCharString_template constGetverdictReason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field verdictReason of a non-specific template of type @TitanLoggerApi.VerdictType.");
			}
			return verdictReason;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				fromVerdict = new Verdict_template();
				toVerdict = new Verdict_template();
				verdictReason = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					fromVerdict.assign(template_sel.ANY_VALUE);
					toVerdict.assign(template_sel.ANY_VALUE);
					verdictReason.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public VerdictType_template() {
			// do nothing
		}

		public VerdictType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public VerdictType_template( final VerdictType otherValue ) {
			copyValue(otherValue);
		}

		public VerdictType_template( final VerdictType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public VerdictType_template( final Optional<VerdictType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.VerdictType from an unbound optional field.");
			}
		}

		//originally operator=
		public VerdictType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public VerdictType_template assign( final VerdictType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public VerdictType_template assign( final VerdictType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public VerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType) {
				return assign((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public VerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof VerdictType_template) {
				return assign((VerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictType' can not be cast to {1}_template", otherValue));
		}

		public VerdictType_template assign( final Optional<VerdictType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.VerdictType.");
			}
			return this;
		}

		private void copyValue(final VerdictType other_value) {
			if (other_value.getfromVerdict().isBound()) {
				getfromVerdict().assign(other_value.getfromVerdict());
			} else {
				getfromVerdict().cleanUp();
			}
			if (other_value.gettoVerdict().isBound()) {
				gettoVerdict().assign(other_value.gettoVerdict());
			} else {
				gettoVerdict().cleanUp();
			}
			if (other_value.getverdictReason().isBound()) {
				if (other_value.getverdictReason().isPresent()) {
					getverdictReason().assign(other_value.getverdictReason().get());
				} else {
					getverdictReason().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getverdictReason().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final VerdictType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfromVerdict().get_selection()) {
					getfromVerdict().cleanUp();
				} else {
					getfromVerdict().assign(other_value.getfromVerdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettoVerdict().get_selection()) {
					gettoVerdict().cleanUp();
				} else {
					gettoVerdict().assign(other_value.gettoVerdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getverdictReason().get_selection()) {
					getverdictReason().cleanUp();
				} else {
					getverdictReason().assign(other_value.getverdictReason());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<VerdictType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final VerdictType_template temp = new VerdictType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.VerdictType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public VerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.VerdictType.");
			}
			final VerdictType ret_val = new VerdictType();
			if (fromVerdict.isBound()) {
				ret_val.getfromVerdict().assign(fromVerdict.valueOf());
			}
			if (toVerdict.isBound()) {
				ret_val.gettoVerdict().assign(toVerdict.valueOf());
			}
			if (verdictReason.isOmit()) {
				ret_val.getverdictReason().assign(template_sel.OMIT_VALUE);
			} else if (verdictReason.isBound()) {
				ret_val.getverdictReason().assign(verdictReason.valueOf());
			}
			return ret_val;
		}

		public VerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.VerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.VerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.VerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<VerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new VerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (fromVerdict.isBound()) {
				return true;
			}
			if (toVerdict.isBound()) {
				return true;
			}
			if (verdictReason.isOmit() || verdictReason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!fromVerdict.isValue()) {
				return false;
			}
			if (!toVerdict.isValue()) {
				return false;
			}
			if (!verdictReason.isOmit() && !verdictReason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final VerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final VerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getfromVerdict().isBound()) {
					return false;
				}
				if(!fromVerdict.match(other_value.getfromVerdict(), legacy)) {
					return false;
				}
				if(!other_value.gettoVerdict().isBound()) {
					return false;
				}
				if(!toVerdict.match(other_value.gettoVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getverdictReason().isBound()) {
					return false;
				}
				if((other_value.getverdictReason().isPresent() ? !verdictReason.match(other_value.getverdictReason().get(), legacy) : !verdictReason.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof VerdictType) {
				return match((VerdictType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				if (verdictReason.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" fromVerdict := ");
				fromVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" toVerdict := ");
				toVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdictReason := ");
				verdictReason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final VerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof VerdictType) {
				log_match((VerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictType.");
		}

		public void log_match(final VerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !fromVerdict.match(match_value.constGetfromVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".fromVerdict");
							fromVerdict.log_match(match_value.constGetfromVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !toVerdict.match(match_value.constGettoVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".toVerdict");
							toVerdict.log_match(match_value.constGettoVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetverdictReason().isPresent()) {
							if( !verdictReason.match(match_value.constGetverdictReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".verdictReason");
								verdictReason.log_match(match_value.constGetverdictReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!verdictReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".verdictReason := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								verdictReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ fromVerdict := ");
				fromVerdict.log_match(match_value.constGetfromVerdict(), legacy);
				TTCN_Logger.log_event_str("{ toVerdict := ");
				toVerdict.log_match(match_value.constGettoVerdict(), legacy);
				TTCN_Logger.log_event_str("{ verdictReason := ");
				verdictReason.log_match(match_value.constGetverdictReason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				fromVerdict.encode_text(text_buf);
				toVerdict.encode_text(text_buf);
				verdictReason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				fromVerdict = new Verdict_template();
				fromVerdict.decode_text(text_buf);
				toVerdict = new Verdict_template();
				toVerdict.decode_text(text_buf);
				verdictReason = new TitanCharString_template();
				verdictReason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<VerdictType_template>(size);
				for (int i = 0; i < size; i++) {
					final VerdictType_template temp = new VerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.VerdictType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.VerdictType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfromVerdict().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettoVerdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdictReason().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fromVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfromVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("toVerdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettoVerdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdictReason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdictReason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.VerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.VerdictType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.fromVerdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictType" : name, legacy);
				this.toVerdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictType" : name, legacy);
				this.verdictReason.check_restriction(restriction, name == null ? "@TitanLoggerApi.VerdictType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.VerdictType" : name));
		}
	}
	public static void VerdictType_encoder(final VerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictType_decoder( final TitanOctetString input_stream, final VerdictType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_functionEvent_encoder(final FunctionEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_functionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_functionEvent_decoder( final TitanOctetString input_stream, final FunctionEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_functionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultOp_id_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultOp_id_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultOp_id_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultOp_id_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_matchingEvent_encoder(final MatchingEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_matchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_matchingEvent_decoder( final TitanOctetString input_stream, final MatchingEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_matchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TestcaseType_name_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseType_name_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__State_operation extends Base_Type {
		public enum enum_type {
			started (0),
			stopped (1),
			halted (2),
			UNKNOWN_VALUE(3),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return started;
				case 1:  return stopped;
				case 2:  return halted;
				case 3:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Port__State_operation() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Port__State_operation(final Port__State_operation otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Port__State_operation(final Port__State_operation.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Port__State_operation(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__State_operation' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Port__State_operation assign(final Port__State_operation otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Port__State_operation assign(final Base_Type otherValue){
			if( otherValue instanceof Port__State_operation ) {
				return assign((Port__State_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Port__State_operation assign(final Port__State_operation.enum_type otherValue){
			return assign( new Port__State_operation(otherValue) );
		}

		//originally operator=
		public Port__State_operation assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__State_operation'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Port__State_operation otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Port__State_operation) {
				return operatorEquals( (Port__State_operation) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.operation.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Port__State_operation.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__State_operation otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__State_operation.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Port__State_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Port__State_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__State_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__State_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__State_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__State_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__State_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__State_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Port__State_operation.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Port__State_operation enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("started".equals(strPar)) {
				return enum_type.started;
			}
			if ("stopped".equals(strPar)) {
				return enum_type.stopped;
			}
			if ("halted".equals(strPar)) {
				return enum_type.halted;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Port_State.operation");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Port_State.operation.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_State.operation.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_State.operation.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__State_operation_template extends Base_Template {
		// single_value
		private Port__State_operation.enum_type single_value;
		// value_list part
		private ArrayList<Port__State_operation_template> value_list;

		private void copy_template(final Port__State_operation_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Port__State_operation_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Port__State_operation_template temp = new Port__State_operation_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__State_operation.");
			}
		}

		public Port__State_operation_template() {
			// do nothing
		}

		public Port__State_operation_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Port__State_operation_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Port__State_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Port__State_operation with unknown numeric value "+ otherValue +".");
			}
			single_value = Port__State_operation.enum_type.getValue(otherValue);
		}

		public Port__State_operation_template(final Port__State_operation otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Port__State_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Port__State_operation. ");
			}
			single_value = otherValue.enum_value;
		}

		public Port__State_operation_template(final Port__State_operation_template otherValue) {
			copy_template(otherValue);
		}

		public Port__State_operation_template(final Port__State_operation.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Port__State_operation.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Port__State_operation_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Port__State_operation_template assign(final int otherValue) {
			if (!Port__State_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__State_operation.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Port__State_operation_template assign(final Port__State_operation.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Port__State_operation_template assign(final Port__State_operation_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Port__State_operation_template assign(final Port__State_operation otherValue){
			if (otherValue.enum_value == Port__State_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Port__State_operation to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Port__State_operation_template assign(final Base_Type otherValue){
			if( otherValue instanceof Port__State_operation ) {
				return assign((Port__State_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__State_operation_template assign(final Base_Template otherValue){
			if( otherValue instanceof Port__State_operation_template ) {
				return assign((Port__State_operation_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Port__State_operation.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Port__State_operation.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__State_operation.");
			}
		}

		// originally match
		public boolean match(final Port__State_operation otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Port__State_operation otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Port__State_operation ) {
				return match((Port__State_operation) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
		}

		public Port__State_operation valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__State_operation.");
			}
			return new Port__State_operation(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__State_operation.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Port__State_operation_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Port__State_operation_template());
			}
		}

		public Port__State_operation_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__State_operation.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Port__State_operation.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Port__State_operation.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Port__State_operation.enum2str(single_value), Port__State_operation.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__State_operation) {
				log_match((Port__State_operation)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.operation.");
		}
		public void log_match(final Port__State_operation match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Port__State_operation.enum_type enum_value = Port__State_operation.str_to_enum(param.get_enumerated());
				if (!Port__State_operation.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Port_State.operation.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Port_State.operation");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_State.operation.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Port__State_operation.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_State.operation.", temp));
				}
				single_value = Port__State_operation.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Port__State_operation_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__State_operation_template temp = new Port__State_operation_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_State.operation.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_State.operation" : name));
		}
	}
	public static void Port__State_operation_encoder(final Port__State_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__State_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__State_operation_decoder( final TitanOctetString input_stream, final Port__State_operation output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__State_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Setstate_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Setstate_info_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Setstate_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Setstate_info_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_executorEvent_encoder(final ExecutorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_executorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_executorEvent_decoder( final TitanOctetString input_stream, final ExecutorEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_executorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorUnqualified_port___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorUnqualified_port___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorUnqualified_port___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorUnqualified_port___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_controlpartFinish_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_controlpartFinish_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_controlpartFinish_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_controlpartFinish_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LocationInfo_line_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LocationInfo_line_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LocationInfo_line_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LocationInfo_line_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__oper extends Base_Type {
		public enum enum_type {
			call__op (0),
			exception__op (1),
			reply__op (2),
			UNKNOWN_VALUE(3),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return call__op;
				case 1:  return exception__op;
				case 2:  return reply__op;
				case 3:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Port__oper() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Port__oper(final Port__oper otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Port__oper(final Port__oper.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Port__oper(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__oper' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Port__oper assign(final Port__oper otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Port__oper assign(final Base_Type otherValue){
			if( otherValue instanceof Port__oper ) {
				return assign((Port__oper) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Port__oper assign(final Port__oper.enum_type otherValue){
			return assign( new Port__oper(otherValue) );
		}

		//originally operator=
		public Port__oper assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__oper'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Port__oper otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Port__oper) {
				return operatorEquals( (Port__oper) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_oper.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Port__oper.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__oper otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__oper.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Port__oper.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Port__oper otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__oper.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__oper otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__oper.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__oper otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__oper.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__oper otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Port__oper.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Port__oper enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("call__op".equals(strPar) || "call_op".equals(strPar)) {
				return enum_type.call__op;
			}
			if ("exception__op".equals(strPar) || "exception_op".equals(strPar)) {
				return enum_type.exception__op;
			}
			if ("reply__op".equals(strPar) || "reply_op".equals(strPar)) {
				return enum_type.reply__op;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Port_oper");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Port_oper.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_oper.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_oper.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__oper_template extends Base_Template {
		// single_value
		private Port__oper.enum_type single_value;
		// value_list part
		private ArrayList<Port__oper_template> value_list;

		private void copy_template(final Port__oper_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Port__oper_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Port__oper_template temp = new Port__oper_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__oper.");
			}
		}

		public Port__oper_template() {
			// do nothing
		}

		public Port__oper_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Port__oper_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Port__oper.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Port__oper with unknown numeric value "+ otherValue +".");
			}
			single_value = Port__oper.enum_type.getValue(otherValue);
		}

		public Port__oper_template(final Port__oper otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Port__oper.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Port__oper. ");
			}
			single_value = otherValue.enum_value;
		}

		public Port__oper_template(final Port__oper_template otherValue) {
			copy_template(otherValue);
		}

		public Port__oper_template(final Port__oper.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Port__oper.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Port__oper_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Port__oper_template assign(final int otherValue) {
			if (!Port__oper.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__oper.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Port__oper_template assign(final Port__oper.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Port__oper_template assign(final Port__oper_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Port__oper_template assign(final Port__oper otherValue){
			if (otherValue.enum_value == Port__oper.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Port__oper to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Port__oper_template assign(final Base_Type otherValue){
			if( otherValue instanceof Port__oper ) {
				return assign((Port__oper) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__oper_template assign(final Base_Template otherValue){
			if( otherValue instanceof Port__oper_template ) {
				return assign((Port__oper_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Port__oper.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Port__oper.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__oper.");
			}
		}

		// originally match
		public boolean match(final Port__oper otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Port__oper otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Port__oper ) {
				return match((Port__oper) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
		}

		public Port__oper valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__oper.");
			}
			return new Port__oper(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__oper.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Port__oper_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Port__oper_template());
			}
		}

		public Port__oper_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__oper.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Port__oper.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Port__oper.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Port__oper.enum2str(single_value), Port__oper.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__oper) {
				log_match((Port__oper)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_oper.");
		}
		public void log_match(final Port__oper match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Port__oper.enum_type enum_value = Port__oper.str_to_enum(param.get_enumerated());
				if (!Port__oper.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Port_oper.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Port_oper");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_oper.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Port__oper.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_oper.", temp));
				}
				single_value = Port__oper.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Port__oper_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__oper_template temp = new Port__oper_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_oper.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_oper" : name));
		}
	}
	public static void Port__oper_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__oper_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__oper_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__oper_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelEvent_choice_parallelPort_encoder(final ParPort input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelEvent_choice_parallelPort_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelEvent_choice_parallelPort_decoder( final TitanOctetString input_stream, final ParPort output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelEvent_choice_parallelPort_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ComponentIDType_id_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ComponentIDType_id_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ComponentIDType_id_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ComponentIDType_id_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultOp_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultOp_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultOp_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultOp_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParPort_dstPort_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_dstPort_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_dstPort_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_dstPort_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingSuccessType_port__type_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingSuccessType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingSuccessType_port__type_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingSuccessType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingDoneType_return__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingDoneType_return__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingDoneType_return__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingDoneType_return__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_portQueue_encoder(final Port__Queue input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_portQueue_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_portQueue_decoder( final TitanOctetString input_stream, final Port__Queue output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_portQueue_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void WarningEvent_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(WarningEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger WarningEvent_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(WarningEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimestampType extends Base_Type {
		private final TitanInteger seconds; //Integer_Type
		private final TitanInteger microSeconds; //Integer_Type

		public TimestampType() {
			this.seconds = new TitanInteger();
			this.microSeconds = new TitanInteger();
		}

		public TimestampType(final TitanInteger seconds, final TitanInteger microSeconds ) {
			this.seconds = new TitanInteger( seconds );
			this.microSeconds = new TitanInteger( microSeconds );
		}

		public TimestampType( final TimestampType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimestampType.");
			}
			seconds = new TitanInteger();
			microSeconds = new TitanInteger();
			assign( otherValue );
		}

		public TimestampType assign(final TimestampType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimestampType");
			}

			if (otherValue != this) {
				if ( otherValue.getseconds().isBound() ) {
					this.seconds.assign( otherValue.getseconds() );
				} else {
					this.seconds.cleanUp();
				}
				if ( otherValue.getmicroSeconds().isBound() ) {
					this.microSeconds.assign( otherValue.getmicroSeconds() );
				} else {
					this.microSeconds.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimestampType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType ) {
				return assign((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimestampType", otherValue));
		}

		public void cleanUp() {
			seconds.cleanUp();
			microSeconds.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( seconds.isBound() ) { return true; }
			if ( microSeconds.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !seconds.isValue() ) { return false; }
			if ( !microSeconds.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimestampType otherValue) {
			if ( !this.seconds.operatorEquals( otherValue.seconds ) ) { return false; }
			if ( !this.microSeconds.operatorEquals( otherValue.microSeconds ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType ) {
				return operatorEquals((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimestampType", otherValue));
		}

		public TitanInteger getseconds() {
			return seconds;
		}

		public TitanInteger constGetseconds() {
			return seconds;
		}

		public TitanInteger getmicroSeconds() {
			return microSeconds;
		}

		public TitanInteger constGetmicroSeconds() {
			return microSeconds;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" seconds := ");
			seconds.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" microSeconds := ");
			microSeconds.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TimestampType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getseconds().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmicroSeconds().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("seconds".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getseconds().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("microSeconds".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmicroSeconds().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimestampType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TimestampType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (seconds.isBound()) {
				seconds.set_implicit_omit();
			}
			if (microSeconds.isBound()) {
				microSeconds.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			seconds.encode_text(text_buf);
			microSeconds.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			seconds.decode_text(text_buf);
			microSeconds.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TimestampType_template extends Base_Template {

		private TitanInteger_template seconds; //Integer_Type
		private TitanInteger_template microSeconds; //Integer_Type
		//originally value_list/list_value
		private List<TimestampType_template> list_value;

		public TitanInteger_template getseconds() {
			setSpecific();
			return seconds;
		}

		public TitanInteger_template constGetseconds() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field seconds of a non-specific template of type @TitanLoggerApi.TimestampType.");
			}
			return seconds;
		}

		public TitanInteger_template getmicroSeconds() {
			setSpecific();
			return microSeconds;
		}

		public TitanInteger_template constGetmicroSeconds() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field microSeconds of a non-specific template of type @TitanLoggerApi.TimestampType.");
			}
			return microSeconds;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				seconds = new TitanInteger_template();
				microSeconds = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					seconds.assign(template_sel.ANY_VALUE);
					microSeconds.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TimestampType_template() {
			// do nothing
		}

		public TimestampType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TimestampType_template( final TimestampType otherValue ) {
			copyValue(otherValue);
		}

		public TimestampType_template( final TimestampType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TimestampType_template( final Optional<TimestampType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TimestampType from an unbound optional field.");
			}
		}

		//originally operator=
		public TimestampType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimestampType_template assign( final TimestampType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TimestampType_template assign( final TimestampType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TimestampType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType) {
				return assign((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimestampType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimestampType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimestampType_template) {
				return assign((TimestampType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimestampType' can not be cast to {1}_template", otherValue));
		}

		public TimestampType_template assign( final Optional<TimestampType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimestampType.");
			}
			return this;
		}

		private void copyValue(final TimestampType other_value) {
			if (other_value.getseconds().isBound()) {
				getseconds().assign(other_value.getseconds());
			} else {
				getseconds().cleanUp();
			}
			if (other_value.getmicroSeconds().isBound()) {
				getmicroSeconds().assign(other_value.getmicroSeconds());
			} else {
				getmicroSeconds().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TimestampType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getseconds().get_selection()) {
					getseconds().cleanUp();
				} else {
					getseconds().assign(other_value.getseconds());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmicroSeconds().get_selection()) {
					getmicroSeconds().cleanUp();
				} else {
					getmicroSeconds().assign(other_value.getmicroSeconds());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TimestampType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TimestampType_template temp = new TimestampType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimestampType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimestampType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimestampType.");
			}
			final TimestampType ret_val = new TimestampType();
			if (seconds.isBound()) {
				ret_val.getseconds().assign(seconds.valueOf());
			}
			if (microSeconds.isBound()) {
				ret_val.getmicroSeconds().assign(microSeconds.valueOf());
			}
			return ret_val;
		}

		public TimestampType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimestampType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimestampType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimestampType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimestampType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimestampType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (seconds.isBound()) {
				return true;
			}
			if (microSeconds.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!seconds.isValue()) {
				return false;
			}
			if (!microSeconds.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimestampType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimestampType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getseconds().isBound()) {
					return false;
				}
				if(!seconds.match(other_value.getseconds(), legacy)) {
					return false;
				}
				if(!other_value.getmicroSeconds().isBound()) {
					return false;
				}
				if(!microSeconds.match(other_value.getmicroSeconds(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TimestampType) {
				return match((TimestampType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TimestampType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" seconds := ");
				seconds.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" microSeconds := ");
				microSeconds.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimestampType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimestampType) {
				log_match((TimestampType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimestampType.");
		}

		public void log_match(final TimestampType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !seconds.match(match_value.constGetseconds(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".seconds");
							seconds.log_match(match_value.constGetseconds(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !microSeconds.match(match_value.constGetmicroSeconds(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".microSeconds");
							microSeconds.log_match(match_value.constGetmicroSeconds(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ seconds := ");
				seconds.log_match(match_value.constGetseconds(), legacy);
				TTCN_Logger.log_event_str("{ microSeconds := ");
				microSeconds.log_match(match_value.constGetmicroSeconds(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				seconds.encode_text(text_buf);
				microSeconds.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				seconds = new TitanInteger_template();
				seconds.decode_text(text_buf);
				microSeconds = new TitanInteger_template();
				microSeconds.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimestampType_template>(size);
				for (int i = 0; i < size; i++) {
					final TimestampType_template temp = new TimestampType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimestampType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TimestampType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getseconds().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmicroSeconds().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("seconds".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getseconds().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("microSeconds".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmicroSeconds().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimestampType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TimestampType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.seconds.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimestampType" : name, legacy);
				this.microSeconds.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimestampType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimestampType" : name));
		}
	}
	public static void TimestampType_encoder(final TimestampType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimestampType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimestampType_decoder( final TitanOctetString input_stream, final TimestampType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimestampType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Setstate extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final TitanCharString state; //CharString_Type
		private final TitanCharString info; //CharString_Type

		public Setstate() {
			this.port__name = new TitanCharString();
			this.state = new TitanCharString();
			this.info = new TitanCharString();
		}

		public Setstate(final TitanCharString port__name, final TitanCharString state, final TitanCharString info ) {
			this.port__name = new TitanCharString( port__name );
			this.state = new TitanCharString( state );
			this.info = new TitanCharString( info );
		}

		public Setstate( final Setstate otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Setstate.");
			}
			port__name = new TitanCharString();
			state = new TitanCharString();
			info = new TitanCharString();
			assign( otherValue );
		}

		public Setstate assign(final Setstate otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Setstate");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getstate().isBound() ) {
					this.state.assign( otherValue.getstate() );
				} else {
					this.state.cleanUp();
				}
				if ( otherValue.getinfo().isBound() ) {
					this.info.assign( otherValue.getinfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Setstate assign(final Base_Type otherValue) {
			if (otherValue instanceof Setstate ) {
				return assign((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Setstate", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			state.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( state.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !state.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Setstate otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.state.operatorEquals( otherValue.state ) ) { return false; }
			if ( !this.info.operatorEquals( otherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Setstate ) {
				return operatorEquals((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Setstate", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanCharString getstate() {
			return state;
		}

		public TitanCharString constGetstate() {
			return state;
		}

		public TitanCharString getinfo() {
			return info;
		}

		public TitanCharString constGetinfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" state := ");
			state.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Setstate has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstate().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("state".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstate().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Setstate: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Setstate");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (state.isBound()) {
				state.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			state.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			state.decode_text(text_buf);
			info.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Setstate_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private TitanCharString_template state; //CharString_Type
		private TitanCharString_template info; //CharString_Type
		//originally value_list/list_value
		private List<Setstate_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Setstate.");
			}
			return port__name;
		}

		public TitanCharString_template getstate() {
			setSpecific();
			return state;
		}

		public TitanCharString_template constGetstate() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field state of a non-specific template of type @TitanLoggerApi.Setstate.");
			}
			return state;
		}

		public TitanCharString_template getinfo() {
			setSpecific();
			return info;
		}

		public TitanCharString_template constGetinfo() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.Setstate.");
			}
			return info;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				state = new TitanCharString_template();
				info = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					state.assign(template_sel.ANY_VALUE);
					info.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Setstate_template() {
			// do nothing
		}

		public Setstate_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Setstate_template( final Setstate otherValue ) {
			copyValue(otherValue);
		}

		public Setstate_template( final Setstate_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Setstate_template( final Optional<Setstate> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Setstate from an unbound optional field.");
			}
		}

		//originally operator=
		public Setstate_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Setstate_template assign( final Setstate other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Setstate_template assign( final Setstate_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Setstate_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Setstate) {
				return assign((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Setstate' can not be cast to {1}", otherValue));
		}

		@Override
		public Setstate_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Setstate_template) {
				return assign((Setstate_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Setstate' can not be cast to {1}_template", otherValue));
		}

		public Setstate_template assign( final Optional<Setstate> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Setstate.");
			}
			return this;
		}

		private void copyValue(final Setstate other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getstate().isBound()) {
				getstate().assign(other_value.getstate());
			} else {
				getstate().cleanUp();
			}
			if (other_value.getinfo().isBound()) {
				getinfo().assign(other_value.getinfo());
			} else {
				getinfo().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Setstate_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getstate().get_selection()) {
					getstate().cleanUp();
				} else {
					getstate().assign(other_value.getstate());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getinfo().get_selection()) {
					getinfo().cleanUp();
				} else {
					getinfo().assign(other_value.getinfo());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Setstate_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Setstate_template temp = new Setstate_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Setstate.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Setstate valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Setstate.");
			}
			final Setstate ret_val = new Setstate();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (state.isBound()) {
				ret_val.getstate().assign(state.valueOf());
			}
			if (info.isBound()) {
				ret_val.getinfo().assign(info.valueOf());
			}
			return ret_val;
		}

		public Setstate_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Setstate.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Setstate.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Setstate.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Setstate_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Setstate_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (state.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!state.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Setstate other_value) {
			return match(other_value, false);
		}

		public boolean match(final Setstate other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getstate().isBound()) {
					return false;
				}
				if(!state.match(other_value.getstate(), legacy)) {
					return false;
				}
				if(!other_value.getinfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getinfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Setstate) {
				return match((Setstate)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Setstate.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" state := ");
				state.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Setstate match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Setstate) {
				log_match((Setstate)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Setstate.");
		}

		public void log_match(final Setstate match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !state.match(match_value.constGetstate(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".state");
							state.log_match(match_value.constGetstate(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetinfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetinfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ state := ");
				state.log_match(match_value.constGetstate(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetinfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				state.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				state = new TitanCharString_template();
				state.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Setstate_template>(size);
				for (int i = 0; i < size; i++) {
					final Setstate_template temp = new Setstate_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Setstate.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Setstate has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstate().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("state".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstate().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Setstate: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Setstate");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Setstate" : name, legacy);
				this.state.check_restriction(restriction, name == null ? "@TitanLoggerApi.Setstate" : name, legacy);
				this.info.check_restriction(restriction, name == null ? "@TitanLoggerApi.Setstate" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Setstate" : name));
		}
	}
	public static void Setstate_encoder(final Setstate input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Setstate_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Setstate_decoder( final TitanOctetString input_stream, final Setstate output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Setstate_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_verdictOp_encoder(final VerdictOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_verdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_verdictOp_decoder( final TitanOctetString input_stream, final VerdictOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_verdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_inconcPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_inconcPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_inconcPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_inconcPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void VerdictType_fromVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictType_fromVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictType_fromVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictType_fromVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelEvent_choice_parallelPTC_encoder(final ParallelPTC input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelEvent_choice_parallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelEvent_choice_parallelPTC_decoder( final TitanOctetString input_stream, final ParallelPTC output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelEvent_choice_parallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Proc__port__in extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Port__oper operation; //Referenced_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanBoolean check__; //Boolean_Type
		private final TitanCharString parameter; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Proc__port__in() {
			this.port__name = new TitanCharString();
			this.operation = new Port__oper();
			this.compref = new TitanInteger();
			this.check__ = new TitanBoolean();
			this.parameter = new TitanCharString();
			this.msgid = new TitanInteger();
		}

		public Proc__port__in(final TitanCharString port__name, final Port__oper operation, final TitanInteger compref, final TitanBoolean check__, final TitanCharString parameter, final TitanInteger msgid ) {
			this.port__name = new TitanCharString( port__name );
			this.operation = new Port__oper( operation );
			this.compref = new TitanInteger( compref );
			this.check__ = new TitanBoolean( check__ );
			this.parameter = new TitanCharString( parameter );
			this.msgid = new TitanInteger( msgid );
		}

		public Proc__port__in( final Proc__port__in otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Proc_port_in.");
			}
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			check__ = new TitanBoolean();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
			assign( otherValue );
		}

		public Proc__port__in assign(final Proc__port__in otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Proc_port_in");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getcheck__().isBound() ) {
					this.check__.assign( otherValue.getcheck__() );
				} else {
					this.check__.cleanUp();
				}
				if ( otherValue.getparameter().isBound() ) {
					this.parameter.assign( otherValue.getparameter() );
				} else {
					this.parameter.cleanUp();
				}
				if ( otherValue.getmsgid().isBound() ) {
					this.msgid.assign( otherValue.getmsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Proc__port__in assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in ) {
				return assign((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_in", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			check__.cleanUp();
			parameter.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( check__.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !check__.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Proc__port__in otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.check__.operatorEquals( otherValue.check__ ) ) { return false; }
			if ( !this.parameter.operatorEquals( otherValue.parameter ) ) { return false; }
			if ( !this.msgid.operatorEquals( otherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in ) {
				return operatorEquals((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_in", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public Port__oper getoperation() {
			return operation;
		}

		public Port__oper constGetoperation() {
			return operation;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanBoolean getcheck__() {
			return check__;
		}

		public TitanBoolean constGetcheck__() {
			return check__;
		}

		public TitanCharString getparameter() {
			return parameter;
		}

		public TitanCharString constGetparameter() {
			return parameter;
		}

		public TitanInteger getmsgid() {
			return msgid;
		}

		public TitanInteger constGetmsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(6);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" check_ := ");
			check__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Proc_port_in has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcheck__().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("check_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcheck__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Proc_port_in: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Proc_port_in");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (check__.isBound()) {
				check__.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			check__.encode_text(text_buf);
			parameter.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			check__.decode_text(text_buf);
			parameter.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Proc__port__in_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private Port__oper_template operation; //Referenced_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanBoolean_template check__; //Boolean_Type
		private TitanCharString_template parameter; //CharString_Type
		private TitanInteger_template msgid; //Integer_Type
		//originally value_list/list_value
		private List<Proc__port__in_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return port__name;
		}

		public Port__oper_template getoperation() {
			setSpecific();
			return operation;
		}

		public Port__oper_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return operation;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return compref;
		}

		public TitanBoolean_template getcheck__() {
			setSpecific();
			return check__;
		}

		public TitanBoolean_template constGetcheck__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field check_ of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return check__;
		}

		public TitanCharString_template getparameter() {
			setSpecific();
			return parameter;
		}

		public TitanCharString_template constGetparameter() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return parameter;
		}

		public TitanInteger_template getmsgid() {
			setSpecific();
			return msgid;
		}

		public TitanInteger_template constGetmsgid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			return msgid;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				operation = new Port__oper_template();
				compref = new TitanInteger_template();
				check__ = new TitanBoolean_template();
				parameter = new TitanCharString_template();
				msgid = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					operation.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					check__.assign(template_sel.ANY_VALUE);
					parameter.assign(template_sel.ANY_VALUE);
					msgid.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Proc__port__in_template() {
			// do nothing
		}

		public Proc__port__in_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Proc__port__in_template( final Proc__port__in otherValue ) {
			copyValue(otherValue);
		}

		public Proc__port__in_template( final Proc__port__in_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Proc__port__in_template( final Optional<Proc__port__in> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Proc_port_in from an unbound optional field.");
			}
		}

		//originally operator=
		public Proc__port__in_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Proc__port__in_template assign( final Proc__port__in other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Proc__port__in_template assign( final Proc__port__in_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Proc__port__in_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in) {
				return assign((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__in' can not be cast to {1}", otherValue));
		}

		@Override
		public Proc__port__in_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Proc__port__in_template) {
				return assign((Proc__port__in_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__in' can not be cast to {1}_template", otherValue));
		}

		public Proc__port__in_template assign( final Optional<Proc__port__in> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Proc_port_in.");
			}
			return this;
		}

		private void copyValue(final Proc__port__in other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getcheck__().isBound()) {
				getcheck__().assign(other_value.getcheck__());
			} else {
				getcheck__().cleanUp();
			}
			if (other_value.getparameter().isBound()) {
				getparameter().assign(other_value.getparameter());
			} else {
				getparameter().cleanUp();
			}
			if (other_value.getmsgid().isBound()) {
				getmsgid().assign(other_value.getmsgid());
			} else {
				getmsgid().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Proc__port__in_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcheck__().get_selection()) {
					getcheck__().cleanUp();
				} else {
					getcheck__().assign(other_value.getcheck__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparameter().get_selection()) {
					getparameter().cleanUp();
				} else {
					getparameter().assign(other_value.getparameter());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmsgid().get_selection()) {
					getmsgid().cleanUp();
				} else {
					getmsgid().assign(other_value.getmsgid());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Proc__port__in_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Proc__port__in_template temp = new Proc__port__in_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Proc_port_in.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Proc__port__in valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			final Proc__port__in ret_val = new Proc__port__in();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (check__.isBound()) {
				ret_val.getcheck__().assign(check__.valueOf());
			}
			if (parameter.isBound()) {
				ret_val.getparameter().assign(parameter.valueOf());
			}
			if (msgid.isBound()) {
				ret_val.getmsgid().assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Proc__port__in_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Proc_port_in.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Proc_port_in.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Proc_port_in.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Proc__port__in_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Proc__port__in_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (check__.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!check__.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Proc__port__in other_value) {
			return match(other_value, false);
		}

		public boolean match(final Proc__port__in other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getcheck__().isBound()) {
					return false;
				}
				if(!check__.match(other_value.getcheck__(), legacy)) {
					return false;
				}
				if(!other_value.getparameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getparameter(), legacy)) {
					return false;
				}
				if(!other_value.getmsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getmsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Proc__port__in) {
				return match((Proc__port__in)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Proc__port__in.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(6);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" check_ := ");
				check__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Proc__port__in match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Proc__port__in) {
				log_match((Proc__port__in)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Proc_port_in.");
		}

		public void log_match(final Proc__port__in match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !check__.match(match_value.constGetcheck__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".check_");
							check__.log_match(match_value.constGetcheck__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetparameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetparameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetmsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetmsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ check_ := ");
				check__.log_match(match_value.constGetcheck__(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetparameter(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetmsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				check__.encode_text(text_buf);
				parameter.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Port__oper_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				check__ = new TitanBoolean_template();
				check__.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Proc__port__in_template>(size);
				for (int i = 0; i < size; i++) {
					final Proc__port__in_template temp = new Proc__port__in_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Proc_port_in has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcheck__().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("check_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcheck__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Proc_port_in: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Proc_port_in");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				this.check__.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				this.parameter.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				this.msgid.check_restriction(restriction, name == null ? "@TitanLoggerApi.Proc_port_in" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Proc_port_in" : name));
		}
	}
	public static void Proc__port__in_encoder(final Proc__port__in input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_decoder( final TitanOctetString input_stream, final Proc__port__in output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLogEvent extends Base_Type {
		private final TimestampType timestamp; //Referenced_Type
		private final TitanLogEvent_sourceInfo__list sourceInfo__list; //SequenceOf_Type
		private final TitanInteger severity; //Integer_Type
		private final LogEventType logEvent; //Referenced_Type

		public TitanLogEvent() {
			this.timestamp = new TimestampType();
			this.sourceInfo__list = new TitanLogEvent_sourceInfo__list();
			this.severity = new TitanInteger();
			this.logEvent = new LogEventType();
		}

		public TitanLogEvent(final TimestampType timestamp, final TitanLogEvent_sourceInfo__list sourceInfo__list, final TitanInteger severity, final LogEventType logEvent ) {
			this.timestamp = new TimestampType( timestamp );
			this.sourceInfo__list = new TitanLogEvent_sourceInfo__list( sourceInfo__list );
			this.severity = new TitanInteger( severity );
			this.logEvent = new LogEventType( logEvent );
		}

		public TitanLogEvent( final TitanLogEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLogEvent.");
			}
			timestamp = new TimestampType();
			sourceInfo__list = new TitanLogEvent_sourceInfo__list();
			severity = new TitanInteger();
			logEvent = new LogEventType();
			assign( otherValue );
		}

		public TitanLogEvent assign(final TitanLogEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLogEvent");
			}

			if (otherValue != this) {
				if ( otherValue.gettimestamp().isBound() ) {
					this.timestamp.assign( otherValue.gettimestamp() );
				} else {
					this.timestamp.cleanUp();
				}
				if ( otherValue.getsourceInfo__list().isBound() ) {
					this.sourceInfo__list.assign( otherValue.getsourceInfo__list() );
				} else {
					this.sourceInfo__list.cleanUp();
				}
				if ( otherValue.getseverity().isBound() ) {
					this.severity.assign( otherValue.getseverity() );
				} else {
					this.severity.cleanUp();
				}
				if ( otherValue.getlogEvent().isBound() ) {
					this.logEvent.assign( otherValue.getlogEvent() );
				} else {
					this.logEvent.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLogEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent ) {
				return assign((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLogEvent", otherValue));
		}

		public void cleanUp() {
			timestamp.cleanUp();
			sourceInfo__list.cleanUp();
			severity.cleanUp();
			logEvent.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( timestamp.isBound() ) { return true; }
			if ( sourceInfo__list.isBound() ) { return true; }
			if ( severity.isBound() ) { return true; }
			if ( logEvent.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !timestamp.isValue() ) { return false; }
			if ( !sourceInfo__list.isValue() ) { return false; }
			if ( !severity.isValue() ) { return false; }
			if ( !logEvent.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLogEvent otherValue) {
			if ( !this.timestamp.operatorEquals( otherValue.timestamp ) ) { return false; }
			if ( !this.sourceInfo__list.operatorEquals( otherValue.sourceInfo__list ) ) { return false; }
			if ( !this.severity.operatorEquals( otherValue.severity ) ) { return false; }
			if ( !this.logEvent.operatorEquals( otherValue.logEvent ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent ) {
				return operatorEquals((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLogEvent", otherValue));
		}

		public TimestampType gettimestamp() {
			return timestamp;
		}

		public TimestampType constGettimestamp() {
			return timestamp;
		}

		public TitanLogEvent_sourceInfo__list getsourceInfo__list() {
			return sourceInfo__list;
		}

		public TitanLogEvent_sourceInfo__list constGetsourceInfo__list() {
			return sourceInfo__list;
		}

		public TitanInteger getseverity() {
			return severity;
		}

		public TitanInteger constGetseverity() {
			return severity;
		}

		public LogEventType getlogEvent() {
			return logEvent;
		}

		public LogEventType constGetlogEvent() {
			return logEvent;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" timestamp := ");
			timestamp.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sourceInfo_list := ");
			sourceInfo__list.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" severity := ");
			severity.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" logEvent := ");
			logEvent.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TitanLogEvent has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettimestamp().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsourceInfo__list().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getseverity().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlogEvent().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("timestamp".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettimestamp().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sourceInfo_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsourceInfo__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("severity".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getseverity().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("logEvent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlogEvent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLogEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TitanLogEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (timestamp.isBound()) {
				timestamp.set_implicit_omit();
			}
			if (sourceInfo__list.isBound()) {
				sourceInfo__list.set_implicit_omit();
			}
			if (severity.isBound()) {
				severity.set_implicit_omit();
			}
			if (logEvent.isBound()) {
				logEvent.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			timestamp.encode_text(text_buf);
			sourceInfo__list.encode_text(text_buf);
			severity.encode_text(text_buf);
			logEvent.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			timestamp.decode_text(text_buf);
			sourceInfo__list.decode_text(text_buf);
			severity.decode_text(text_buf);
			logEvent.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLogEvent_template extends Base_Template {

		private TimestampType_template timestamp; //Referenced_Type
		private TitanLogEvent_sourceInfo__list_template sourceInfo__list; //SequenceOf_Type
		private TitanInteger_template severity; //Integer_Type
		private LogEventType_template logEvent; //Referenced_Type
		//originally value_list/list_value
		private List<TitanLogEvent_template> list_value;

		public TimestampType_template gettimestamp() {
			setSpecific();
			return timestamp;
		}

		public TimestampType_template constGettimestamp() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field timestamp of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return timestamp;
		}

		public TitanLogEvent_sourceInfo__list_template getsourceInfo__list() {
			setSpecific();
			return sourceInfo__list;
		}

		public TitanLogEvent_sourceInfo__list_template constGetsourceInfo__list() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sourceInfo_list of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return sourceInfo__list;
		}

		public TitanInteger_template getseverity() {
			setSpecific();
			return severity;
		}

		public TitanInteger_template constGetseverity() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field severity of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return severity;
		}

		public LogEventType_template getlogEvent() {
			setSpecific();
			return logEvent;
		}

		public LogEventType_template constGetlogEvent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field logEvent of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return logEvent;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				timestamp = new TimestampType_template();
				sourceInfo__list = new TitanLogEvent_sourceInfo__list_template();
				severity = new TitanInteger_template();
				logEvent = new LogEventType_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					timestamp.assign(template_sel.ANY_VALUE);
					sourceInfo__list.assign(template_sel.ANY_VALUE);
					severity.assign(template_sel.ANY_VALUE);
					logEvent.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TitanLogEvent_template() {
			// do nothing
		}

		public TitanLogEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLogEvent_template( final TitanLogEvent otherValue ) {
			copyValue(otherValue);
		}

		public TitanLogEvent_template( final TitanLogEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLogEvent_template( final Optional<TitanLogEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLogEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public TitanLogEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLogEvent_template assign( final TitanLogEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TitanLogEvent_template assign( final TitanLogEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLogEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent) {
				return assign((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLogEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLogEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLogEvent_template) {
				return assign((TitanLogEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLogEvent' can not be cast to {1}_template", otherValue));
		}

		public TitanLogEvent_template assign( final Optional<TitanLogEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return this;
		}

		private void copyValue(final TitanLogEvent other_value) {
			if (other_value.gettimestamp().isBound()) {
				gettimestamp().assign(other_value.gettimestamp());
			} else {
				gettimestamp().cleanUp();
			}
			if (other_value.getsourceInfo__list().isBound()) {
				getsourceInfo__list().assign(other_value.getsourceInfo__list());
			} else {
				getsourceInfo__list().cleanUp();
			}
			if (other_value.getseverity().isBound()) {
				getseverity().assign(other_value.getseverity());
			} else {
				getseverity().cleanUp();
			}
			if (other_value.getlogEvent().isBound()) {
				getlogEvent().assign(other_value.getlogEvent());
			} else {
				getlogEvent().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLogEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettimestamp().get_selection()) {
					gettimestamp().cleanUp();
				} else {
					gettimestamp().assign(other_value.gettimestamp());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsourceInfo__list().get_selection()) {
					getsourceInfo__list().cleanUp();
				} else {
					getsourceInfo__list().assign(other_value.getsourceInfo__list());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getseverity().get_selection()) {
					getseverity().cleanUp();
				} else {
					getseverity().assign(other_value.getseverity());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getlogEvent().get_selection()) {
					getlogEvent().cleanUp();
				} else {
					getlogEvent().assign(other_value.getlogEvent());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLogEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLogEvent_template temp = new TitanLogEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLogEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLogEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			final TitanLogEvent ret_val = new TitanLogEvent();
			if (timestamp.isBound()) {
				ret_val.gettimestamp().assign(timestamp.valueOf());
			}
			if (sourceInfo__list.isBound()) {
				ret_val.getsourceInfo__list().assign(sourceInfo__list.valueOf());
			}
			if (severity.isBound()) {
				ret_val.getseverity().assign(severity.valueOf());
			}
			if (logEvent.isBound()) {
				ret_val.getlogEvent().assign(logEvent.valueOf());
			}
			return ret_val;
		}

		public TitanLogEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLogEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLogEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLogEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (timestamp.isBound()) {
				return true;
			}
			if (sourceInfo__list.isBound()) {
				return true;
			}
			if (severity.isBound()) {
				return true;
			}
			if (logEvent.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!timestamp.isValue()) {
				return false;
			}
			if (!sourceInfo__list.isValue()) {
				return false;
			}
			if (!severity.isValue()) {
				return false;
			}
			if (!logEvent.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLogEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLogEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.gettimestamp().isBound()) {
					return false;
				}
				if(!timestamp.match(other_value.gettimestamp(), legacy)) {
					return false;
				}
				if(!other_value.getsourceInfo__list().isBound()) {
					return false;
				}
				if(!sourceInfo__list.match(other_value.getsourceInfo__list(), legacy)) {
					return false;
				}
				if(!other_value.getseverity().isBound()) {
					return false;
				}
				if(!severity.match(other_value.getseverity(), legacy)) {
					return false;
				}
				if(!other_value.getlogEvent().isBound()) {
					return false;
				}
				if(!logEvent.match(other_value.getlogEvent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLogEvent) {
				return match((TitanLogEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" timestamp := ");
				timestamp.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sourceInfo_list := ");
				sourceInfo__list.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" severity := ");
				severity.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" logEvent := ");
				logEvent.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLogEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLogEvent) {
				log_match((TitanLogEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLogEvent.");
		}

		public void log_match(final TitanLogEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !timestamp.match(match_value.constGettimestamp(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".timestamp");
							timestamp.log_match(match_value.constGettimestamp(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sourceInfo__list.match(match_value.constGetsourceInfo__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sourceInfo_list");
							sourceInfo__list.log_match(match_value.constGetsourceInfo__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !severity.match(match_value.constGetseverity(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".severity");
							severity.log_match(match_value.constGetseverity(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !logEvent.match(match_value.constGetlogEvent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".logEvent");
							logEvent.log_match(match_value.constGetlogEvent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ timestamp := ");
				timestamp.log_match(match_value.constGettimestamp(), legacy);
				TTCN_Logger.log_event_str("{ sourceInfo_list := ");
				sourceInfo__list.log_match(match_value.constGetsourceInfo__list(), legacy);
				TTCN_Logger.log_event_str("{ severity := ");
				severity.log_match(match_value.constGetseverity(), legacy);
				TTCN_Logger.log_event_str("{ logEvent := ");
				logEvent.log_match(match_value.constGetlogEvent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timestamp.encode_text(text_buf);
				sourceInfo__list.encode_text(text_buf);
				severity.encode_text(text_buf);
				logEvent.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timestamp = new TimestampType_template();
				timestamp.decode_text(text_buf);
				sourceInfo__list = new TitanLogEvent_sourceInfo__list_template();
				sourceInfo__list.decode_text(text_buf);
				severity = new TitanInteger_template();
				severity.decode_text(text_buf);
				logEvent = new LogEventType_template();
				logEvent.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLogEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLogEvent_template temp = new TitanLogEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TitanLogEvent has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettimestamp().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsourceInfo__list().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getseverity().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getlogEvent().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("timestamp".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettimestamp().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sourceInfo_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsourceInfo__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("severity".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getseverity().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("logEvent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getlogEvent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLogEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TitanLogEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.timestamp.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLogEvent" : name, legacy);
				this.sourceInfo__list.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLogEvent" : name, legacy);
				this.severity.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLogEvent" : name, legacy);
				this.logEvent.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLogEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLogEvent" : name));
		}
	}
	public static void TitanLogEvent_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class StatisticsType_choice_verdictStatistics extends Base_Type {
		private final TitanInteger none__; //Integer_Type
		private final TitanFloat nonePercent; //Float_Type
		private final TitanInteger pass__; //Integer_Type
		private final TitanFloat passPercent; //Float_Type
		private final TitanInteger inconc__; //Integer_Type
		private final TitanFloat inconcPercent; //Float_Type
		private final TitanInteger fail__; //Integer_Type
		private final TitanFloat failPercent; //Float_Type
		private final TitanInteger error__; //Integer_Type
		private final TitanFloat errorPercent; //Float_Type

		public StatisticsType_choice_verdictStatistics() {
			this.none__ = new TitanInteger();
			this.nonePercent = new TitanFloat();
			this.pass__ = new TitanInteger();
			this.passPercent = new TitanFloat();
			this.inconc__ = new TitanInteger();
			this.inconcPercent = new TitanFloat();
			this.fail__ = new TitanInteger();
			this.failPercent = new TitanFloat();
			this.error__ = new TitanInteger();
			this.errorPercent = new TitanFloat();
		}

		public StatisticsType_choice_verdictStatistics(final TitanInteger none__, final TitanFloat nonePercent, final TitanInteger pass__, final TitanFloat passPercent, final TitanInteger inconc__, final TitanFloat inconcPercent, final TitanInteger fail__, final TitanFloat failPercent, final TitanInteger error__, final TitanFloat errorPercent ) {
			this.none__ = new TitanInteger( none__ );
			this.nonePercent = new TitanFloat( nonePercent );
			this.pass__ = new TitanInteger( pass__ );
			this.passPercent = new TitanFloat( passPercent );
			this.inconc__ = new TitanInteger( inconc__ );
			this.inconcPercent = new TitanFloat( inconcPercent );
			this.fail__ = new TitanInteger( fail__ );
			this.failPercent = new TitanFloat( failPercent );
			this.error__ = new TitanInteger( error__ );
			this.errorPercent = new TitanFloat( errorPercent );
		}

		public StatisticsType_choice_verdictStatistics( final StatisticsType_choice_verdictStatistics otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			none__ = new TitanInteger();
			nonePercent = new TitanFloat();
			pass__ = new TitanInteger();
			passPercent = new TitanFloat();
			inconc__ = new TitanInteger();
			inconcPercent = new TitanFloat();
			fail__ = new TitanInteger();
			failPercent = new TitanFloat();
			error__ = new TitanInteger();
			errorPercent = new TitanFloat();
			assign( otherValue );
		}

		public StatisticsType_choice_verdictStatistics assign(final StatisticsType_choice_verdictStatistics otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics");
			}

			if (otherValue != this) {
				if ( otherValue.getnone__().isBound() ) {
					this.none__.assign( otherValue.getnone__() );
				} else {
					this.none__.cleanUp();
				}
				if ( otherValue.getnonePercent().isBound() ) {
					this.nonePercent.assign( otherValue.getnonePercent() );
				} else {
					this.nonePercent.cleanUp();
				}
				if ( otherValue.getpass__().isBound() ) {
					this.pass__.assign( otherValue.getpass__() );
				} else {
					this.pass__.cleanUp();
				}
				if ( otherValue.getpassPercent().isBound() ) {
					this.passPercent.assign( otherValue.getpassPercent() );
				} else {
					this.passPercent.cleanUp();
				}
				if ( otherValue.getinconc__().isBound() ) {
					this.inconc__.assign( otherValue.getinconc__() );
				} else {
					this.inconc__.cleanUp();
				}
				if ( otherValue.getinconcPercent().isBound() ) {
					this.inconcPercent.assign( otherValue.getinconcPercent() );
				} else {
					this.inconcPercent.cleanUp();
				}
				if ( otherValue.getfail__().isBound() ) {
					this.fail__.assign( otherValue.getfail__() );
				} else {
					this.fail__.cleanUp();
				}
				if ( otherValue.getfailPercent().isBound() ) {
					this.failPercent.assign( otherValue.getfailPercent() );
				} else {
					this.failPercent.cleanUp();
				}
				if ( otherValue.geterror__().isBound() ) {
					this.error__.assign( otherValue.geterror__() );
				} else {
					this.error__.cleanUp();
				}
				if ( otherValue.geterrorPercent().isBound() ) {
					this.errorPercent.assign( otherValue.geterrorPercent() );
				} else {
					this.errorPercent.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StatisticsType_choice_verdictStatistics assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics ) {
				return assign((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics", otherValue));
		}

		public void cleanUp() {
			none__.cleanUp();
			nonePercent.cleanUp();
			pass__.cleanUp();
			passPercent.cleanUp();
			inconc__.cleanUp();
			inconcPercent.cleanUp();
			fail__.cleanUp();
			failPercent.cleanUp();
			error__.cleanUp();
			errorPercent.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( none__.isBound() ) { return true; }
			if ( nonePercent.isBound() ) { return true; }
			if ( pass__.isBound() ) { return true; }
			if ( passPercent.isBound() ) { return true; }
			if ( inconc__.isBound() ) { return true; }
			if ( inconcPercent.isBound() ) { return true; }
			if ( fail__.isBound() ) { return true; }
			if ( failPercent.isBound() ) { return true; }
			if ( error__.isBound() ) { return true; }
			if ( errorPercent.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !none__.isValue() ) { return false; }
			if ( !nonePercent.isValue() ) { return false; }
			if ( !pass__.isValue() ) { return false; }
			if ( !passPercent.isValue() ) { return false; }
			if ( !inconc__.isValue() ) { return false; }
			if ( !inconcPercent.isValue() ) { return false; }
			if ( !fail__.isValue() ) { return false; }
			if ( !failPercent.isValue() ) { return false; }
			if ( !error__.isValue() ) { return false; }
			if ( !errorPercent.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StatisticsType_choice_verdictStatistics otherValue) {
			if ( !this.none__.operatorEquals( otherValue.none__ ) ) { return false; }
			if ( !this.nonePercent.operatorEquals( otherValue.nonePercent ) ) { return false; }
			if ( !this.pass__.operatorEquals( otherValue.pass__ ) ) { return false; }
			if ( !this.passPercent.operatorEquals( otherValue.passPercent ) ) { return false; }
			if ( !this.inconc__.operatorEquals( otherValue.inconc__ ) ) { return false; }
			if ( !this.inconcPercent.operatorEquals( otherValue.inconcPercent ) ) { return false; }
			if ( !this.fail__.operatorEquals( otherValue.fail__ ) ) { return false; }
			if ( !this.failPercent.operatorEquals( otherValue.failPercent ) ) { return false; }
			if ( !this.error__.operatorEquals( otherValue.error__ ) ) { return false; }
			if ( !this.errorPercent.operatorEquals( otherValue.errorPercent ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics ) {
				return operatorEquals((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics", otherValue));
		}

		public TitanInteger getnone__() {
			return none__;
		}

		public TitanInteger constGetnone__() {
			return none__;
		}

		public TitanFloat getnonePercent() {
			return nonePercent;
		}

		public TitanFloat constGetnonePercent() {
			return nonePercent;
		}

		public TitanInteger getpass__() {
			return pass__;
		}

		public TitanInteger constGetpass__() {
			return pass__;
		}

		public TitanFloat getpassPercent() {
			return passPercent;
		}

		public TitanFloat constGetpassPercent() {
			return passPercent;
		}

		public TitanInteger getinconc__() {
			return inconc__;
		}

		public TitanInteger constGetinconc__() {
			return inconc__;
		}

		public TitanFloat getinconcPercent() {
			return inconcPercent;
		}

		public TitanFloat constGetinconcPercent() {
			return inconcPercent;
		}

		public TitanInteger getfail__() {
			return fail__;
		}

		public TitanInteger constGetfail__() {
			return fail__;
		}

		public TitanFloat getfailPercent() {
			return failPercent;
		}

		public TitanFloat constGetfailPercent() {
			return failPercent;
		}

		public TitanInteger geterror__() {
			return error__;
		}

		public TitanInteger constGeterror__() {
			return error__;
		}

		public TitanFloat geterrorPercent() {
			return errorPercent;
		}

		public TitanFloat constGeterrorPercent() {
			return errorPercent;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(10);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" none_ := ");
			none__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" nonePercent := ");
			nonePercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pass_ := ");
			pass__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" passPercent := ");
			passPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" inconc_ := ");
			inconc__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" inconcPercent := ");
			inconcPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" fail_ := ");
			fail__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" failPercent := ");
			failPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" error_ := ");
			error__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" errorPercent := ");
			errorPercent.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 10) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics has 10 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnone__().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnonePercent().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpass__().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpassPercent().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinconc__().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinconcPercent().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfail__().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfailPercent().set_param(param.get_elem(7));
				}
				if (param.get_size() > 8 && param.get_elem(8).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					geterror__().set_param(param.get_elem(8));
				}
				if (param.get_size() > 9 && param.get_elem(9).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					geterrorPercent().set_param(param.get_elem(9));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("none_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnone__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("nonePercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnonePercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pass_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpass__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("passPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpassPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("inconc_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinconc__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("inconcPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinconcPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fail_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfail__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("failPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfailPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("error_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							geterror__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("errorPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							geterrorPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StatisticsType.choice.verdictStatistics: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.StatisticsType.choice.verdictStatistics");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (none__.isBound()) {
				none__.set_implicit_omit();
			}
			if (nonePercent.isBound()) {
				nonePercent.set_implicit_omit();
			}
			if (pass__.isBound()) {
				pass__.set_implicit_omit();
			}
			if (passPercent.isBound()) {
				passPercent.set_implicit_omit();
			}
			if (inconc__.isBound()) {
				inconc__.set_implicit_omit();
			}
			if (inconcPercent.isBound()) {
				inconcPercent.set_implicit_omit();
			}
			if (fail__.isBound()) {
				fail__.set_implicit_omit();
			}
			if (failPercent.isBound()) {
				failPercent.set_implicit_omit();
			}
			if (error__.isBound()) {
				error__.set_implicit_omit();
			}
			if (errorPercent.isBound()) {
				errorPercent.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			none__.encode_text(text_buf);
			nonePercent.encode_text(text_buf);
			pass__.encode_text(text_buf);
			passPercent.encode_text(text_buf);
			inconc__.encode_text(text_buf);
			inconcPercent.encode_text(text_buf);
			fail__.encode_text(text_buf);
			failPercent.encode_text(text_buf);
			error__.encode_text(text_buf);
			errorPercent.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			none__.decode_text(text_buf);
			nonePercent.decode_text(text_buf);
			pass__.decode_text(text_buf);
			passPercent.decode_text(text_buf);
			inconc__.decode_text(text_buf);
			inconcPercent.decode_text(text_buf);
			fail__.decode_text(text_buf);
			failPercent.decode_text(text_buf);
			error__.decode_text(text_buf);
			errorPercent.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class StatisticsType_choice_verdictStatistics_template extends Base_Template {

		private TitanInteger_template none__; //Integer_Type
		private TitanFloat_template nonePercent; //Float_Type
		private TitanInteger_template pass__; //Integer_Type
		private TitanFloat_template passPercent; //Float_Type
		private TitanInteger_template inconc__; //Integer_Type
		private TitanFloat_template inconcPercent; //Float_Type
		private TitanInteger_template fail__; //Integer_Type
		private TitanFloat_template failPercent; //Float_Type
		private TitanInteger_template error__; //Integer_Type
		private TitanFloat_template errorPercent; //Float_Type
		//originally value_list/list_value
		private List<StatisticsType_choice_verdictStatistics_template> list_value;

		public TitanInteger_template getnone__() {
			setSpecific();
			return none__;
		}

		public TitanInteger_template constGetnone__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field none_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return none__;
		}

		public TitanFloat_template getnonePercent() {
			setSpecific();
			return nonePercent;
		}

		public TitanFloat_template constGetnonePercent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field nonePercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return nonePercent;
		}

		public TitanInteger_template getpass__() {
			setSpecific();
			return pass__;
		}

		public TitanInteger_template constGetpass__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field pass_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return pass__;
		}

		public TitanFloat_template getpassPercent() {
			setSpecific();
			return passPercent;
		}

		public TitanFloat_template constGetpassPercent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field passPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return passPercent;
		}

		public TitanInteger_template getinconc__() {
			setSpecific();
			return inconc__;
		}

		public TitanInteger_template constGetinconc__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field inconc_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return inconc__;
		}

		public TitanFloat_template getinconcPercent() {
			setSpecific();
			return inconcPercent;
		}

		public TitanFloat_template constGetinconcPercent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field inconcPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return inconcPercent;
		}

		public TitanInteger_template getfail__() {
			setSpecific();
			return fail__;
		}

		public TitanInteger_template constGetfail__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field fail_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return fail__;
		}

		public TitanFloat_template getfailPercent() {
			setSpecific();
			return failPercent;
		}

		public TitanFloat_template constGetfailPercent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field failPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return failPercent;
		}

		public TitanInteger_template geterror__() {
			setSpecific();
			return error__;
		}

		public TitanInteger_template constGeterror__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field error_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return error__;
		}

		public TitanFloat_template geterrorPercent() {
			setSpecific();
			return errorPercent;
		}

		public TitanFloat_template constGeterrorPercent() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field errorPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return errorPercent;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				none__ = new TitanInteger_template();
				nonePercent = new TitanFloat_template();
				pass__ = new TitanInteger_template();
				passPercent = new TitanFloat_template();
				inconc__ = new TitanInteger_template();
				inconcPercent = new TitanFloat_template();
				fail__ = new TitanInteger_template();
				failPercent = new TitanFloat_template();
				error__ = new TitanInteger_template();
				errorPercent = new TitanFloat_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					none__.assign(template_sel.ANY_VALUE);
					nonePercent.assign(template_sel.ANY_VALUE);
					pass__.assign(template_sel.ANY_VALUE);
					passPercent.assign(template_sel.ANY_VALUE);
					inconc__.assign(template_sel.ANY_VALUE);
					inconcPercent.assign(template_sel.ANY_VALUE);
					fail__.assign(template_sel.ANY_VALUE);
					failPercent.assign(template_sel.ANY_VALUE);
					error__.assign(template_sel.ANY_VALUE);
					errorPercent.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public StatisticsType_choice_verdictStatistics_template() {
			// do nothing
		}

		public StatisticsType_choice_verdictStatistics_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public StatisticsType_choice_verdictStatistics_template( final StatisticsType_choice_verdictStatistics otherValue ) {
			copyValue(otherValue);
		}

		public StatisticsType_choice_verdictStatistics_template( final StatisticsType_choice_verdictStatistics_template otherValue ) {
			copyTemplate( otherValue );
		}

		public StatisticsType_choice_verdictStatistics_template( final Optional<StatisticsType_choice_verdictStatistics> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics from an unbound optional field.");
			}
		}

		//originally operator=
		public StatisticsType_choice_verdictStatistics_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_choice_verdictStatistics_template assign( final StatisticsType_choice_verdictStatistics other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_choice_verdictStatistics_template assign( final StatisticsType_choice_verdictStatistics_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public StatisticsType_choice_verdictStatistics_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics) {
				return assign((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType_choice_verdictStatistics' can not be cast to {1}", otherValue));
		}

		@Override
		public StatisticsType_choice_verdictStatistics_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics_template) {
				return assign((StatisticsType_choice_verdictStatistics_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType_choice_verdictStatistics' can not be cast to {1}_template", otherValue));
		}

		public StatisticsType_choice_verdictStatistics_template assign( final Optional<StatisticsType_choice_verdictStatistics> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return this;
		}

		private void copyValue(final StatisticsType_choice_verdictStatistics other_value) {
			if (other_value.getnone__().isBound()) {
				getnone__().assign(other_value.getnone__());
			} else {
				getnone__().cleanUp();
			}
			if (other_value.getnonePercent().isBound()) {
				getnonePercent().assign(other_value.getnonePercent());
			} else {
				getnonePercent().cleanUp();
			}
			if (other_value.getpass__().isBound()) {
				getpass__().assign(other_value.getpass__());
			} else {
				getpass__().cleanUp();
			}
			if (other_value.getpassPercent().isBound()) {
				getpassPercent().assign(other_value.getpassPercent());
			} else {
				getpassPercent().cleanUp();
			}
			if (other_value.getinconc__().isBound()) {
				getinconc__().assign(other_value.getinconc__());
			} else {
				getinconc__().cleanUp();
			}
			if (other_value.getinconcPercent().isBound()) {
				getinconcPercent().assign(other_value.getinconcPercent());
			} else {
				getinconcPercent().cleanUp();
			}
			if (other_value.getfail__().isBound()) {
				getfail__().assign(other_value.getfail__());
			} else {
				getfail__().cleanUp();
			}
			if (other_value.getfailPercent().isBound()) {
				getfailPercent().assign(other_value.getfailPercent());
			} else {
				getfailPercent().cleanUp();
			}
			if (other_value.geterror__().isBound()) {
				geterror__().assign(other_value.geterror__());
			} else {
				geterror__().cleanUp();
			}
			if (other_value.geterrorPercent().isBound()) {
				geterrorPercent().assign(other_value.geterrorPercent());
			} else {
				geterrorPercent().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final StatisticsType_choice_verdictStatistics_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnone__().get_selection()) {
					getnone__().cleanUp();
				} else {
					getnone__().assign(other_value.getnone__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnonePercent().get_selection()) {
					getnonePercent().cleanUp();
				} else {
					getnonePercent().assign(other_value.getnonePercent());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getpass__().get_selection()) {
					getpass__().cleanUp();
				} else {
					getpass__().assign(other_value.getpass__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getpassPercent().get_selection()) {
					getpassPercent().cleanUp();
				} else {
					getpassPercent().assign(other_value.getpassPercent());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getinconc__().get_selection()) {
					getinconc__().cleanUp();
				} else {
					getinconc__().assign(other_value.getinconc__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getinconcPercent().get_selection()) {
					getinconcPercent().cleanUp();
				} else {
					getinconcPercent().assign(other_value.getinconcPercent());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfail__().get_selection()) {
					getfail__().cleanUp();
				} else {
					getfail__().assign(other_value.getfail__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfailPercent().get_selection()) {
					getfailPercent().cleanUp();
				} else {
					getfailPercent().assign(other_value.getfailPercent());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.geterror__().get_selection()) {
					geterror__().cleanUp();
				} else {
					geterror__().assign(other_value.geterror__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.geterrorPercent().get_selection()) {
					geterrorPercent().cleanUp();
				} else {
					geterrorPercent().assign(other_value.geterrorPercent());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final StatisticsType_choice_verdictStatistics_template temp = new StatisticsType_choice_verdictStatistics_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StatisticsType_choice_verdictStatistics valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			final StatisticsType_choice_verdictStatistics ret_val = new StatisticsType_choice_verdictStatistics();
			if (none__.isBound()) {
				ret_val.getnone__().assign(none__.valueOf());
			}
			if (nonePercent.isBound()) {
				ret_val.getnonePercent().assign(nonePercent.valueOf());
			}
			if (pass__.isBound()) {
				ret_val.getpass__().assign(pass__.valueOf());
			}
			if (passPercent.isBound()) {
				ret_val.getpassPercent().assign(passPercent.valueOf());
			}
			if (inconc__.isBound()) {
				ret_val.getinconc__().assign(inconc__.valueOf());
			}
			if (inconcPercent.isBound()) {
				ret_val.getinconcPercent().assign(inconcPercent.valueOf());
			}
			if (fail__.isBound()) {
				ret_val.getfail__().assign(fail__.valueOf());
			}
			if (failPercent.isBound()) {
				ret_val.getfailPercent().assign(failPercent.valueOf());
			}
			if (error__.isBound()) {
				ret_val.geterror__().assign(error__.valueOf());
			}
			if (errorPercent.isBound()) {
				ret_val.geterrorPercent().assign(errorPercent.valueOf());
			}
			return ret_val;
		}

		public StatisticsType_choice_verdictStatistics_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StatisticsType_choice_verdictStatistics_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (none__.isBound()) {
				return true;
			}
			if (nonePercent.isBound()) {
				return true;
			}
			if (pass__.isBound()) {
				return true;
			}
			if (passPercent.isBound()) {
				return true;
			}
			if (inconc__.isBound()) {
				return true;
			}
			if (inconcPercent.isBound()) {
				return true;
			}
			if (fail__.isBound()) {
				return true;
			}
			if (failPercent.isBound()) {
				return true;
			}
			if (error__.isBound()) {
				return true;
			}
			if (errorPercent.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!none__.isValue()) {
				return false;
			}
			if (!nonePercent.isValue()) {
				return false;
			}
			if (!pass__.isValue()) {
				return false;
			}
			if (!passPercent.isValue()) {
				return false;
			}
			if (!inconc__.isValue()) {
				return false;
			}
			if (!inconcPercent.isValue()) {
				return false;
			}
			if (!fail__.isValue()) {
				return false;
			}
			if (!failPercent.isValue()) {
				return false;
			}
			if (!error__.isValue()) {
				return false;
			}
			if (!errorPercent.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StatisticsType_choice_verdictStatistics other_value) {
			return match(other_value, false);
		}

		public boolean match(final StatisticsType_choice_verdictStatistics other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getnone__().isBound()) {
					return false;
				}
				if(!none__.match(other_value.getnone__(), legacy)) {
					return false;
				}
				if(!other_value.getnonePercent().isBound()) {
					return false;
				}
				if(!nonePercent.match(other_value.getnonePercent(), legacy)) {
					return false;
				}
				if(!other_value.getpass__().isBound()) {
					return false;
				}
				if(!pass__.match(other_value.getpass__(), legacy)) {
					return false;
				}
				if(!other_value.getpassPercent().isBound()) {
					return false;
				}
				if(!passPercent.match(other_value.getpassPercent(), legacy)) {
					return false;
				}
				if(!other_value.getinconc__().isBound()) {
					return false;
				}
				if(!inconc__.match(other_value.getinconc__(), legacy)) {
					return false;
				}
				if(!other_value.getinconcPercent().isBound()) {
					return false;
				}
				if(!inconcPercent.match(other_value.getinconcPercent(), legacy)) {
					return false;
				}
				if(!other_value.getfail__().isBound()) {
					return false;
				}
				if(!fail__.match(other_value.getfail__(), legacy)) {
					return false;
				}
				if(!other_value.getfailPercent().isBound()) {
					return false;
				}
				if(!failPercent.match(other_value.getfailPercent(), legacy)) {
					return false;
				}
				if(!other_value.geterror__().isBound()) {
					return false;
				}
				if(!error__.match(other_value.geterror__(), legacy)) {
					return false;
				}
				if(!other_value.geterrorPercent().isBound()) {
					return false;
				}
				if(!errorPercent.match(other_value.geterrorPercent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics) {
				return match((StatisticsType_choice_verdictStatistics)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType_choice_verdictStatistics.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(10);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" none_ := ");
				none__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" nonePercent := ");
				nonePercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pass_ := ");
				pass__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" passPercent := ");
				passPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" inconc_ := ");
				inconc__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" inconcPercent := ");
				inconcPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" fail_ := ");
				fail__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" failPercent := ");
				failPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" error_ := ");
				error__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" errorPercent := ");
				errorPercent.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StatisticsType_choice_verdictStatistics match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StatisticsType_choice_verdictStatistics) {
				log_match((StatisticsType_choice_verdictStatistics)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}

		public void log_match(final StatisticsType_choice_verdictStatistics match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !none__.match(match_value.constGetnone__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".none_");
							none__.log_match(match_value.constGetnone__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !nonePercent.match(match_value.constGetnonePercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".nonePercent");
							nonePercent.log_match(match_value.constGetnonePercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !pass__.match(match_value.constGetpass__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".pass_");
							pass__.log_match(match_value.constGetpass__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !passPercent.match(match_value.constGetpassPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".passPercent");
							passPercent.log_match(match_value.constGetpassPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !inconc__.match(match_value.constGetinconc__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".inconc_");
							inconc__.log_match(match_value.constGetinconc__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !inconcPercent.match(match_value.constGetinconcPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".inconcPercent");
							inconcPercent.log_match(match_value.constGetinconcPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !fail__.match(match_value.constGetfail__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".fail_");
							fail__.log_match(match_value.constGetfail__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !failPercent.match(match_value.constGetfailPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".failPercent");
							failPercent.log_match(match_value.constGetfailPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !error__.match(match_value.constGeterror__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".error_");
							error__.log_match(match_value.constGeterror__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !errorPercent.match(match_value.constGeterrorPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".errorPercent");
							errorPercent.log_match(match_value.constGeterrorPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ none_ := ");
				none__.log_match(match_value.constGetnone__(), legacy);
				TTCN_Logger.log_event_str("{ nonePercent := ");
				nonePercent.log_match(match_value.constGetnonePercent(), legacy);
				TTCN_Logger.log_event_str("{ pass_ := ");
				pass__.log_match(match_value.constGetpass__(), legacy);
				TTCN_Logger.log_event_str("{ passPercent := ");
				passPercent.log_match(match_value.constGetpassPercent(), legacy);
				TTCN_Logger.log_event_str("{ inconc_ := ");
				inconc__.log_match(match_value.constGetinconc__(), legacy);
				TTCN_Logger.log_event_str("{ inconcPercent := ");
				inconcPercent.log_match(match_value.constGetinconcPercent(), legacy);
				TTCN_Logger.log_event_str("{ fail_ := ");
				fail__.log_match(match_value.constGetfail__(), legacy);
				TTCN_Logger.log_event_str("{ failPercent := ");
				failPercent.log_match(match_value.constGetfailPercent(), legacy);
				TTCN_Logger.log_event_str("{ error_ := ");
				error__.log_match(match_value.constGeterror__(), legacy);
				TTCN_Logger.log_event_str("{ errorPercent := ");
				errorPercent.log_match(match_value.constGeterrorPercent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				none__.encode_text(text_buf);
				nonePercent.encode_text(text_buf);
				pass__.encode_text(text_buf);
				passPercent.encode_text(text_buf);
				inconc__.encode_text(text_buf);
				inconcPercent.encode_text(text_buf);
				fail__.encode_text(text_buf);
				failPercent.encode_text(text_buf);
				error__.encode_text(text_buf);
				errorPercent.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				none__ = new TitanInteger_template();
				none__.decode_text(text_buf);
				nonePercent = new TitanFloat_template();
				nonePercent.decode_text(text_buf);
				pass__ = new TitanInteger_template();
				pass__.decode_text(text_buf);
				passPercent = new TitanFloat_template();
				passPercent.decode_text(text_buf);
				inconc__ = new TitanInteger_template();
				inconc__.decode_text(text_buf);
				inconcPercent = new TitanFloat_template();
				inconcPercent.decode_text(text_buf);
				fail__ = new TitanInteger_template();
				fail__.decode_text(text_buf);
				failPercent = new TitanFloat_template();
				failPercent.decode_text(text_buf);
				error__ = new TitanInteger_template();
				error__.decode_text(text_buf);
				errorPercent = new TitanFloat_template();
				errorPercent.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(size);
				for (int i = 0; i < size; i++) {
					final StatisticsType_choice_verdictStatistics_template temp = new StatisticsType_choice_verdictStatistics_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 10) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics has 10 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnone__().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnonePercent().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpass__().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpassPercent().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinconc__().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinconcPercent().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfail__().set_param(param.get_elem(6));
				}
				if (param.get_size() > 7 && param.get_elem(7).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfailPercent().set_param(param.get_elem(7));
				}
				if (param.get_size() > 8 && param.get_elem(8).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					geterror__().set_param(param.get_elem(8));
				}
				if (param.get_size() > 9 && param.get_elem(9).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					geterrorPercent().set_param(param.get_elem(9));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("none_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnone__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("nonePercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnonePercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pass_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpass__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("passPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpassPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("inconc_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinconc__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("inconcPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinconcPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fail_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfail__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("failPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfailPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("error_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							geterror__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("errorPercent".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							geterrorPercent().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StatisticsType.choice.verdictStatistics: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.StatisticsType.choice.verdictStatistics");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.none__.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.nonePercent.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.pass__.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.passPercent.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.inconc__.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.inconcPercent.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.fail__.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.failPercent.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.error__.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				this.errorPercent.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.StatisticsType.choice.verdictStatistics" : name));
		}
	}
	public static void StatisticsType_choice_verdictStatistics_encoder(final StatisticsType_choice_verdictStatistics input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice.verdictStatistics' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_decoder( final TitanOctetString input_stream, final StatisticsType_choice_verdictStatistics output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice.verdictStatistics' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParPort_dstCompref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_dstCompref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_dstCompref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_dstCompref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__send_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__send_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__send_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__send_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingSuccessType_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingSuccessType_info_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingSuccessType_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingSuccessType_info_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__send_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__send_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__send_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__send_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_none___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_none___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_none___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_none___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class LogEventType extends Base_Type {
		private final LogEventType_choice choice; //TTCN3_Choice_Type

		public LogEventType() {
			this.choice = new LogEventType_choice();
		}

		public LogEventType(final LogEventType_choice choice ) {
			this.choice = new LogEventType_choice( choice );
		}

		public LogEventType( final LogEventType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.LogEventType.");
			}
			choice = new LogEventType_choice();
			assign( otherValue );
		}

		public LogEventType assign(final LogEventType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.LogEventType");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public LogEventType assign(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType ) {
				return assign((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LogEventType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final LogEventType otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType ) {
				return operatorEquals((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LogEventType", otherValue));
		}

		public LogEventType_choice getchoice() {
			return choice;
		}

		public LogEventType_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.LogEventType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.LogEventType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.LogEventType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class LogEventType_template extends Base_Template {

		private LogEventType_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<LogEventType_template> list_value;

		public LogEventType_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public LogEventType_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.LogEventType.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new LogEventType_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public LogEventType_template() {
			// do nothing
		}

		public LogEventType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public LogEventType_template( final LogEventType otherValue ) {
			copyValue(otherValue);
		}

		public LogEventType_template( final LogEventType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public LogEventType_template( final Optional<LogEventType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.LogEventType from an unbound optional field.");
			}
		}

		//originally operator=
		public LogEventType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public LogEventType_template assign( final LogEventType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public LogEventType_template assign( final LogEventType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public LogEventType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType) {
				return assign((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LogEventType' can not be cast to {1}", otherValue));
		}

		@Override
		public LogEventType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof LogEventType_template) {
				return assign((LogEventType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LogEventType' can not be cast to {1}_template", otherValue));
		}

		public LogEventType_template assign( final Optional<LogEventType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.LogEventType.");
			}
			return this;
		}

		private void copyValue(final LogEventType other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final LogEventType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<LogEventType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final LogEventType_template temp = new LogEventType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.LogEventType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public LogEventType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.LogEventType.");
			}
			final LogEventType ret_val = new LogEventType();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public LogEventType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.LogEventType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.LogEventType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.LogEventType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<LogEventType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new LogEventType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final LogEventType other_value) {
			return match(other_value, false);
		}

		public boolean match(final LogEventType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof LogEventType) {
				return match((LogEventType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type LogEventType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final LogEventType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LogEventType) {
				log_match((LogEventType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.");
		}

		public void log_match(final LogEventType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new LogEventType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<LogEventType_template>(size);
				for (int i = 0; i < size; i++) {
					final LogEventType_template temp = new LogEventType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.LogEventType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.LogEventType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.LogEventType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.LogEventType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.LogEventType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.LogEventType" : name));
		}
	}
	public static void LogEventType_encoder(final LogEventType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_decoder( final TitanOctetString input_stream, final LogEventType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__State extends Base_Type {
		private final Port__State_operation operation; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type

		public Port__State() {
			this.operation = new Port__State_operation();
			this.port__name = new TitanCharString();
		}

		public Port__State(final Port__State_operation operation, final TitanCharString port__name ) {
			this.operation = new Port__State_operation( operation );
			this.port__name = new TitanCharString( port__name );
		}

		public Port__State( final Port__State otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_State.");
			}
			operation = new Port__State_operation();
			port__name = new TitanCharString();
			assign( otherValue );
		}

		public Port__State assign(final Port__State otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_State");
			}

			if (otherValue != this) {
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__State assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__State ) {
				return assign((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_State", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			port__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__State otherValue) {
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__State ) {
				return operatorEquals((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_State", otherValue));
		}

		public Port__State_operation getoperation() {
			return operation;
		}

		public Port__State_operation constGetoperation() {
			return operation;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Port_State has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_State: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Port_State");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			port__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			port__name.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__State_template extends Base_Template {

		private Port__State_operation_template operation; //TTCN3_Enumerated_Type
		private TitanCharString_template port__name; //CharString_Type
		//originally value_list/list_value
		private List<Port__State_template> list_value;

		public Port__State_operation_template getoperation() {
			setSpecific();
			return operation;
		}

		public Port__State_operation_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Port_State.");
			}
			return operation;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_State.");
			}
			return port__name;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				operation = new Port__State_operation_template();
				port__name = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					operation.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Port__State_template() {
			// do nothing
		}

		public Port__State_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Port__State_template( final Port__State otherValue ) {
			copyValue(otherValue);
		}

		public Port__State_template( final Port__State_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Port__State_template( final Optional<Port__State> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_State from an unbound optional field.");
			}
		}

		//originally operator=
		public Port__State_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Port__State_template assign( final Port__State other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Port__State_template assign( final Port__State_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Port__State_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__State) {
				return assign((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__State_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__State_template) {
				return assign((Port__State_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State' can not be cast to {1}_template", otherValue));
		}

		public Port__State_template assign( final Optional<Port__State> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_State.");
			}
			return this;
		}

		private void copyValue(final Port__State other_value) {
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Port__State_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Port__State_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Port__State_template temp = new Port__State_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_State.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__State valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_State.");
			}
			final Port__State ret_val = new Port__State();
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			return ret_val;
		}

		public Port__State_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_State.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_State.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_State.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__State_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__State_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__State other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__State other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Port__State) {
				return match((Port__State)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__State.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__State match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__State) {
				log_match((Port__State)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.");
		}

		public void log_match(final Port__State match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				port__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new Port__State_operation_template();
				operation.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__State_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__State_template temp = new Port__State_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_State.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Port_State has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_State: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Port_State");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_State" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_State" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_State" : name));
		}
	}
	public static void Port__State_encoder(final Port__State input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__State_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__State_decoder( final TitanOctetString input_stream, final Port__State output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__State_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TestcaseType extends Base_Type {
		private final QualifiedName name; //Referenced_Type
		private final Verdict verdict; //Referenced_Type
		private final TitanCharString reason; //CharString_Type

		public TestcaseType() {
			this.name = new QualifiedName();
			this.verdict = new Verdict();
			this.reason = new TitanCharString();
		}

		public TestcaseType(final QualifiedName name, final Verdict verdict, final TitanCharString reason ) {
			this.name = new QualifiedName( name );
			this.verdict = new Verdict( verdict );
			this.reason = new TitanCharString( reason );
		}

		public TestcaseType( final TestcaseType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TestcaseType.");
			}
			name = new QualifiedName();
			verdict = new Verdict();
			reason = new TitanCharString();
			assign( otherValue );
		}

		public TestcaseType assign(final TestcaseType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TestcaseType");
			}

			if (otherValue != this) {
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
				if ( otherValue.getverdict().isBound() ) {
					this.verdict.assign( otherValue.getverdict() );
				} else {
					this.verdict.cleanUp();
				}
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TestcaseType assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType ) {
				return assign((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseType", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			verdict.cleanUp();
			reason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( verdict.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !verdict.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TestcaseType otherValue) {
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			if ( !this.verdict.operatorEquals( otherValue.verdict ) ) { return false; }
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType ) {
				return operatorEquals((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseType", otherValue));
		}

		public QualifiedName getname() {
			return name;
		}

		public QualifiedName constGetname() {
			return name;
		}

		public Verdict getverdict() {
			return verdict;
		}

		public Verdict constGetverdict() {
			return verdict;
		}

		public TitanCharString getreason() {
			return reason;
		}

		public TitanCharString constGetreason() {
			return reason;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdict := ");
			verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TestcaseType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TestcaseType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TestcaseType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (verdict.isBound()) {
				verdict.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			verdict.encode_text(text_buf);
			reason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			verdict.decode_text(text_buf);
			reason.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TestcaseType_template extends Base_Template {

		private QualifiedName_template name; //Referenced_Type
		private Verdict_template verdict; //Referenced_Type
		private TitanCharString_template reason; //CharString_Type
		//originally value_list/list_value
		private List<TestcaseType_template> list_value;

		public QualifiedName_template getname() {
			setSpecific();
			return name;
		}

		public QualifiedName_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.TestcaseType.");
			}
			return name;
		}

		public Verdict_template getverdict() {
			setSpecific();
			return verdict;
		}

		public Verdict_template constGetverdict() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field verdict of a non-specific template of type @TitanLoggerApi.TestcaseType.");
			}
			return verdict;
		}

		public TitanCharString_template getreason() {
			setSpecific();
			return reason;
		}

		public TitanCharString_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.TestcaseType.");
			}
			return reason;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				name = new QualifiedName_template();
				verdict = new Verdict_template();
				reason = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					name.assign(template_sel.ANY_VALUE);
					verdict.assign(template_sel.ANY_VALUE);
					reason.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TestcaseType_template() {
			// do nothing
		}

		public TestcaseType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TestcaseType_template( final TestcaseType otherValue ) {
			copyValue(otherValue);
		}

		public TestcaseType_template( final TestcaseType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TestcaseType_template( final Optional<TestcaseType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TestcaseType from an unbound optional field.");
			}
		}

		//originally operator=
		public TestcaseType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TestcaseType_template assign( final TestcaseType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TestcaseType_template assign( final TestcaseType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TestcaseType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType) {
				return assign((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseType' can not be cast to {1}", otherValue));
		}

		@Override
		public TestcaseType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TestcaseType_template) {
				return assign((TestcaseType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseType' can not be cast to {1}_template", otherValue));
		}

		public TestcaseType_template assign( final Optional<TestcaseType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TestcaseType.");
			}
			return this;
		}

		private void copyValue(final TestcaseType other_value) {
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			if (other_value.getverdict().isBound()) {
				getverdict().assign(other_value.getverdict());
			} else {
				getverdict().cleanUp();
			}
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TestcaseType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getverdict().get_selection()) {
					getverdict().cleanUp();
				} else {
					getverdict().assign(other_value.getverdict());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TestcaseType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TestcaseType_template temp = new TestcaseType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TestcaseType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TestcaseType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TestcaseType.");
			}
			final TestcaseType ret_val = new TestcaseType();
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			if (verdict.isBound()) {
				ret_val.getverdict().assign(verdict.valueOf());
			}
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			return ret_val;
		}

		public TestcaseType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TestcaseType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TestcaseType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TestcaseType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TestcaseType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TestcaseType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (verdict.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!verdict.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TestcaseType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TestcaseType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				if(!other_value.getverdict().isBound()) {
					return false;
				}
				if(!verdict.match(other_value.getverdict(), legacy)) {
					return false;
				}
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TestcaseType) {
				return match((TestcaseType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdict := ");
				verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TestcaseType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TestcaseType) {
				log_match((TestcaseType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseType.");
		}

		public void log_match(final TestcaseType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !verdict.match(match_value.constGetverdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".verdict");
							verdict.log_match(match_value.constGetverdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str("{ verdict := ");
				verdict.log_match(match_value.constGetverdict(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				verdict.encode_text(text_buf);
				reason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new QualifiedName_template();
				name.decode_text(text_buf);
				verdict = new Verdict_template();
				verdict.decode_text(text_buf);
				reason = new TitanCharString_template();
				reason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TestcaseType_template>(size);
				for (int i = 0; i < size; i++) {
					final TestcaseType_template temp = new TestcaseType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TestcaseType has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getverdict().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("verdict".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getverdict().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TestcaseType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TestcaseType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseType" : name, legacy);
				this.verdict.check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseType" : name, legacy);
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.TestcaseType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TestcaseType" : name));
		}
	}
	public static void TestcaseType_encoder(final TestcaseType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseType_decoder( final TitanOctetString input_stream, final TestcaseType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLogEvent_timestamp_encoder(final TimestampType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_timestamp_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_timestamp_decoder( final TitanOctetString input_stream, final TimestampType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_timestamp_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParallelEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_parallelPTC,  ALT_parallelPTC__exit,  ALT_parallelPort };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public ParallelEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public ParallelEvent_choice(final ParallelEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final ParallelEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_parallelPTC:
				field = new ParallelPTC((ParallelPTC)otherValue.field);
				break;
			case ALT_parallelPTC__exit:
				field = new PTC__exit((PTC__exit)otherValue.field);
				break;
			case ALT_parallelPort:
				field = new ParPort((ParPort)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.ParallelEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public ParallelEvent_choice assign( final ParallelEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public ParallelEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof ParallelEvent_choice) {
				return assign((ParallelEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_parallelPTC:
				return field.isValue();
			case ALT_parallelPTC__exit:
				return field.isValue();
			case ALT_parallelPort:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final ParallelEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.ParallelEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.ParallelEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_parallelPTC:
				return ((ParallelPTC)field).operatorEquals((ParallelPTC)otherValue.field);
			case ALT_parallelPTC__exit:
				return ((PTC__exit)field).operatorEquals((PTC__exit)otherValue.field);
			case ALT_parallelPort:
				return ((ParPort)field).operatorEquals((ParPort)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof ParallelEvent_choice) {
				return operatorEquals((ParallelEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final ParallelEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public ParallelPTC getparallelPTC() {
			if (union_selection != union_selection_type.ALT_parallelPTC) {
				cleanUp();
				field = new ParallelPTC();
				union_selection = union_selection_type.ALT_parallelPTC;
			}
			return (ParallelPTC)field;
		}

		public ParallelPTC constGetparallelPTC() {
			if (union_selection != union_selection_type.ALT_parallelPTC) {
				throw new TtcnError("Using non-selected field parallelPTC in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (ParallelPTC)field;
		}

		public PTC__exit getparallelPTC__exit() {
			if (union_selection != union_selection_type.ALT_parallelPTC__exit) {
				cleanUp();
				field = new PTC__exit();
				union_selection = union_selection_type.ALT_parallelPTC__exit;
			}
			return (PTC__exit)field;
		}

		public PTC__exit constGetparallelPTC__exit() {
			if (union_selection != union_selection_type.ALT_parallelPTC__exit) {
				throw new TtcnError("Using non-selected field parallelPTC_exit in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (PTC__exit)field;
		}

		public ParPort getparallelPort() {
			if (union_selection != union_selection_type.ALT_parallelPort) {
				cleanUp();
				field = new ParPort();
				union_selection = union_selection_type.ALT_parallelPort;
			}
			return (ParPort)field;
		}

		public ParPort constGetparallelPort() {
			if (union_selection != union_selection_type.ALT_parallelPort) {
				throw new TtcnError("Using non-selected field parallelPort in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (ParPort)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_parallelPTC:
				TTCN_Logger.log_event_str("{ parallelPTC := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_parallelPTC__exit:
				TTCN_Logger.log_event_str("{ parallelPTC_exit := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_parallelPort:
				TTCN_Logger.log_event_str("{ parallelPort := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("parallelPTC".equals(last_name)) {
				getparallelPTC().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("parallelPTC_exit".equals(last_name)) {
				getparallelPTC__exit().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("parallelPort".equals(last_name)) {
				getparallelPort().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.ParallelEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_parallelPTC:
			case ALT_parallelPTC__exit:
			case ALT_parallelPort:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_parallelPTC:
				text_buf.push_int(0);
				break;
			case ALT_parallelPTC__exit:
				text_buf.push_int(1);
				break;
			case ALT_parallelPort:
				text_buf.push_int(2);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getparallelPTC().decode_text(text_buf);
				break;
			case 1:
				getparallelPTC__exit().decode_text(text_buf);
				break;
			case 2:
				getparallelPort().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.ParallelEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParallelEvent_choice_template extends Base_Template {
		//if single value which value?
		private ParallelEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<ParallelEvent_choice_template> value_list;

		private void copy_value(final ParallelEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_parallelPTC:
				single_value = new ParallelPTC_template(other_value.constGetparallelPTC());
				break;
			case ALT_parallelPTC__exit:
				single_value = new PTC__exit_template(other_value.constGetparallelPTC__exit());
				break;
			case ALT_parallelPort:
				single_value = new ParPort_template(other_value.constGetparallelPort());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.ParallelEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final ParallelEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_parallelPTC:
					single_value = new ParallelPTC_template(other_value.constGetparallelPTC());
					break;
				case ALT_parallelPTC__exit:
					single_value = new PTC__exit_template(other_value.constGetparallelPTC__exit());
					break;
				case ALT_parallelPort:
					single_value = new ParPort_template(other_value.constGetparallelPort());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.ParallelEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ParallelEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final ParallelEvent_choice_template temp = new ParallelEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			set_selection(other_value);
		}

		public ParallelEvent_choice_template() {
			// do nothing
		}
		public ParallelEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public ParallelEvent_choice_template(final ParallelEvent_choice other_value) {
			copy_value(other_value);
		}
		public ParallelEvent_choice_template(final ParallelEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_parallelPTC:
					((ParallelPTC_template)single_value).cleanUp();
					break;
				case ALT_parallelPTC__exit:
					((PTC__exit_template)single_value).cleanUp();
					break;
				case ALT_parallelPort:
					((ParPort_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public ParallelEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ParallelEvent_choice_template assign( final ParallelEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public ParallelEvent_choice_template assign( final ParallelEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public ParallelEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof ParallelEvent_choice) {
				return assign((ParallelEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to ParallelEvent_choice.");
		}

		@Override
		public ParallelEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof ParallelEvent_choice_template) {
				return assign((ParallelEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to ParallelEvent_choice_template.");
		}

		// originally match
		public boolean match(final ParallelEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final ParallelEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final ParallelEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_parallelPTC:
					return ((ParallelPTC_template)single_value).match(other_value.getparallelPTC(), legacy);
				case ALT_parallelPTC__exit:
					return ((PTC__exit_template)single_value).match(other_value.getparallelPTC__exit(), legacy);
				case ALT_parallelPort:
					return ((ParPort_template)single_value).match(other_value.getparallelPort(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.ParallelEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ParallelEvent_choice) {
				return match((ParallelEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelEvent_choice.");
		}
		public boolean isChosen(final ParallelEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.ParallelEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_parallelPTC:
				return ((ParallelPTC_template)single_value).isValue();
			case ALT_parallelPTC__exit:
				return ((PTC__exit_template)single_value).isValue();
			case ALT_parallelPort:
				return ((ParPort_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
		}

		public ParallelEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			final ParallelEvent_choice ret_val = new ParallelEvent_choice();
			switch (single_value_union_selection) {
			case ALT_parallelPTC:
				ret_val.getparallelPTC().assign(((ParallelPTC_template)single_value).valueOf());
				break;
			case ALT_parallelPTC__exit:
				ret_val.getparallelPTC__exit().assign(((PTC__exit_template)single_value).valueOf());
				break;
			case ALT_parallelPort:
				ret_val.getparallelPort().assign(((ParPort_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<ParallelEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ParallelEvent_choice_template());
			}
		}

		public ParallelEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public ParallelPTC_template getparallelPTC() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPTC) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ParallelPTC_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ParallelPTC_template();
				}
				single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_parallelPTC;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ParallelPTC_template)single_value;
		}

		public ParallelPTC_template constGetparallelPTC() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parallelPTC in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPTC) {
				throw new TtcnError("Accessing non-selected field parallelPTC in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (ParallelPTC_template)single_value;
		}

		public PTC__exit_template getparallelPTC__exit() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPTC__exit) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new PTC__exit_template(template_sel.ANY_VALUE);
				} else {
					single_value = new PTC__exit_template();
				}
				single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_parallelPTC__exit;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (PTC__exit_template)single_value;
		}

		public PTC__exit_template constGetparallelPTC__exit() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parallelPTC_exit in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPTC__exit) {
				throw new TtcnError("Accessing non-selected field parallelPTC_exit in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (PTC__exit_template)single_value;
		}

		public ParPort_template getparallelPort() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPort) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new ParPort_template(template_sel.ANY_VALUE);
				} else {
					single_value = new ParPort_template();
				}
				single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_parallelPort;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (ParPort_template)single_value;
		}

		public ParPort_template constGetparallelPort() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parallelPort in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_parallelPort) {
				throw new TtcnError("Accessing non-selected field parallelPort in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
			}
			return (ParPort_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelEvent_choice) {
				log_match((ParallelEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
		}

		public void log_match(final ParallelEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_parallelPTC:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".parallelPTC");
						single_value.log_match(match_value.getparallelPTC(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ parallelPTC := ");
						single_value.log_match(match_value.getparallelPTC(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_parallelPTC__exit:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".parallelPTC_exit");
						single_value.log_match(match_value.getparallelPTC__exit(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ parallelPTC_exit := ");
						single_value.log_match(match_value.getparallelPTC__exit(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_parallelPort:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".parallelPort");
						single_value.log_match(match_value.getparallelPort(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ parallelPort := ");
						single_value.log_match(match_value.getparallelPort(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.ParallelEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new ParallelPTC_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new PTC__exit_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new ParPort_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ParallelEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final ParallelEvent_choice_template temp2 = new ParallelEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.ParallelEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.ParallelEvent.choice");
				}
				if("parallelPTC".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("parallelPTC_exit".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("parallelPort".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.ParallelEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("parallelPTC".equals(last_name)) {
					getparallelPTC().set_param(mp_last);
					break;
				}
				if("parallelPTC_exit".equals(last_name)) {
					getparallelPTC__exit().set_param(mp_last);
					break;
				}
				if("parallelPort".equals(last_name)) {
					getparallelPort().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.ParallelEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.ParallelEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_parallelPTC:
					((ParallelPTC_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelEvent.choice" : name, legacy);
					return;
				case ALT_parallelPTC__exit:
					((PTC__exit_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelEvent.choice" : name, legacy);
					return;
				case ALT_parallelPort:
					((ParPort_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParallelEvent.choice" : name));
		}
	}
	public static void ParallelEvent_choice_encoder(final ParallelEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelEvent_choice_decoder( final TitanOctetString input_stream, final ParallelEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingTimeout_timer__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingTimeout_timer__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingTimeout_timer__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingTimeout_timer__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class anytype extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE };
		private union_selection_type union_selection;
		public anytype() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public anytype(final anytype otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final anytype otherValue) {
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public anytype assign( final anytype otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public anytype assign( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
		}

		//originally clean_up
		public void cleanUp() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.anytype.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final anytype otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.anytype." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.anytype." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return operatorEquals((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final anytype otherValue ) {
			return !operatorEquals(otherValue);
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.anytype.", last_name));
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.anytype.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class anytype_template extends Base_Template {
		//if single value which value?
		private anytype.union_selection_type single_value_union_selection;
		// value_list part
		private ArrayList<anytype_template> value_list;

		private void copy_value(final anytype other_value) {
			single_value_union_selection = other_value.get_selection();
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final anytype_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<anytype_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final anytype_template temp = new anytype_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.anytype.");
			}
			set_selection(other_value);
		}

		public anytype_template() {
			// do nothing
		}
		public anytype_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public anytype_template(final anytype other_value) {
			copy_value(other_value);
		}
		public anytype_template(final anytype_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public anytype_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public anytype_template assign( final anytype other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public anytype_template assign( final anytype_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public anytype_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof anytype) {
				return assign((anytype)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype.");
		}

		@Override
		public anytype_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof anytype_template) {
				return assign((anytype_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to anytype_template.");
		}

		// originally match
		public boolean match(final anytype other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final anytype other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final anytype.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.anytype.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof anytype) {
				return match((anytype)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type anytype.");
		}
		public boolean isChosen(final anytype.union_selection_type checked_selection) {
			if(checked_selection == anytype.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.anytype.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == anytype.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.anytype.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.anytype containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.anytype.");
			}
		}

		public anytype valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.anytype.");
			}
			switch (single_value_union_selection) {
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.anytype.");
			}
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.anytype.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<anytype_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new anytype_template());
			}
		}

		public anytype_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.anytype.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.anytype.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.anytype.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof anytype) {
				log_match((anytype)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
		}

		public void log_match(final anytype match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.anytype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<anytype_template>(size);
				for (int i = 0; i < size; i++) {
					final anytype_template temp2 = new anytype_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.anytype.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.anytype");
				}
				else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.anytype");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.anytype.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.anytype");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.anytype.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.anytype" : name));
		}
	}
	public static void anytype_encoder(final anytype input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.anytype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(anytype_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger anytype_decoder( final TitanOctetString input_stream, final anytype output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.anytype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(anytype_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class PortEvent extends Base_Type {
		private final PortEvent_choice choice; //TTCN3_Choice_Type

		public PortEvent() {
			this.choice = new PortEvent_choice();
		}

		public PortEvent(final PortEvent_choice choice ) {
			this.choice = new PortEvent_choice( choice );
		}

		public PortEvent( final PortEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.PortEvent.");
			}
			choice = new PortEvent_choice();
			assign( otherValue );
		}

		public PortEvent assign(final PortEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.PortEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public PortEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent ) {
				return assign((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PortEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final PortEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent ) {
				return operatorEquals((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PortEvent", otherValue));
		}

		public PortEvent_choice getchoice() {
			return choice;
		}

		public PortEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.PortEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.PortEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.PortEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class PortEvent_template extends Base_Template {

		private PortEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<PortEvent_template> list_value;

		public PortEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public PortEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.PortEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new PortEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public PortEvent_template() {
			// do nothing
		}

		public PortEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public PortEvent_template( final PortEvent otherValue ) {
			copyValue(otherValue);
		}

		public PortEvent_template( final PortEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public PortEvent_template( final Optional<PortEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.PortEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public PortEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public PortEvent_template assign( final PortEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public PortEvent_template assign( final PortEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public PortEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent) {
				return assign((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public PortEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof PortEvent_template) {
				return assign((PortEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortEvent' can not be cast to {1}_template", otherValue));
		}

		public PortEvent_template assign( final Optional<PortEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.PortEvent.");
			}
			return this;
		}

		private void copyValue(final PortEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final PortEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PortEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PortEvent_template temp = new PortEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.PortEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public PortEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.PortEvent.");
			}
			final PortEvent ret_val = new PortEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public PortEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.PortEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.PortEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.PortEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<PortEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new PortEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final PortEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final PortEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PortEvent) {
				return match((PortEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PortEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final PortEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PortEvent) {
				log_match((PortEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.");
		}

		public void log_match(final PortEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new PortEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<PortEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final PortEvent_template temp = new PortEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.PortEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.PortEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.PortEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.PortEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.PortEvent" : name));
		}
	}
	public static void PortEvent_encoder(final PortEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_decoder( final TitanOctetString input_stream, final PortEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class PortEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_portQueue,  ALT_portState,  ALT_procPortSend,  ALT_procPortRecv,  ALT_msgPortSend,  ALT_msgPortRecv,  ALT_dualMapped,  ALT_dualDiscard,  ALT_setState,  ALT_portMisc };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public PortEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public PortEvent_choice(final PortEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final PortEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_portQueue:
				field = new Port__Queue((Port__Queue)otherValue.field);
				break;
			case ALT_portState:
				field = new Port__State((Port__State)otherValue.field);
				break;
			case ALT_procPortSend:
				field = new Proc__port__out((Proc__port__out)otherValue.field);
				break;
			case ALT_procPortRecv:
				field = new Proc__port__in((Proc__port__in)otherValue.field);
				break;
			case ALT_msgPortSend:
				field = new Msg__port__send((Msg__port__send)otherValue.field);
				break;
			case ALT_msgPortRecv:
				field = new Msg__port__recv((Msg__port__recv)otherValue.field);
				break;
			case ALT_dualMapped:
				field = new Dualface__mapped((Dualface__mapped)otherValue.field);
				break;
			case ALT_dualDiscard:
				field = new Dualface__discard((Dualface__discard)otherValue.field);
				break;
			case ALT_setState:
				field = new Setstate((Setstate)otherValue.field);
				break;
			case ALT_portMisc:
				field = new Port__Misc((Port__Misc)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.PortEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public PortEvent_choice assign( final PortEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public PortEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof PortEvent_choice) {
				return assign((PortEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_portQueue:
				return field.isValue();
			case ALT_portState:
				return field.isValue();
			case ALT_procPortSend:
				return field.isValue();
			case ALT_procPortRecv:
				return field.isValue();
			case ALT_msgPortSend:
				return field.isValue();
			case ALT_msgPortRecv:
				return field.isValue();
			case ALT_dualMapped:
				return field.isValue();
			case ALT_dualDiscard:
				return field.isValue();
			case ALT_setState:
				return field.isValue();
			case ALT_portMisc:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final PortEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.PortEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.PortEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_portQueue:
				return ((Port__Queue)field).operatorEquals((Port__Queue)otherValue.field);
			case ALT_portState:
				return ((Port__State)field).operatorEquals((Port__State)otherValue.field);
			case ALT_procPortSend:
				return ((Proc__port__out)field).operatorEquals((Proc__port__out)otherValue.field);
			case ALT_procPortRecv:
				return ((Proc__port__in)field).operatorEquals((Proc__port__in)otherValue.field);
			case ALT_msgPortSend:
				return ((Msg__port__send)field).operatorEquals((Msg__port__send)otherValue.field);
			case ALT_msgPortRecv:
				return ((Msg__port__recv)field).operatorEquals((Msg__port__recv)otherValue.field);
			case ALT_dualMapped:
				return ((Dualface__mapped)field).operatorEquals((Dualface__mapped)otherValue.field);
			case ALT_dualDiscard:
				return ((Dualface__discard)field).operatorEquals((Dualface__discard)otherValue.field);
			case ALT_setState:
				return ((Setstate)field).operatorEquals((Setstate)otherValue.field);
			case ALT_portMisc:
				return ((Port__Misc)field).operatorEquals((Port__Misc)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof PortEvent_choice) {
				return operatorEquals((PortEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final PortEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public Port__Queue getportQueue() {
			if (union_selection != union_selection_type.ALT_portQueue) {
				cleanUp();
				field = new Port__Queue();
				union_selection = union_selection_type.ALT_portQueue;
			}
			return (Port__Queue)field;
		}

		public Port__Queue constGetportQueue() {
			if (union_selection != union_selection_type.ALT_portQueue) {
				throw new TtcnError("Using non-selected field portQueue in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__Queue)field;
		}

		public Port__State getportState() {
			if (union_selection != union_selection_type.ALT_portState) {
				cleanUp();
				field = new Port__State();
				union_selection = union_selection_type.ALT_portState;
			}
			return (Port__State)field;
		}

		public Port__State constGetportState() {
			if (union_selection != union_selection_type.ALT_portState) {
				throw new TtcnError("Using non-selected field portState in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__State)field;
		}

		public Proc__port__out getprocPortSend() {
			if (union_selection != union_selection_type.ALT_procPortSend) {
				cleanUp();
				field = new Proc__port__out();
				union_selection = union_selection_type.ALT_procPortSend;
			}
			return (Proc__port__out)field;
		}

		public Proc__port__out constGetprocPortSend() {
			if (union_selection != union_selection_type.ALT_procPortSend) {
				throw new TtcnError("Using non-selected field procPortSend in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Proc__port__out)field;
		}

		public Proc__port__in getprocPortRecv() {
			if (union_selection != union_selection_type.ALT_procPortRecv) {
				cleanUp();
				field = new Proc__port__in();
				union_selection = union_selection_type.ALT_procPortRecv;
			}
			return (Proc__port__in)field;
		}

		public Proc__port__in constGetprocPortRecv() {
			if (union_selection != union_selection_type.ALT_procPortRecv) {
				throw new TtcnError("Using non-selected field procPortRecv in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Proc__port__in)field;
		}

		public Msg__port__send getmsgPortSend() {
			if (union_selection != union_selection_type.ALT_msgPortSend) {
				cleanUp();
				field = new Msg__port__send();
				union_selection = union_selection_type.ALT_msgPortSend;
			}
			return (Msg__port__send)field;
		}

		public Msg__port__send constGetmsgPortSend() {
			if (union_selection != union_selection_type.ALT_msgPortSend) {
				throw new TtcnError("Using non-selected field msgPortSend in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Msg__port__send)field;
		}

		public Msg__port__recv getmsgPortRecv() {
			if (union_selection != union_selection_type.ALT_msgPortRecv) {
				cleanUp();
				field = new Msg__port__recv();
				union_selection = union_selection_type.ALT_msgPortRecv;
			}
			return (Msg__port__recv)field;
		}

		public Msg__port__recv constGetmsgPortRecv() {
			if (union_selection != union_selection_type.ALT_msgPortRecv) {
				throw new TtcnError("Using non-selected field msgPortRecv in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Msg__port__recv)field;
		}

		public Dualface__mapped getdualMapped() {
			if (union_selection != union_selection_type.ALT_dualMapped) {
				cleanUp();
				field = new Dualface__mapped();
				union_selection = union_selection_type.ALT_dualMapped;
			}
			return (Dualface__mapped)field;
		}

		public Dualface__mapped constGetdualMapped() {
			if (union_selection != union_selection_type.ALT_dualMapped) {
				throw new TtcnError("Using non-selected field dualMapped in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Dualface__mapped)field;
		}

		public Dualface__discard getdualDiscard() {
			if (union_selection != union_selection_type.ALT_dualDiscard) {
				cleanUp();
				field = new Dualface__discard();
				union_selection = union_selection_type.ALT_dualDiscard;
			}
			return (Dualface__discard)field;
		}

		public Dualface__discard constGetdualDiscard() {
			if (union_selection != union_selection_type.ALT_dualDiscard) {
				throw new TtcnError("Using non-selected field dualDiscard in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Dualface__discard)field;
		}

		public Setstate getsetState() {
			if (union_selection != union_selection_type.ALT_setState) {
				cleanUp();
				field = new Setstate();
				union_selection = union_selection_type.ALT_setState;
			}
			return (Setstate)field;
		}

		public Setstate constGetsetState() {
			if (union_selection != union_selection_type.ALT_setState) {
				throw new TtcnError("Using non-selected field setState in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Setstate)field;
		}

		public Port__Misc getportMisc() {
			if (union_selection != union_selection_type.ALT_portMisc) {
				cleanUp();
				field = new Port__Misc();
				union_selection = union_selection_type.ALT_portMisc;
			}
			return (Port__Misc)field;
		}

		public Port__Misc constGetportMisc() {
			if (union_selection != union_selection_type.ALT_portMisc) {
				throw new TtcnError("Using non-selected field portMisc in a value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__Misc)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_portQueue:
				TTCN_Logger.log_event_str("{ portQueue := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_portState:
				TTCN_Logger.log_event_str("{ portState := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_procPortSend:
				TTCN_Logger.log_event_str("{ procPortSend := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_procPortRecv:
				TTCN_Logger.log_event_str("{ procPortRecv := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_msgPortSend:
				TTCN_Logger.log_event_str("{ msgPortSend := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_msgPortRecv:
				TTCN_Logger.log_event_str("{ msgPortRecv := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_dualMapped:
				TTCN_Logger.log_event_str("{ dualMapped := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_dualDiscard:
				TTCN_Logger.log_event_str("{ dualDiscard := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_setState:
				TTCN_Logger.log_event_str("{ setState := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_portMisc:
				TTCN_Logger.log_event_str("{ portMisc := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("portQueue".equals(last_name)) {
				getportQueue().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("portState".equals(last_name)) {
				getportState().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("procPortSend".equals(last_name)) {
				getprocPortSend().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("procPortRecv".equals(last_name)) {
				getprocPortRecv().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("msgPortSend".equals(last_name)) {
				getmsgPortSend().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("msgPortRecv".equals(last_name)) {
				getmsgPortRecv().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("dualMapped".equals(last_name)) {
				getdualMapped().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("dualDiscard".equals(last_name)) {
				getdualDiscard().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("setState".equals(last_name)) {
				getsetState().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("portMisc".equals(last_name)) {
				getportMisc().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.PortEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_portQueue:
			case ALT_portState:
			case ALT_procPortSend:
			case ALT_procPortRecv:
			case ALT_msgPortSend:
			case ALT_msgPortRecv:
			case ALT_dualMapped:
			case ALT_dualDiscard:
			case ALT_setState:
			case ALT_portMisc:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_portQueue:
				text_buf.push_int(0);
				break;
			case ALT_portState:
				text_buf.push_int(1);
				break;
			case ALT_procPortSend:
				text_buf.push_int(2);
				break;
			case ALT_procPortRecv:
				text_buf.push_int(3);
				break;
			case ALT_msgPortSend:
				text_buf.push_int(4);
				break;
			case ALT_msgPortRecv:
				text_buf.push_int(5);
				break;
			case ALT_dualMapped:
				text_buf.push_int(6);
				break;
			case ALT_dualDiscard:
				text_buf.push_int(7);
				break;
			case ALT_setState:
				text_buf.push_int(8);
				break;
			case ALT_portMisc:
				text_buf.push_int(9);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.PortEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getportQueue().decode_text(text_buf);
				break;
			case 1:
				getportState().decode_text(text_buf);
				break;
			case 2:
				getprocPortSend().decode_text(text_buf);
				break;
			case 3:
				getprocPortRecv().decode_text(text_buf);
				break;
			case 4:
				getmsgPortSend().decode_text(text_buf);
				break;
			case 5:
				getmsgPortRecv().decode_text(text_buf);
				break;
			case 6:
				getdualMapped().decode_text(text_buf);
				break;
			case 7:
				getdualDiscard().decode_text(text_buf);
				break;
			case 8:
				getsetState().decode_text(text_buf);
				break;
			case 9:
				getportMisc().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.PortEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class PortEvent_choice_template extends Base_Template {
		//if single value which value?
		private PortEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<PortEvent_choice_template> value_list;

		private void copy_value(final PortEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_portQueue:
				single_value = new Port__Queue_template(other_value.constGetportQueue());
				break;
			case ALT_portState:
				single_value = new Port__State_template(other_value.constGetportState());
				break;
			case ALT_procPortSend:
				single_value = new Proc__port__out_template(other_value.constGetprocPortSend());
				break;
			case ALT_procPortRecv:
				single_value = new Proc__port__in_template(other_value.constGetprocPortRecv());
				break;
			case ALT_msgPortSend:
				single_value = new Msg__port__send_template(other_value.constGetmsgPortSend());
				break;
			case ALT_msgPortRecv:
				single_value = new Msg__port__recv_template(other_value.constGetmsgPortRecv());
				break;
			case ALT_dualMapped:
				single_value = new Dualface__mapped_template(other_value.constGetdualMapped());
				break;
			case ALT_dualDiscard:
				single_value = new Dualface__discard_template(other_value.constGetdualDiscard());
				break;
			case ALT_setState:
				single_value = new Setstate_template(other_value.constGetsetState());
				break;
			case ALT_portMisc:
				single_value = new Port__Misc_template(other_value.constGetportMisc());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.PortEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final PortEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_portQueue:
					single_value = new Port__Queue_template(other_value.constGetportQueue());
					break;
				case ALT_portState:
					single_value = new Port__State_template(other_value.constGetportState());
					break;
				case ALT_procPortSend:
					single_value = new Proc__port__out_template(other_value.constGetprocPortSend());
					break;
				case ALT_procPortRecv:
					single_value = new Proc__port__in_template(other_value.constGetprocPortRecv());
					break;
				case ALT_msgPortSend:
					single_value = new Msg__port__send_template(other_value.constGetmsgPortSend());
					break;
				case ALT_msgPortRecv:
					single_value = new Msg__port__recv_template(other_value.constGetmsgPortRecv());
					break;
				case ALT_dualMapped:
					single_value = new Dualface__mapped_template(other_value.constGetdualMapped());
					break;
				case ALT_dualDiscard:
					single_value = new Dualface__discard_template(other_value.constGetdualDiscard());
					break;
				case ALT_setState:
					single_value = new Setstate_template(other_value.constGetsetState());
					break;
				case ALT_portMisc:
					single_value = new Port__Misc_template(other_value.constGetportMisc());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.PortEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<PortEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final PortEvent_choice_template temp = new PortEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			set_selection(other_value);
		}

		public PortEvent_choice_template() {
			// do nothing
		}
		public PortEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public PortEvent_choice_template(final PortEvent_choice other_value) {
			copy_value(other_value);
		}
		public PortEvent_choice_template(final PortEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_portQueue:
					((Port__Queue_template)single_value).cleanUp();
					break;
				case ALT_portState:
					((Port__State_template)single_value).cleanUp();
					break;
				case ALT_procPortSend:
					((Proc__port__out_template)single_value).cleanUp();
					break;
				case ALT_procPortRecv:
					((Proc__port__in_template)single_value).cleanUp();
					break;
				case ALT_msgPortSend:
					((Msg__port__send_template)single_value).cleanUp();
					break;
				case ALT_msgPortRecv:
					((Msg__port__recv_template)single_value).cleanUp();
					break;
				case ALT_dualMapped:
					((Dualface__mapped_template)single_value).cleanUp();
					break;
				case ALT_dualDiscard:
					((Dualface__discard_template)single_value).cleanUp();
					break;
				case ALT_setState:
					((Setstate_template)single_value).cleanUp();
					break;
				case ALT_portMisc:
					((Port__Misc_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public PortEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public PortEvent_choice_template assign( final PortEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public PortEvent_choice_template assign( final PortEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public PortEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof PortEvent_choice) {
				return assign((PortEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to PortEvent_choice.");
		}

		@Override
		public PortEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof PortEvent_choice_template) {
				return assign((PortEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to PortEvent_choice_template.");
		}

		// originally match
		public boolean match(final PortEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final PortEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final PortEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_portQueue:
					return ((Port__Queue_template)single_value).match(other_value.getportQueue(), legacy);
				case ALT_portState:
					return ((Port__State_template)single_value).match(other_value.getportState(), legacy);
				case ALT_procPortSend:
					return ((Proc__port__out_template)single_value).match(other_value.getprocPortSend(), legacy);
				case ALT_procPortRecv:
					return ((Proc__port__in_template)single_value).match(other_value.getprocPortRecv(), legacy);
				case ALT_msgPortSend:
					return ((Msg__port__send_template)single_value).match(other_value.getmsgPortSend(), legacy);
				case ALT_msgPortRecv:
					return ((Msg__port__recv_template)single_value).match(other_value.getmsgPortRecv(), legacy);
				case ALT_dualMapped:
					return ((Dualface__mapped_template)single_value).match(other_value.getdualMapped(), legacy);
				case ALT_dualDiscard:
					return ((Dualface__discard_template)single_value).match(other_value.getdualDiscard(), legacy);
				case ALT_setState:
					return ((Setstate_template)single_value).match(other_value.getsetState(), legacy);
				case ALT_portMisc:
					return ((Port__Misc_template)single_value).match(other_value.getportMisc(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.PortEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PortEvent_choice) {
				return match((PortEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PortEvent_choice.");
		}
		public boolean isChosen(final PortEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.PortEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.PortEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_portQueue:
				return ((Port__Queue_template)single_value).isValue();
			case ALT_portState:
				return ((Port__State_template)single_value).isValue();
			case ALT_procPortSend:
				return ((Proc__port__out_template)single_value).isValue();
			case ALT_procPortRecv:
				return ((Proc__port__in_template)single_value).isValue();
			case ALT_msgPortSend:
				return ((Msg__port__send_template)single_value).isValue();
			case ALT_msgPortRecv:
				return ((Msg__port__recv_template)single_value).isValue();
			case ALT_dualMapped:
				return ((Dualface__mapped_template)single_value).isValue();
			case ALT_dualDiscard:
				return ((Dualface__discard_template)single_value).isValue();
			case ALT_setState:
				return ((Setstate_template)single_value).isValue();
			case ALT_portMisc:
				return ((Port__Misc_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
		}

		public PortEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			final PortEvent_choice ret_val = new PortEvent_choice();
			switch (single_value_union_selection) {
			case ALT_portQueue:
				ret_val.getportQueue().assign(((Port__Queue_template)single_value).valueOf());
				break;
			case ALT_portState:
				ret_val.getportState().assign(((Port__State_template)single_value).valueOf());
				break;
			case ALT_procPortSend:
				ret_val.getprocPortSend().assign(((Proc__port__out_template)single_value).valueOf());
				break;
			case ALT_procPortRecv:
				ret_val.getprocPortRecv().assign(((Proc__port__in_template)single_value).valueOf());
				break;
			case ALT_msgPortSend:
				ret_val.getmsgPortSend().assign(((Msg__port__send_template)single_value).valueOf());
				break;
			case ALT_msgPortRecv:
				ret_val.getmsgPortRecv().assign(((Msg__port__recv_template)single_value).valueOf());
				break;
			case ALT_dualMapped:
				ret_val.getdualMapped().assign(((Dualface__mapped_template)single_value).valueOf());
				break;
			case ALT_dualDiscard:
				ret_val.getdualDiscard().assign(((Dualface__discard_template)single_value).valueOf());
				break;
			case ALT_setState:
				ret_val.getsetState().assign(((Setstate_template)single_value).valueOf());
				break;
			case ALT_portMisc:
				ret_val.getportMisc().assign(((Port__Misc_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<PortEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new PortEvent_choice_template());
			}
		}

		public PortEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public Port__Queue_template getportQueue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portQueue) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Port__Queue_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Port__Queue_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_portQueue;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Port__Queue_template)single_value;
		}

		public Port__Queue_template constGetportQueue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field portQueue in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portQueue) {
				throw new TtcnError("Accessing non-selected field portQueue in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__Queue_template)single_value;
		}

		public Port__State_template getportState() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portState) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Port__State_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Port__State_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_portState;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Port__State_template)single_value;
		}

		public Port__State_template constGetportState() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field portState in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portState) {
				throw new TtcnError("Accessing non-selected field portState in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__State_template)single_value;
		}

		public Proc__port__out_template getprocPortSend() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_procPortSend) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Proc__port__out_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Proc__port__out_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_procPortSend;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Proc__port__out_template)single_value;
		}

		public Proc__port__out_template constGetprocPortSend() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field procPortSend in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_procPortSend) {
				throw new TtcnError("Accessing non-selected field procPortSend in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Proc__port__out_template)single_value;
		}

		public Proc__port__in_template getprocPortRecv() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_procPortRecv) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Proc__port__in_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Proc__port__in_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_procPortRecv;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Proc__port__in_template)single_value;
		}

		public Proc__port__in_template constGetprocPortRecv() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field procPortRecv in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_procPortRecv) {
				throw new TtcnError("Accessing non-selected field procPortRecv in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Proc__port__in_template)single_value;
		}

		public Msg__port__send_template getmsgPortSend() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_msgPortSend) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Msg__port__send_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Msg__port__send_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_msgPortSend;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Msg__port__send_template)single_value;
		}

		public Msg__port__send_template constGetmsgPortSend() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgPortSend in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_msgPortSend) {
				throw new TtcnError("Accessing non-selected field msgPortSend in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Msg__port__send_template)single_value;
		}

		public Msg__port__recv_template getmsgPortRecv() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_msgPortRecv) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Msg__port__recv_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Msg__port__recv_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_msgPortRecv;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Msg__port__recv_template)single_value;
		}

		public Msg__port__recv_template constGetmsgPortRecv() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgPortRecv in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_msgPortRecv) {
				throw new TtcnError("Accessing non-selected field msgPortRecv in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Msg__port__recv_template)single_value;
		}

		public Dualface__mapped_template getdualMapped() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_dualMapped) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Dualface__mapped_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Dualface__mapped_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_dualMapped;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Dualface__mapped_template)single_value;
		}

		public Dualface__mapped_template constGetdualMapped() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dualMapped in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_dualMapped) {
				throw new TtcnError("Accessing non-selected field dualMapped in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Dualface__mapped_template)single_value;
		}

		public Dualface__discard_template getdualDiscard() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_dualDiscard) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Dualface__discard_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Dualface__discard_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_dualDiscard;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Dualface__discard_template)single_value;
		}

		public Dualface__discard_template constGetdualDiscard() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dualDiscard in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_dualDiscard) {
				throw new TtcnError("Accessing non-selected field dualDiscard in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Dualface__discard_template)single_value;
		}

		public Setstate_template getsetState() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_setState) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Setstate_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Setstate_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_setState;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Setstate_template)single_value;
		}

		public Setstate_template constGetsetState() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field setState in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_setState) {
				throw new TtcnError("Accessing non-selected field setState in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Setstate_template)single_value;
		}

		public Port__Misc_template getportMisc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portMisc) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new Port__Misc_template(template_sel.ANY_VALUE);
				} else {
					single_value = new Port__Misc_template();
				}
				single_value_union_selection = PortEvent_choice.union_selection_type.ALT_portMisc;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (Port__Misc_template)single_value;
		}

		public Port__Misc_template constGetportMisc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field portMisc in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_portMisc) {
				throw new TtcnError("Accessing non-selected field portMisc in a template of union type @TitanLoggerApi.PortEvent.choice.");
			}
			return (Port__Misc_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PortEvent_choice) {
				log_match((PortEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
		}

		public void log_match(final PortEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_portQueue:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".portQueue");
						single_value.log_match(match_value.getportQueue(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ portQueue := ");
						single_value.log_match(match_value.getportQueue(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_portState:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".portState");
						single_value.log_match(match_value.getportState(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ portState := ");
						single_value.log_match(match_value.getportState(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_procPortSend:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".procPortSend");
						single_value.log_match(match_value.getprocPortSend(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ procPortSend := ");
						single_value.log_match(match_value.getprocPortSend(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_procPortRecv:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".procPortRecv");
						single_value.log_match(match_value.getprocPortRecv(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ procPortRecv := ");
						single_value.log_match(match_value.getprocPortRecv(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_msgPortSend:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".msgPortSend");
						single_value.log_match(match_value.getmsgPortSend(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ msgPortSend := ");
						single_value.log_match(match_value.getmsgPortSend(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_msgPortRecv:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".msgPortRecv");
						single_value.log_match(match_value.getmsgPortRecv(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ msgPortRecv := ");
						single_value.log_match(match_value.getmsgPortRecv(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_dualMapped:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".dualMapped");
						single_value.log_match(match_value.getdualMapped(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ dualMapped := ");
						single_value.log_match(match_value.getdualMapped(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_dualDiscard:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".dualDiscard");
						single_value.log_match(match_value.getdualDiscard(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ dualDiscard := ");
						single_value.log_match(match_value.getdualDiscard(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_setState:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".setState");
						single_value.log_match(match_value.getsetState(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ setState := ");
						single_value.log_match(match_value.getsetState(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_portMisc:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".portMisc");
						single_value.log_match(match_value.getportMisc(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ portMisc := ");
						single_value.log_match(match_value.getportMisc(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.PortEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new Port__Queue_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new Port__State_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new Proc__port__out_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new Proc__port__in_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new Msg__port__send_template();
					single_value.decode_text(text_buf);
					break;
				case 5:
					single_value = new Msg__port__recv_template();
					single_value.decode_text(text_buf);
					break;
				case 6:
					single_value = new Dualface__mapped_template();
					single_value.decode_text(text_buf);
					break;
				case 7:
					single_value = new Dualface__discard_template();
					single_value.decode_text(text_buf);
					break;
				case 8:
					single_value = new Setstate_template();
					single_value.decode_text(text_buf);
					break;
				case 9:
					single_value = new Port__Misc_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<PortEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final PortEvent_choice_template temp2 = new PortEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.PortEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.PortEvent.choice");
				}
				if("portQueue".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("portState".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("procPortSend".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("procPortRecv".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("msgPortSend".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("msgPortRecv".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("dualMapped".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("dualDiscard".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("setState".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("portMisc".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.PortEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("portQueue".equals(last_name)) {
					getportQueue().set_param(mp_last);
					break;
				}
				if("portState".equals(last_name)) {
					getportState().set_param(mp_last);
					break;
				}
				if("procPortSend".equals(last_name)) {
					getprocPortSend().set_param(mp_last);
					break;
				}
				if("procPortRecv".equals(last_name)) {
					getprocPortRecv().set_param(mp_last);
					break;
				}
				if("msgPortSend".equals(last_name)) {
					getmsgPortSend().set_param(mp_last);
					break;
				}
				if("msgPortRecv".equals(last_name)) {
					getmsgPortRecv().set_param(mp_last);
					break;
				}
				if("dualMapped".equals(last_name)) {
					getdualMapped().set_param(mp_last);
					break;
				}
				if("dualDiscard".equals(last_name)) {
					getdualDiscard().set_param(mp_last);
					break;
				}
				if("setState".equals(last_name)) {
					getsetState().set_param(mp_last);
					break;
				}
				if("portMisc".equals(last_name)) {
					getportMisc().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.PortEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.PortEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_portQueue:
					((Port__Queue_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_portState:
					((Port__State_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_procPortSend:
					((Proc__port__out_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_procPortRecv:
					((Proc__port__in_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_msgPortSend:
					((Msg__port__send_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_msgPortRecv:
					((Msg__port__recv_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_dualMapped:
					((Dualface__mapped_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_dualDiscard:
					((Dualface__discard_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_setState:
					((Setstate_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				case ALT_portMisc:
					((Port__Misc_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.PortEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.PortEvent.choice" : name));
		}
	}
	public static void PortEvent_choice_encoder(final PortEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_decoder( final TitanOctetString input_stream, final PortEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_warningLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_warningLog_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_warningLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_warningLog_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Msg__port__send extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString parameter; //CharString_Type

		public Msg__port__send() {
			this.port__name = new TitanCharString();
			this.compref = new TitanInteger();
			this.parameter = new TitanCharString();
		}

		public Msg__port__send(final TitanCharString port__name, final TitanInteger compref, final TitanCharString parameter ) {
			this.port__name = new TitanCharString( port__name );
			this.compref = new TitanInteger( compref );
			this.parameter = new TitanCharString( parameter );
		}

		public Msg__port__send( final Msg__port__send otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Msg_port_send.");
			}
			port__name = new TitanCharString();
			compref = new TitanInteger();
			parameter = new TitanCharString();
			assign( otherValue );
		}

		public Msg__port__send assign(final Msg__port__send otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Msg_port_send");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getparameter().isBound() ) {
					this.parameter.assign( otherValue.getparameter() );
				} else {
					this.parameter.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Msg__port__send assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send ) {
				return assign((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_send", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			compref.cleanUp();
			parameter.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Msg__port__send otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.parameter.operatorEquals( otherValue.parameter ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send ) {
				return operatorEquals((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_send", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanCharString getparameter() {
			return parameter;
		}

		public TitanCharString constGetparameter() {
			return parameter;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Msg_port_send has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Msg_port_send: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Msg_port_send");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			parameter.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			parameter.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Msg__port__send_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanCharString_template parameter; //CharString_Type
		//originally value_list/list_value
		private List<Msg__port__send_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
			}
			return port__name;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
			}
			return compref;
		}

		public TitanCharString_template getparameter() {
			setSpecific();
			return parameter;
		}

		public TitanCharString_template constGetparameter() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
			}
			return parameter;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				compref = new TitanInteger_template();
				parameter = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					parameter.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Msg__port__send_template() {
			// do nothing
		}

		public Msg__port__send_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Msg__port__send_template( final Msg__port__send otherValue ) {
			copyValue(otherValue);
		}

		public Msg__port__send_template( final Msg__port__send_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Msg__port__send_template( final Optional<Msg__port__send> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Msg_port_send from an unbound optional field.");
			}
		}

		//originally operator=
		public Msg__port__send_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Msg__port__send_template assign( final Msg__port__send other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Msg__port__send_template assign( final Msg__port__send_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Msg__port__send_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send) {
				return assign((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__send' can not be cast to {1}", otherValue));
		}

		@Override
		public Msg__port__send_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Msg__port__send_template) {
				return assign((Msg__port__send_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__send' can not be cast to {1}_template", otherValue));
		}

		public Msg__port__send_template assign( final Optional<Msg__port__send> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Msg_port_send.");
			}
			return this;
		}

		private void copyValue(final Msg__port__send other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getparameter().isBound()) {
				getparameter().assign(other_value.getparameter());
			} else {
				getparameter().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Msg__port__send_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparameter().get_selection()) {
					getparameter().cleanUp();
				} else {
					getparameter().assign(other_value.getparameter());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Msg__port__send_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Msg__port__send_template temp = new Msg__port__send_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Msg_port_send.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Msg__port__send valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Msg_port_send.");
			}
			final Msg__port__send ret_val = new Msg__port__send();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (parameter.isBound()) {
				ret_val.getparameter().assign(parameter.valueOf());
			}
			return ret_val;
		}

		public Msg__port__send_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Msg_port_send.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Msg_port_send.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Msg_port_send.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Msg__port__send_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Msg__port__send_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Msg__port__send other_value) {
			return match(other_value, false);
		}

		public boolean match(final Msg__port__send other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getparameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getparameter(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Msg__port__send) {
				return match((Msg__port__send)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Msg__port__send.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Msg__port__send match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Msg__port__send) {
				log_match((Msg__port__send)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_send.");
		}

		public void log_match(final Msg__port__send match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetparameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetparameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetparameter(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				parameter.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Msg__port__send_template>(size);
				for (int i = 0; i < size; i++) {
					final Msg__port__send_template temp = new Msg__port__send_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Msg_port_send has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Msg_port_send: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Msg_port_send");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_send" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_send" : name, legacy);
				this.parameter.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_send" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Msg_port_send" : name));
		}
	}
	public static void Msg__port__send_encoder(final Msg__port__send input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__send_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__send_decoder( final TitanOctetString input_stream, final Msg__port__send output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__send_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StartFunction_parameter__list_0_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StartFunction_parameter__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StartFunction_parameter__list_0_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StartFunction_parameter__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ComponentIDType_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ComponentIDType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ComponentIDType_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ComponentIDType_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingEvent_choice_matchingSuccess_encoder(final MatchingSuccessType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_matchingSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_matchingSuccess_decoder( final TitanOctetString input_stream, final MatchingSuccessType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_matchingSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__recv_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_fail___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_fail___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_fail___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_fail___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_executorRuntime_encoder(final ExecutorRuntime input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_executorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_executorRuntime_decoder( final TitanOctetString input_stream, final ExecutorRuntime output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_executorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_defaultEvent_encoder(final DefaultEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_defaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_defaultEvent_decoder( final TitanOctetString input_stream, final DefaultEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_defaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_errorLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_errorLog_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_errorLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_errorLog_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_errorPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_errorPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_errorPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_errorPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_local__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_local__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_local__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_local__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_src__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_src__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_src__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_src__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FunctionEvent extends Base_Type {
		private final FunctionEvent_choice choice; //TTCN3_Choice_Type

		public FunctionEvent() {
			this.choice = new FunctionEvent_choice();
		}

		public FunctionEvent(final FunctionEvent_choice choice ) {
			this.choice = new FunctionEvent_choice( choice );
		}

		public FunctionEvent( final FunctionEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FunctionEvent.");
			}
			choice = new FunctionEvent_choice();
			assign( otherValue );
		}

		public FunctionEvent assign(final FunctionEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FunctionEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FunctionEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent ) {
				return assign((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FunctionEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent ) {
				return operatorEquals((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent", otherValue));
		}

		public FunctionEvent_choice getchoice() {
			return choice;
		}

		public FunctionEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.FunctionEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FunctionEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.FunctionEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FunctionEvent_template extends Base_Template {

		private FunctionEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<FunctionEvent_template> list_value;

		public FunctionEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public FunctionEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.FunctionEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new FunctionEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public FunctionEvent_template() {
			// do nothing
		}

		public FunctionEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public FunctionEvent_template( final FunctionEvent otherValue ) {
			copyValue(otherValue);
		}

		public FunctionEvent_template( final FunctionEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public FunctionEvent_template( final Optional<FunctionEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.FunctionEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public FunctionEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_template assign( final FunctionEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_template assign( final FunctionEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public FunctionEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent) {
				return assign((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public FunctionEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FunctionEvent_template) {
				return assign((FunctionEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent' can not be cast to {1}_template", otherValue));
		}

		public FunctionEvent_template assign( final Optional<FunctionEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FunctionEvent.");
			}
			return this;
		}

		private void copyValue(final FunctionEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final FunctionEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<FunctionEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final FunctionEvent_template temp = new FunctionEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FunctionEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FunctionEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FunctionEvent.");
			}
			final FunctionEvent ret_val = new FunctionEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public FunctionEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FunctionEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FunctionEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FunctionEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FunctionEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FunctionEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FunctionEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final FunctionEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FunctionEvent) {
				return match((FunctionEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FunctionEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FunctionEvent) {
				log_match((FunctionEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.");
		}

		public void log_match(final FunctionEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new FunctionEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FunctionEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final FunctionEvent_template temp = new FunctionEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.FunctionEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FunctionEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.FunctionEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FunctionEvent" : name));
		}
	}
	public static void FunctionEvent_encoder(final FunctionEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_decoder( final TitanOctetString input_stream, final FunctionEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_stopTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_stopTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_stopTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_stopTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__send_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__send_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__send_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__send_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutionSummaryType_overallStatistics_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutionSummaryType_overallStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutionSummaryType_overallStatistics_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutionSummaryType_overallStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ErrorEvent_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ErrorEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ErrorEvent_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ErrorEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorRuntime_fd__setsize_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_fd__setsize_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_fd__setsize_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_fd__setsize_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_executorComponent_encoder(final ExecutorComponent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_executorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_executorComponent_decoder( final TitanOctetString input_stream, final ExecutorComponent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_executorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_function__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_function__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_testcaseOp_encoder(final TestcaseEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_testcaseOp_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_testcaseOp_decoder( final TitanOctetString input_stream, final TestcaseEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_testcaseOp_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingFailureType extends Base_Type {
		private final PortType port__type; //Referenced_Type
		private final TitanCharString port__name; //CharString_Type
		private final MatchingFailureType_choice choice; //TTCN3_Choice_Type
		private final MatchingFailureType_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString info; //CharString_Type

		public MatchingFailureType() {
			this.port__type = new PortType();
			this.port__name = new TitanCharString();
			this.choice = new MatchingFailureType_choice();
			this.reason = new MatchingFailureType_reason();
			this.info = new TitanCharString();
		}

		public MatchingFailureType(final PortType port__type, final TitanCharString port__name, final MatchingFailureType_choice choice, final MatchingFailureType_reason reason, final TitanCharString info ) {
			this.port__type = new PortType( port__type );
			this.port__name = new TitanCharString( port__name );
			this.choice = new MatchingFailureType_choice( choice );
			this.reason = new MatchingFailureType_reason( reason );
			this.info = new TitanCharString( info );
		}

		public MatchingFailureType( final MatchingFailureType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingFailureType.");
			}
			port__type = new PortType();
			port__name = new TitanCharString();
			choice = new MatchingFailureType_choice();
			reason = new MatchingFailureType_reason();
			info = new TitanCharString();
			assign( otherValue );
		}

		public MatchingFailureType assign(final MatchingFailureType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingFailureType");
			}

			if (otherValue != this) {
				if ( otherValue.getport__type().isBound() ) {
					this.port__type.assign( otherValue.getport__type() );
				} else {
					this.port__type.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getinfo().isBound() ) {
					this.info.assign( otherValue.getinfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingFailureType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType ) {
				return assign((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingFailureType", otherValue));
		}

		public void cleanUp() {
			port__type.cleanUp();
			port__name.cleanUp();
			choice.cleanUp();
			reason.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( choice.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !choice.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingFailureType otherValue) {
			if ( !this.port__type.operatorEquals( otherValue.port__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.info.operatorEquals( otherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType ) {
				return operatorEquals((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingFailureType", otherValue));
		}

		public PortType getport__type() {
			return port__type;
		}

		public PortType constGetport__type() {
			return port__type;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public MatchingFailureType_choice getchoice() {
			return choice;
		}

		public MatchingFailureType_choice constGetchoice() {
			return choice;
		}

		public MatchingFailureType_reason getreason() {
			return reason;
		}

		public MatchingFailureType_reason constGetreason() {
			return reason;
		}

		public TitanCharString getinfo() {
			return info;
		}

		public TitanCharString constGetinfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(5);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_type := ");
			port__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingFailureType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__type().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingFailureType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingFailureType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__type.isBound()) {
				port__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			choice.encode_text(text_buf);
			reason.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			choice.decode_text(text_buf);
			reason.decode_text(text_buf);
			info.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingFailureType_template extends Base_Template {

		private PortType_template port__type; //Referenced_Type
		private TitanCharString_template port__name; //CharString_Type
		private MatchingFailureType_choice_template choice; //TTCN3_Choice_Type
		private MatchingFailureType_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template info; //CharString_Type
		//originally value_list/list_value
		private List<MatchingFailureType_template> list_value;

		public PortType_template getport__type() {
			setSpecific();
			return port__type;
		}

		public PortType_template constGetport__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_type of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return port__type;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return port__name;
		}

		public MatchingFailureType_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public MatchingFailureType_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return choice;
		}

		public MatchingFailureType_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public MatchingFailureType_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return reason;
		}

		public TitanCharString_template getinfo() {
			setSpecific();
			return info;
		}

		public TitanCharString_template constGetinfo() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return info;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__type = new PortType_template();
				port__name = new TitanCharString_template();
				choice = new MatchingFailureType_choice_template();
				reason = new MatchingFailureType_reason_template();
				info = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__type.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
					choice.assign(template_sel.ANY_VALUE);
					reason.assign(template_sel.ANY_VALUE);
					info.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public MatchingFailureType_template() {
			// do nothing
		}

		public MatchingFailureType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingFailureType_template( final MatchingFailureType otherValue ) {
			copyValue(otherValue);
		}

		public MatchingFailureType_template( final MatchingFailureType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingFailureType_template( final Optional<MatchingFailureType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingFailureType from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingFailureType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingFailureType_template assign( final MatchingFailureType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingFailureType_template assign( final MatchingFailureType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingFailureType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType) {
				return assign((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingFailureType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingFailureType_template) {
				return assign((MatchingFailureType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType' can not be cast to {1}_template", otherValue));
		}

		public MatchingFailureType_template assign( final Optional<MatchingFailureType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return this;
		}

		private void copyValue(final MatchingFailureType other_value) {
			if (other_value.getport__type().isBound()) {
				getport__type().assign(other_value.getport__type());
			} else {
				getport__type().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getinfo().isBound()) {
				getinfo().assign(other_value.getinfo());
			} else {
				getinfo().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingFailureType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__type().get_selection()) {
					getport__type().cleanUp();
				} else {
					getport__type().assign(other_value.getport__type());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getinfo().get_selection()) {
					getinfo().cleanUp();
				} else {
					getinfo().assign(other_value.getinfo());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingFailureType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingFailureType_template temp = new MatchingFailureType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingFailureType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingFailureType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			final MatchingFailureType ret_val = new MatchingFailureType();
			if (port__type.isBound()) {
				ret_val.getport__type().assign(port__type.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (info.isBound()) {
				ret_val.getinfo().assign(info.valueOf());
			}
			return ret_val;
		}

		public MatchingFailureType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingFailureType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingFailureType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingFailureType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingFailureType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingFailureType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingFailureType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__type().isBound()) {
					return false;
				}
				if(!port__type.match(other_value.getport__type(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getinfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getinfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingFailureType) {
				return match((MatchingFailureType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingFailureType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(5);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_type := ");
				port__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingFailureType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingFailureType) {
				log_match((MatchingFailureType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.");
		}

		public void log_match(final MatchingFailureType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__type.match(match_value.constGetport__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_type");
							port__type.log_match(match_value.constGetport__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetinfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetinfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_type := ");
				port__type.log_match(match_value.constGetport__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetinfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				choice.encode_text(text_buf);
				reason.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type = new PortType_template();
				port__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				choice = new MatchingFailureType_choice_template();
				choice.decode_text(text_buf);
				reason = new MatchingFailureType_reason_template();
				reason.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingFailureType_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingFailureType_template temp = new MatchingFailureType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingFailureType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__type().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getinfo().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("info".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getinfo().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingFailureType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingFailureType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType" : name, legacy);
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType" : name, legacy);
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType" : name, legacy);
				this.info.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingFailureType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingFailureType" : name));
		}
	}
	public static void MatchingFailureType_encoder(final MatchingFailureType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_decoder( final TitanOctetString input_stream, final MatchingFailureType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingProblemType_check___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_check___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_check___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_check___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LocationInfo_ent__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LocationInfo_ent__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LocationInfo_ent__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LocationInfo_ent__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingEvent_choice_matchingDone_encoder(final MatchingDoneType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_matchingDone_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_matchingDone_decoder( final TitanOctetString input_stream, final MatchingDoneType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_matchingDone_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__recv_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_timeoutAnyTimer_encoder(final TimerAnyTimeoutType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_timeoutAnyTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_timeoutAnyTimer_decoder( final TitanOctetString input_stream, final TimerAnyTimeoutType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_timeoutAnyTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingFailureType_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_info_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_info_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultEvent_choice_defaultopDeactivate_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEvent_choice_defaultopDeactivate_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEvent_choice_defaultopDeactivate_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEvent_choice_defaultopDeactivate_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_new__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_new__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_new__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_new__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_dst__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_dst__port_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_dst__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_dst__port_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_ptc__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_ptc__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_ptc__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_ptc__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Queue_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TestcaseEvent_choice_testcaseStarted_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseEvent_choice_testcaseStarted_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseEvent_choice_testcaseStarted_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseEvent_choice_testcaseStarted_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictInfo_ptc__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictInfo_ptc__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictInfo_ptc__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictInfo_ptc__compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParPort extends Base_Type {
		private final ParPort_operation operation; //TTCN3_Enumerated_Type
		private final TitanInteger srcCompref; //Integer_Type
		private final TitanInteger dstCompref; //Integer_Type
		private final TitanCharString srcPort; //CharString_Type
		private final TitanCharString dstPort; //CharString_Type

		public ParPort() {
			this.operation = new ParPort_operation();
			this.srcCompref = new TitanInteger();
			this.dstCompref = new TitanInteger();
			this.srcPort = new TitanCharString();
			this.dstPort = new TitanCharString();
		}

		public ParPort(final ParPort_operation operation, final TitanInteger srcCompref, final TitanInteger dstCompref, final TitanCharString srcPort, final TitanCharString dstPort ) {
			this.operation = new ParPort_operation( operation );
			this.srcCompref = new TitanInteger( srcCompref );
			this.dstCompref = new TitanInteger( dstCompref );
			this.srcPort = new TitanCharString( srcPort );
			this.dstPort = new TitanCharString( dstPort );
		}

		public ParPort( final ParPort otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParPort.");
			}
			operation = new ParPort_operation();
			srcCompref = new TitanInteger();
			dstCompref = new TitanInteger();
			srcPort = new TitanCharString();
			dstPort = new TitanCharString();
			assign( otherValue );
		}

		public ParPort assign(final ParPort otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParPort");
			}

			if (otherValue != this) {
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getsrcCompref().isBound() ) {
					this.srcCompref.assign( otherValue.getsrcCompref() );
				} else {
					this.srcCompref.cleanUp();
				}
				if ( otherValue.getdstCompref().isBound() ) {
					this.dstCompref.assign( otherValue.getdstCompref() );
				} else {
					this.dstCompref.cleanUp();
				}
				if ( otherValue.getsrcPort().isBound() ) {
					this.srcPort.assign( otherValue.getsrcPort() );
				} else {
					this.srcPort.cleanUp();
				}
				if ( otherValue.getdstPort().isBound() ) {
					this.dstPort.assign( otherValue.getdstPort() );
				} else {
					this.dstPort.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParPort assign(final Base_Type otherValue) {
			if (otherValue instanceof ParPort ) {
				return assign((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParPort", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			srcCompref.cleanUp();
			dstCompref.cleanUp();
			srcPort.cleanUp();
			dstPort.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( srcCompref.isBound() ) { return true; }
			if ( dstCompref.isBound() ) { return true; }
			if ( srcPort.isBound() ) { return true; }
			if ( dstPort.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !srcCompref.isValue() ) { return false; }
			if ( !dstCompref.isValue() ) { return false; }
			if ( !srcPort.isValue() ) { return false; }
			if ( !dstPort.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParPort otherValue) {
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.srcCompref.operatorEquals( otherValue.srcCompref ) ) { return false; }
			if ( !this.dstCompref.operatorEquals( otherValue.dstCompref ) ) { return false; }
			if ( !this.srcPort.operatorEquals( otherValue.srcPort ) ) { return false; }
			if ( !this.dstPort.operatorEquals( otherValue.dstPort ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParPort ) {
				return operatorEquals((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParPort", otherValue));
		}

		public ParPort_operation getoperation() {
			return operation;
		}

		public ParPort_operation constGetoperation() {
			return operation;
		}

		public TitanInteger getsrcCompref() {
			return srcCompref;
		}

		public TitanInteger constGetsrcCompref() {
			return srcCompref;
		}

		public TitanInteger getdstCompref() {
			return dstCompref;
		}

		public TitanInteger constGetdstCompref() {
			return dstCompref;
		}

		public TitanCharString getsrcPort() {
			return srcPort;
		}

		public TitanCharString constGetsrcPort() {
			return srcPort;
		}

		public TitanCharString getdstPort() {
			return dstPort;
		}

		public TitanCharString constGetdstPort() {
			return dstPort;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(5);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" srcCompref := ");
			srcCompref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dstCompref := ");
			dstCompref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" srcPort := ");
			srcPort.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dstPort := ");
			dstPort.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ParPort has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrcCompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdstCompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrcPort().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdstPort().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("srcCompref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrcCompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dstCompref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdstCompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("srcPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrcPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dstPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdstPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParPort: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ParPort");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (srcCompref.isBound()) {
				srcCompref.set_implicit_omit();
			}
			if (dstCompref.isBound()) {
				dstCompref.set_implicit_omit();
			}
			if (srcPort.isBound()) {
				srcPort.set_implicit_omit();
			}
			if (dstPort.isBound()) {
				dstPort.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			srcCompref.encode_text(text_buf);
			dstCompref.encode_text(text_buf);
			srcPort.encode_text(text_buf);
			dstPort.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			srcCompref.decode_text(text_buf);
			dstCompref.decode_text(text_buf);
			srcPort.decode_text(text_buf);
			dstPort.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParPort_template extends Base_Template {

		private ParPort_operation_template operation; //TTCN3_Enumerated_Type
		private TitanInteger_template srcCompref; //Integer_Type
		private TitanInteger_template dstCompref; //Integer_Type
		private TitanCharString_template srcPort; //CharString_Type
		private TitanCharString_template dstPort; //CharString_Type
		//originally value_list/list_value
		private List<ParPort_template> list_value;

		public ParPort_operation_template getoperation() {
			setSpecific();
			return operation;
		}

		public ParPort_operation_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			return operation;
		}

		public TitanInteger_template getsrcCompref() {
			setSpecific();
			return srcCompref;
		}

		public TitanInteger_template constGetsrcCompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field srcCompref of a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			return srcCompref;
		}

		public TitanInteger_template getdstCompref() {
			setSpecific();
			return dstCompref;
		}

		public TitanInteger_template constGetdstCompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dstCompref of a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			return dstCompref;
		}

		public TitanCharString_template getsrcPort() {
			setSpecific();
			return srcPort;
		}

		public TitanCharString_template constGetsrcPort() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field srcPort of a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			return srcPort;
		}

		public TitanCharString_template getdstPort() {
			setSpecific();
			return dstPort;
		}

		public TitanCharString_template constGetdstPort() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dstPort of a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			return dstPort;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				operation = new ParPort_operation_template();
				srcCompref = new TitanInteger_template();
				dstCompref = new TitanInteger_template();
				srcPort = new TitanCharString_template();
				dstPort = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					operation.assign(template_sel.ANY_VALUE);
					srcCompref.assign(template_sel.ANY_VALUE);
					dstCompref.assign(template_sel.ANY_VALUE);
					srcPort.assign(template_sel.ANY_VALUE);
					dstPort.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ParPort_template() {
			// do nothing
		}

		public ParPort_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ParPort_template( final ParPort otherValue ) {
			copyValue(otherValue);
		}

		public ParPort_template( final ParPort_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ParPort_template( final Optional<ParPort> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ParPort from an unbound optional field.");
			}
		}

		//originally operator=
		public ParPort_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ParPort_template assign( final ParPort other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ParPort_template assign( final ParPort_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ParPort_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParPort) {
				return assign((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort' can not be cast to {1}", otherValue));
		}

		@Override
		public ParPort_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParPort_template) {
				return assign((ParPort_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort' can not be cast to {1}_template", otherValue));
		}

		public ParPort_template assign( final Optional<ParPort> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParPort.");
			}
			return this;
		}

		private void copyValue(final ParPort other_value) {
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getsrcCompref().isBound()) {
				getsrcCompref().assign(other_value.getsrcCompref());
			} else {
				getsrcCompref().cleanUp();
			}
			if (other_value.getdstCompref().isBound()) {
				getdstCompref().assign(other_value.getdstCompref());
			} else {
				getdstCompref().cleanUp();
			}
			if (other_value.getsrcPort().isBound()) {
				getsrcPort().assign(other_value.getsrcPort());
			} else {
				getsrcPort().cleanUp();
			}
			if (other_value.getdstPort().isBound()) {
				getdstPort().assign(other_value.getdstPort());
			} else {
				getdstPort().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ParPort_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsrcCompref().get_selection()) {
					getsrcCompref().cleanUp();
				} else {
					getsrcCompref().assign(other_value.getsrcCompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getdstCompref().get_selection()) {
					getdstCompref().cleanUp();
				} else {
					getdstCompref().assign(other_value.getdstCompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsrcPort().get_selection()) {
					getsrcPort().cleanUp();
				} else {
					getsrcPort().assign(other_value.getsrcPort());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getdstPort().get_selection()) {
					getdstPort().cleanUp();
				} else {
					getdstPort().assign(other_value.getdstPort());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ParPort_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ParPort_template temp = new ParPort_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParPort.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParPort valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			final ParPort ret_val = new ParPort();
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (srcCompref.isBound()) {
				ret_val.getsrcCompref().assign(srcCompref.valueOf());
			}
			if (dstCompref.isBound()) {
				ret_val.getdstCompref().assign(dstCompref.valueOf());
			}
			if (srcPort.isBound()) {
				ret_val.getsrcPort().assign(srcPort.valueOf());
			}
			if (dstPort.isBound()) {
				ret_val.getdstPort().assign(dstPort.valueOf());
			}
			return ret_val;
		}

		public ParPort_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParPort.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParPort.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParPort.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParPort_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParPort_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (srcCompref.isBound()) {
				return true;
			}
			if (dstCompref.isBound()) {
				return true;
			}
			if (srcPort.isBound()) {
				return true;
			}
			if (dstPort.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!srcCompref.isValue()) {
				return false;
			}
			if (!dstCompref.isValue()) {
				return false;
			}
			if (!srcPort.isValue()) {
				return false;
			}
			if (!dstPort.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParPort other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParPort other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getsrcCompref().isBound()) {
					return false;
				}
				if(!srcCompref.match(other_value.getsrcCompref(), legacy)) {
					return false;
				}
				if(!other_value.getdstCompref().isBound()) {
					return false;
				}
				if(!dstCompref.match(other_value.getdstCompref(), legacy)) {
					return false;
				}
				if(!other_value.getsrcPort().isBound()) {
					return false;
				}
				if(!srcPort.match(other_value.getsrcPort(), legacy)) {
					return false;
				}
				if(!other_value.getdstPort().isBound()) {
					return false;
				}
				if(!dstPort.match(other_value.getdstPort(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ParPort) {
				return match((ParPort)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ParPort.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(5);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" srcCompref := ");
				srcCompref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dstCompref := ");
				dstCompref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" srcPort := ");
				srcPort.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dstPort := ");
				dstPort.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParPort match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParPort) {
				log_match((ParPort)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.");
		}

		public void log_match(final ParPort match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !srcCompref.match(match_value.constGetsrcCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".srcCompref");
							srcCompref.log_match(match_value.constGetsrcCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dstCompref.match(match_value.constGetdstCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dstCompref");
							dstCompref.log_match(match_value.constGetdstCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !srcPort.match(match_value.constGetsrcPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".srcPort");
							srcPort.log_match(match_value.constGetsrcPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dstPort.match(match_value.constGetdstPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dstPort");
							dstPort.log_match(match_value.constGetdstPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ srcCompref := ");
				srcCompref.log_match(match_value.constGetsrcCompref(), legacy);
				TTCN_Logger.log_event_str("{ dstCompref := ");
				dstCompref.log_match(match_value.constGetdstCompref(), legacy);
				TTCN_Logger.log_event_str("{ srcPort := ");
				srcPort.log_match(match_value.constGetsrcPort(), legacy);
				TTCN_Logger.log_event_str("{ dstPort := ");
				dstPort.log_match(match_value.constGetdstPort(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				srcCompref.encode_text(text_buf);
				dstCompref.encode_text(text_buf);
				srcPort.encode_text(text_buf);
				dstPort.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new ParPort_operation_template();
				operation.decode_text(text_buf);
				srcCompref = new TitanInteger_template();
				srcCompref.decode_text(text_buf);
				dstCompref = new TitanInteger_template();
				dstCompref.decode_text(text_buf);
				srcPort = new TitanCharString_template();
				srcPort.decode_text(text_buf);
				dstPort = new TitanCharString_template();
				dstPort.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParPort_template>(size);
				for (int i = 0; i < size; i++) {
					final ParPort_template temp = new ParPort_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParPort.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ParPort has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrcCompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdstCompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrcPort().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdstPort().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("srcCompref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrcCompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dstCompref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdstCompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("srcPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrcPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dstPort".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdstPort().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParPort: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ParPort");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParPort" : name, legacy);
				this.srcCompref.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParPort" : name, legacy);
				this.dstCompref.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParPort" : name, legacy);
				this.srcPort.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParPort" : name, legacy);
				this.dstPort.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParPort" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParPort" : name));
		}
	}
	public static void ParPort_encoder(final ParPort input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_decoder( final TitanOctetString input_stream, final ParPort output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_actionEvent_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_actionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_actionEvent_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_actionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingDoneType extends Base_Type {
		private final MatchingDoneType_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString type__; //CharString_Type
		private final TitanInteger ptc; //Integer_Type
		private final TitanCharString return__type; //CharString_Type

		public MatchingDoneType() {
			this.reason = new MatchingDoneType_reason();
			this.type__ = new TitanCharString();
			this.ptc = new TitanInteger();
			this.return__type = new TitanCharString();
		}

		public MatchingDoneType(final MatchingDoneType_reason reason, final TitanCharString type__, final TitanInteger ptc, final TitanCharString return__type ) {
			this.reason = new MatchingDoneType_reason( reason );
			this.type__ = new TitanCharString( type__ );
			this.ptc = new TitanInteger( ptc );
			this.return__type = new TitanCharString( return__type );
		}

		public MatchingDoneType( final MatchingDoneType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingDoneType.");
			}
			reason = new MatchingDoneType_reason();
			type__ = new TitanCharString();
			ptc = new TitanInteger();
			return__type = new TitanCharString();
			assign( otherValue );
		}

		public MatchingDoneType assign(final MatchingDoneType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingDoneType");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.gettype__().isBound() ) {
					this.type__.assign( otherValue.gettype__() );
				} else {
					this.type__.cleanUp();
				}
				if ( otherValue.getptc().isBound() ) {
					this.ptc.assign( otherValue.getptc() );
				} else {
					this.ptc.cleanUp();
				}
				if ( otherValue.getreturn__type().isBound() ) {
					this.return__type.assign( otherValue.getreturn__type() );
				} else {
					this.return__type.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingDoneType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType ) {
				return assign((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingDoneType", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			type__.cleanUp();
			ptc.cleanUp();
			return__type.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( type__.isBound() ) { return true; }
			if ( ptc.isBound() ) { return true; }
			if ( return__type.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !type__.isValue() ) { return false; }
			if ( !ptc.isValue() ) { return false; }
			if ( !return__type.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingDoneType otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.type__.operatorEquals( otherValue.type__ ) ) { return false; }
			if ( !this.ptc.operatorEquals( otherValue.ptc ) ) { return false; }
			if ( !this.return__type.operatorEquals( otherValue.return__type ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType ) {
				return operatorEquals((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingDoneType", otherValue));
		}

		public MatchingDoneType_reason getreason() {
			return reason;
		}

		public MatchingDoneType_reason constGetreason() {
			return reason;
		}

		public TitanCharString gettype__() {
			return type__;
		}

		public TitanCharString constGettype__() {
			return type__;
		}

		public TitanInteger getptc() {
			return ptc;
		}

		public TitanInteger constGetptc() {
			return ptc;
		}

		public TitanCharString getreturn__type() {
			return return__type;
		}

		public TitanCharString constGetreturn__type() {
			return return__type;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" type_ := ");
			type__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc := ");
			ptc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" return_type := ");
			return__type.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingDoneType has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettype__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreturn__type().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("type_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettype__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("return_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreturn__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingDoneType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingDoneType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (type__.isBound()) {
				type__.set_implicit_omit();
			}
			if (ptc.isBound()) {
				ptc.set_implicit_omit();
			}
			if (return__type.isBound()) {
				return__type.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			type__.encode_text(text_buf);
			ptc.encode_text(text_buf);
			return__type.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			type__.decode_text(text_buf);
			ptc.decode_text(text_buf);
			return__type.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingDoneType_template extends Base_Template {

		private MatchingDoneType_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template type__; //CharString_Type
		private TitanInteger_template ptc; //Integer_Type
		private TitanCharString_template return__type; //CharString_Type
		//originally value_list/list_value
		private List<MatchingDoneType_template> list_value;

		public MatchingDoneType_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public MatchingDoneType_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return reason;
		}

		public TitanCharString_template gettype__() {
			setSpecific();
			return type__;
		}

		public TitanCharString_template constGettype__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field type_ of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return type__;
		}

		public TitanInteger_template getptc() {
			setSpecific();
			return ptc;
		}

		public TitanInteger_template constGetptc() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field ptc of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return ptc;
		}

		public TitanCharString_template getreturn__type() {
			setSpecific();
			return return__type;
		}

		public TitanCharString_template constGetreturn__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field return_type of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return return__type;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new MatchingDoneType_reason_template();
				type__ = new TitanCharString_template();
				ptc = new TitanInteger_template();
				return__type = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					type__.assign(template_sel.ANY_VALUE);
					ptc.assign(template_sel.ANY_VALUE);
					return__type.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public MatchingDoneType_template() {
			// do nothing
		}

		public MatchingDoneType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingDoneType_template( final MatchingDoneType otherValue ) {
			copyValue(otherValue);
		}

		public MatchingDoneType_template( final MatchingDoneType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingDoneType_template( final Optional<MatchingDoneType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingDoneType from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingDoneType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingDoneType_template assign( final MatchingDoneType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingDoneType_template assign( final MatchingDoneType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingDoneType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType) {
				return assign((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingDoneType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingDoneType_template) {
				return assign((MatchingDoneType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType' can not be cast to {1}_template", otherValue));
		}

		public MatchingDoneType_template assign( final Optional<MatchingDoneType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return this;
		}

		private void copyValue(final MatchingDoneType other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.gettype__().isBound()) {
				gettype__().assign(other_value.gettype__());
			} else {
				gettype__().cleanUp();
			}
			if (other_value.getptc().isBound()) {
				getptc().assign(other_value.getptc());
			} else {
				getptc().cleanUp();
			}
			if (other_value.getreturn__type().isBound()) {
				getreturn__type().assign(other_value.getreturn__type());
			} else {
				getreturn__type().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingDoneType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettype__().get_selection()) {
					gettype__().cleanUp();
				} else {
					gettype__().assign(other_value.gettype__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getptc().get_selection()) {
					getptc().cleanUp();
				} else {
					getptc().assign(other_value.getptc());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreturn__type().get_selection()) {
					getreturn__type().cleanUp();
				} else {
					getreturn__type().assign(other_value.getreturn__type());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingDoneType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingDoneType_template temp = new MatchingDoneType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingDoneType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingDoneType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			final MatchingDoneType ret_val = new MatchingDoneType();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (type__.isBound()) {
				ret_val.gettype__().assign(type__.valueOf());
			}
			if (ptc.isBound()) {
				ret_val.getptc().assign(ptc.valueOf());
			}
			if (return__type.isBound()) {
				ret_val.getreturn__type().assign(return__type.valueOf());
			}
			return ret_val;
		}

		public MatchingDoneType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingDoneType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingDoneType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingDoneType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingDoneType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (type__.isBound()) {
				return true;
			}
			if (ptc.isBound()) {
				return true;
			}
			if (return__type.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!type__.isValue()) {
				return false;
			}
			if (!ptc.isValue()) {
				return false;
			}
			if (!return__type.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingDoneType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingDoneType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.gettype__().isBound()) {
					return false;
				}
				if(!type__.match(other_value.gettype__(), legacy)) {
					return false;
				}
				if(!other_value.getptc().isBound()) {
					return false;
				}
				if(!ptc.match(other_value.getptc(), legacy)) {
					return false;
				}
				if(!other_value.getreturn__type().isBound()) {
					return false;
				}
				if(!return__type.match(other_value.getreturn__type(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingDoneType) {
				return match((MatchingDoneType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingDoneType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" type_ := ");
				type__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc := ");
				ptc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" return_type := ");
				return__type.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingDoneType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingDoneType) {
				log_match((MatchingDoneType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.");
		}

		public void log_match(final MatchingDoneType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !type__.match(match_value.constGettype__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".type_");
							type__.log_match(match_value.constGettype__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ptc.match(match_value.constGetptc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ptc");
							ptc.log_match(match_value.constGetptc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !return__type.match(match_value.constGetreturn__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".return_type");
							return__type.log_match(match_value.constGetreturn__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ type_ := ");
				type__.log_match(match_value.constGettype__(), legacy);
				TTCN_Logger.log_event_str("{ ptc := ");
				ptc.log_match(match_value.constGetptc(), legacy);
				TTCN_Logger.log_event_str("{ return_type := ");
				return__type.log_match(match_value.constGetreturn__type(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				type__.encode_text(text_buf);
				ptc.encode_text(text_buf);
				return__type.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new MatchingDoneType_reason_template();
				reason.decode_text(text_buf);
				type__ = new TitanCharString_template();
				type__.decode_text(text_buf);
				ptc = new TitanInteger_template();
				ptc.decode_text(text_buf);
				return__type = new TitanCharString_template();
				return__type.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingDoneType_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingDoneType_template temp = new MatchingDoneType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingDoneType has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettype__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getptc().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreturn__type().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("type_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettype__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("ptc".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getptc().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("return_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreturn__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingDoneType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingDoneType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingDoneType" : name, legacy);
				this.type__.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingDoneType" : name, legacy);
				this.ptc.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingDoneType" : name, legacy);
				this.return__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingDoneType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingDoneType" : name));
		}
	}
	public static void MatchingDoneType_encoder(final MatchingDoneType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingDoneType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingDoneType_decoder( final TitanOctetString input_stream, final MatchingDoneType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingDoneType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLog_sequence__list_0_event__list_0_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_sequence__list_0_event__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_sequence__list_0_event__list_0_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_sequence__list_0_event__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingFailureType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingFailureType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingFailureType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingFailureType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TestcaseType_reason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseType_reason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__Queue extends Base_Type {
		private final Port__Queue_operation operation; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanInteger msgid; //Integer_Type
		private final TitanCharString address__; //CharString_Type
		private final TitanCharString param__; //CharString_Type

		public Port__Queue() {
			this.operation = new Port__Queue_operation();
			this.port__name = new TitanCharString();
			this.compref = new TitanInteger();
			this.msgid = new TitanInteger();
			this.address__ = new TitanCharString();
			this.param__ = new TitanCharString();
		}

		public Port__Queue(final Port__Queue_operation operation, final TitanCharString port__name, final TitanInteger compref, final TitanInteger msgid, final TitanCharString address__, final TitanCharString param__ ) {
			this.operation = new Port__Queue_operation( operation );
			this.port__name = new TitanCharString( port__name );
			this.compref = new TitanInteger( compref );
			this.msgid = new TitanInteger( msgid );
			this.address__ = new TitanCharString( address__ );
			this.param__ = new TitanCharString( param__ );
		}

		public Port__Queue( final Port__Queue otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_Queue.");
			}
			operation = new Port__Queue_operation();
			port__name = new TitanCharString();
			compref = new TitanInteger();
			msgid = new TitanInteger();
			address__ = new TitanCharString();
			param__ = new TitanCharString();
			assign( otherValue );
		}

		public Port__Queue assign(final Port__Queue otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_Queue");
			}

			if (otherValue != this) {
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getmsgid().isBound() ) {
					this.msgid.assign( otherValue.getmsgid() );
				} else {
					this.msgid.cleanUp();
				}
				if ( otherValue.getaddress__().isBound() ) {
					this.address__.assign( otherValue.getaddress__() );
				} else {
					this.address__.cleanUp();
				}
				if ( otherValue.getparam__().isBound() ) {
					this.param__.assign( otherValue.getparam__() );
				} else {
					this.param__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__Queue assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue ) {
				return assign((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Queue", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			port__name.cleanUp();
			compref.cleanUp();
			msgid.cleanUp();
			address__.cleanUp();
			param__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			if ( address__.isBound() ) { return true; }
			if ( param__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			if ( !address__.isValue() ) { return false; }
			if ( !param__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__Queue otherValue) {
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.msgid.operatorEquals( otherValue.msgid ) ) { return false; }
			if ( !this.address__.operatorEquals( otherValue.address__ ) ) { return false; }
			if ( !this.param__.operatorEquals( otherValue.param__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue ) {
				return operatorEquals((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Queue", otherValue));
		}

		public Port__Queue_operation getoperation() {
			return operation;
		}

		public Port__Queue_operation constGetoperation() {
			return operation;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanInteger getmsgid() {
			return msgid;
		}

		public TitanInteger constGetmsgid() {
			return msgid;
		}

		public TitanCharString getaddress__() {
			return address__;
		}

		public TitanCharString constGetaddress__() {
			return address__;
		}

		public TitanCharString getparam__() {
			return param__;
		}

		public TitanCharString constGetparam__() {
			return param__;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(6);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" address_ := ");
			address__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" param_ := ");
			param__.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Port_Queue has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getaddress__().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparam__().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("address_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getaddress__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("param_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparam__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_Queue: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Port_Queue");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
			if (address__.isBound()) {
				address__.set_implicit_omit();
			}
			if (param__.isBound()) {
				param__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			port__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			msgid.encode_text(text_buf);
			address__.encode_text(text_buf);
			param__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			port__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			msgid.decode_text(text_buf);
			address__.decode_text(text_buf);
			param__.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__Queue_template extends Base_Template {

		private Port__Queue_operation_template operation; //TTCN3_Enumerated_Type
		private TitanCharString_template port__name; //CharString_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanInteger_template msgid; //Integer_Type
		private TitanCharString_template address__; //CharString_Type
		private TitanCharString_template param__; //CharString_Type
		//originally value_list/list_value
		private List<Port__Queue_template> list_value;

		public Port__Queue_operation_template getoperation() {
			setSpecific();
			return operation;
		}

		public Port__Queue_operation_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return operation;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return port__name;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return compref;
		}

		public TitanInteger_template getmsgid() {
			setSpecific();
			return msgid;
		}

		public TitanInteger_template constGetmsgid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return msgid;
		}

		public TitanCharString_template getaddress__() {
			setSpecific();
			return address__;
		}

		public TitanCharString_template constGetaddress__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field address_ of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return address__;
		}

		public TitanCharString_template getparam__() {
			setSpecific();
			return param__;
		}

		public TitanCharString_template constGetparam__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field param_ of a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			return param__;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				operation = new Port__Queue_operation_template();
				port__name = new TitanCharString_template();
				compref = new TitanInteger_template();
				msgid = new TitanInteger_template();
				address__ = new TitanCharString_template();
				param__ = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					operation.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					msgid.assign(template_sel.ANY_VALUE);
					address__.assign(template_sel.ANY_VALUE);
					param__.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Port__Queue_template() {
			// do nothing
		}

		public Port__Queue_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Port__Queue_template( final Port__Queue otherValue ) {
			copyValue(otherValue);
		}

		public Port__Queue_template( final Port__Queue_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Port__Queue_template( final Optional<Port__Queue> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_Queue from an unbound optional field.");
			}
		}

		//originally operator=
		public Port__Queue_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Port__Queue_template assign( final Port__Queue other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Port__Queue_template assign( final Port__Queue_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Port__Queue_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue) {
				return assign((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Queue_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__Queue_template) {
				return assign((Port__Queue_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue' can not be cast to {1}_template", otherValue));
		}

		public Port__Queue_template assign( final Optional<Port__Queue> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_Queue.");
			}
			return this;
		}

		private void copyValue(final Port__Queue other_value) {
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getmsgid().isBound()) {
				getmsgid().assign(other_value.getmsgid());
			} else {
				getmsgid().cleanUp();
			}
			if (other_value.getaddress__().isBound()) {
				getaddress__().assign(other_value.getaddress__());
			} else {
				getaddress__().cleanUp();
			}
			if (other_value.getparam__().isBound()) {
				getparam__().assign(other_value.getparam__());
			} else {
				getparam__().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Port__Queue_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmsgid().get_selection()) {
					getmsgid().cleanUp();
				} else {
					getmsgid().assign(other_value.getmsgid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getaddress__().get_selection()) {
					getaddress__().cleanUp();
				} else {
					getaddress__().assign(other_value.getaddress__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparam__().get_selection()) {
					getparam__().cleanUp();
				} else {
					getparam__().assign(other_value.getparam__());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Port__Queue_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Port__Queue_template temp = new Port__Queue_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_Queue.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__Queue valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			final Port__Queue ret_val = new Port__Queue();
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (msgid.isBound()) {
				ret_val.getmsgid().assign(msgid.valueOf());
			}
			if (address__.isBound()) {
				ret_val.getaddress__().assign(address__.valueOf());
			}
			if (param__.isBound()) {
				ret_val.getparam__().assign(param__.valueOf());
			}
			return ret_val;
		}

		public Port__Queue_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_Queue.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_Queue.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_Queue.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__Queue_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__Queue_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			if (address__.isBound()) {
				return true;
			}
			if (param__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			if (!address__.isValue()) {
				return false;
			}
			if (!param__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__Queue other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__Queue other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getmsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getmsgid(), legacy)) {
					return false;
				}
				if(!other_value.getaddress__().isBound()) {
					return false;
				}
				if(!address__.match(other_value.getaddress__(), legacy)) {
					return false;
				}
				if(!other_value.getparam__().isBound()) {
					return false;
				}
				if(!param__.match(other_value.getparam__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Port__Queue) {
				return match((Port__Queue)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__Queue.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(6);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" address_ := ");
				address__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" param_ := ");
				param__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__Queue match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Queue) {
				log_match((Port__Queue)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.");
		}

		public void log_match(final Port__Queue match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetmsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetmsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !address__.match(match_value.constGetaddress__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".address_");
							address__.log_match(match_value.constGetaddress__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !param__.match(match_value.constGetparam__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".param_");
							param__.log_match(match_value.constGetparam__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetmsgid(), legacy);
				TTCN_Logger.log_event_str("{ address_ := ");
				address__.log_match(match_value.constGetaddress__(), legacy);
				TTCN_Logger.log_event_str("{ param_ := ");
				param__.log_match(match_value.constGetparam__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				port__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				msgid.encode_text(text_buf);
				address__.encode_text(text_buf);
				param__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new Port__Queue_operation_template();
				operation.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				address__ = new TitanCharString_template();
				address__.decode_text(text_buf);
				param__ = new TitanCharString_template();
				param__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__Queue_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__Queue_template temp = new Port__Queue_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Port_Queue has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getaddress__().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparam__().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("address_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getaddress__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("param_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparam__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Port_Queue: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Port_Queue");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				this.msgid.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				this.address__.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				this.param__.check_restriction(restriction, name == null ? "@TitanLoggerApi.Port_Queue" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_Queue" : name));
		}
	}
	public static void Port__Queue_encoder(final Port__Queue input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_decoder( final TitanOctetString input_stream, final Port__Queue output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParallelEvent extends Base_Type {
		private final ParallelEvent_choice choice; //TTCN3_Choice_Type

		public ParallelEvent() {
			this.choice = new ParallelEvent_choice();
		}

		public ParallelEvent(final ParallelEvent_choice choice ) {
			this.choice = new ParallelEvent_choice( choice );
		}

		public ParallelEvent( final ParallelEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParallelEvent.");
			}
			choice = new ParallelEvent_choice();
			assign( otherValue );
		}

		public ParallelEvent assign(final ParallelEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParallelEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParallelEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent ) {
				return assign((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParallelEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent ) {
				return operatorEquals((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelEvent", otherValue));
		}

		public ParallelEvent_choice getchoice() {
			return choice;
		}

		public ParallelEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ParallelEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParallelEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ParallelEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParallelEvent_template extends Base_Template {

		private ParallelEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<ParallelEvent_template> list_value;

		public ParallelEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public ParallelEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.ParallelEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new ParallelEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ParallelEvent_template() {
			// do nothing
		}

		public ParallelEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ParallelEvent_template( final ParallelEvent otherValue ) {
			copyValue(otherValue);
		}

		public ParallelEvent_template( final ParallelEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ParallelEvent_template( final Optional<ParallelEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ParallelEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public ParallelEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ParallelEvent_template assign( final ParallelEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ParallelEvent_template assign( final ParallelEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ParallelEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent) {
				return assign((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ParallelEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParallelEvent_template) {
				return assign((ParallelEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelEvent' can not be cast to {1}_template", otherValue));
		}

		public ParallelEvent_template assign( final Optional<ParallelEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParallelEvent.");
			}
			return this;
		}

		private void copyValue(final ParallelEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ParallelEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ParallelEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ParallelEvent_template temp = new ParallelEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParallelEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParallelEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParallelEvent.");
			}
			final ParallelEvent ret_val = new ParallelEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public ParallelEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParallelEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParallelEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParallelEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParallelEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParallelEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParallelEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParallelEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ParallelEvent) {
				return match((ParallelEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParallelEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelEvent) {
				log_match((ParallelEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.");
		}

		public void log_match(final ParallelEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new ParallelEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParallelEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final ParallelEvent_template temp = new ParallelEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ParallelEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ParallelEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ParallelEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.ParallelEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParallelEvent" : name));
		}
	}
	public static void ParallelEvent_encoder(final ParallelEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelEvent_decoder( final TitanOctetString input_stream, final ParallelEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FinalVerdictType_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_info,  ALT_notification };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public FinalVerdictType_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public FinalVerdictType_choice(final FinalVerdictType_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final FinalVerdictType_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_info:
				field = new FinalVerdictInfo((FinalVerdictInfo)otherValue.field);
				break;
			case ALT_notification:
				field = new FinalVerdictType_choice_notification((FinalVerdictType_choice_notification)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public FinalVerdictType_choice assign( final FinalVerdictType_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public FinalVerdictType_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof FinalVerdictType_choice) {
				return assign((FinalVerdictType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_info:
				return field.isValue();
			case ALT_notification:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final FinalVerdictType_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_info:
				return ((FinalVerdictInfo)field).operatorEquals((FinalVerdictInfo)otherValue.field);
			case ALT_notification:
				return ((FinalVerdictType_choice_notification)field).operatorEquals((FinalVerdictType_choice_notification)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof FinalVerdictType_choice) {
				return operatorEquals((FinalVerdictType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final FinalVerdictType_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public FinalVerdictInfo getinfo() {
			if (union_selection != union_selection_type.ALT_info) {
				cleanUp();
				field = new FinalVerdictInfo();
				union_selection = union_selection_type.ALT_info;
			}
			return (FinalVerdictInfo)field;
		}

		public FinalVerdictInfo constGetinfo() {
			if (union_selection != union_selection_type.ALT_info) {
				throw new TtcnError("Using non-selected field info in a value of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return (FinalVerdictInfo)field;
		}

		public FinalVerdictType_choice_notification getnotification() {
			if (union_selection != union_selection_type.ALT_notification) {
				cleanUp();
				field = new FinalVerdictType_choice_notification();
				union_selection = union_selection_type.ALT_notification;
			}
			return (FinalVerdictType_choice_notification)field;
		}

		public FinalVerdictType_choice_notification constGetnotification() {
			if (union_selection != union_selection_type.ALT_notification) {
				throw new TtcnError("Using non-selected field notification in a value of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return (FinalVerdictType_choice_notification)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_info:
				TTCN_Logger.log_event_str("{ info := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_notification:
				TTCN_Logger.log_event_str("{ notification := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("info".equals(last_name)) {
				getinfo().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("notification".equals(last_name)) {
				getnotification().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.FinalVerdictType.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_info:
			case ALT_notification:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_info:
				text_buf.push_int(0);
				break;
			case ALT_notification:
				text_buf.push_int(1);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getinfo().decode_text(text_buf);
				break;
			case 1:
				getnotification().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.FinalVerdictType.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FinalVerdictType_choice_template extends Base_Template {
		//if single value which value?
		private FinalVerdictType_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<FinalVerdictType_choice_template> value_list;

		private void copy_value(final FinalVerdictType_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_info:
				single_value = new FinalVerdictInfo_template(other_value.constGetinfo());
				break;
			case ALT_notification:
				single_value = new FinalVerdictType_choice_notification_template(other_value.constGetnotification());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final FinalVerdictType_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_info:
					single_value = new FinalVerdictInfo_template(other_value.constGetinfo());
					break;
				case ALT_notification:
					single_value = new FinalVerdictType_choice_notification_template(other_value.constGetnotification());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.FinalVerdictType.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<FinalVerdictType_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final FinalVerdictType_choice_template temp = new FinalVerdictType_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			set_selection(other_value);
		}

		public FinalVerdictType_choice_template() {
			// do nothing
		}
		public FinalVerdictType_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public FinalVerdictType_choice_template(final FinalVerdictType_choice other_value) {
			copy_value(other_value);
		}
		public FinalVerdictType_choice_template(final FinalVerdictType_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_info:
					((FinalVerdictInfo_template)single_value).cleanUp();
					break;
				case ALT_notification:
					((FinalVerdictType_choice_notification_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public FinalVerdictType_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_template assign( final FinalVerdictType_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_template assign( final FinalVerdictType_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public FinalVerdictType_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof FinalVerdictType_choice) {
				return assign((FinalVerdictType_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to FinalVerdictType_choice.");
		}

		@Override
		public FinalVerdictType_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof FinalVerdictType_choice_template) {
				return assign((FinalVerdictType_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to FinalVerdictType_choice_template.");
		}

		// originally match
		public boolean match(final FinalVerdictType_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final FinalVerdictType_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final FinalVerdictType_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_info:
					return ((FinalVerdictInfo_template)single_value).match(other_value.getinfo(), legacy);
				case ALT_notification:
					return ((FinalVerdictType_choice_notification_template)single_value).match(other_value.getnotification(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FinalVerdictType_choice) {
				return match((FinalVerdictType_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictType_choice.");
		}
		public boolean isChosen(final FinalVerdictType_choice.union_selection_type checked_selection) {
			if(checked_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_info:
				return ((FinalVerdictInfo_template)single_value).isValue();
			case ALT_notification:
				return ((FinalVerdictType_choice_notification_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
		}

		public FinalVerdictType_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			final FinalVerdictType_choice ret_val = new FinalVerdictType_choice();
			switch (single_value_union_selection) {
			case ALT_info:
				ret_val.getinfo().assign(((FinalVerdictInfo_template)single_value).valueOf());
				break;
			case ALT_notification:
				ret_val.getnotification().assign(((FinalVerdictType_choice_notification_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<FinalVerdictType_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new FinalVerdictType_choice_template());
			}
		}

		public FinalVerdictType_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public FinalVerdictInfo_template getinfo() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_info) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new FinalVerdictInfo_template(template_sel.ANY_VALUE);
				} else {
					single_value = new FinalVerdictInfo_template();
				}
				single_value_union_selection = FinalVerdictType_choice.union_selection_type.ALT_info;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (FinalVerdictInfo_template)single_value;
		}

		public FinalVerdictInfo_template constGetinfo() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field info in a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			if (single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_info) {
				throw new TtcnError("Accessing non-selected field info in a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return (FinalVerdictInfo_template)single_value;
		}

		public FinalVerdictType_choice_notification_template getnotification() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_notification) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new FinalVerdictType_choice_notification_template(template_sel.ANY_VALUE);
				} else {
					single_value = new FinalVerdictType_choice_notification_template();
				}
				single_value_union_selection = FinalVerdictType_choice.union_selection_type.ALT_notification;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (FinalVerdictType_choice_notification_template)single_value;
		}

		public FinalVerdictType_choice_notification_template constGetnotification() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field notification in a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			if (single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_notification) {
				throw new TtcnError("Accessing non-selected field notification in a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
			}
			return (FinalVerdictType_choice_notification_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictType_choice) {
				log_match((FinalVerdictType_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
		}

		public void log_match(final FinalVerdictType_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_info:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".info");
						single_value.log_match(match_value.getinfo(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ info := ");
						single_value.log_match(match_value.getinfo(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_notification:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".notification");
						single_value.log_match(match_value.getnotification(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ notification := ");
						single_value.log_match(match_value.getnotification(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.FinalVerdictType.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new FinalVerdictInfo_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new FinalVerdictType_choice_notification_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<FinalVerdictType_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final FinalVerdictType_choice_template temp2 = new FinalVerdictType_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.FinalVerdictType.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.FinalVerdictType.choice");
				}
				if("info".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("notification".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.FinalVerdictType.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("info".equals(last_name)) {
					getinfo().set_param(mp_last);
					break;
				}
				if("notification".equals(last_name)) {
					getnotification().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.FinalVerdictType.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.FinalVerdictType.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_info:
					((FinalVerdictInfo_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictType.choice" : name, legacy);
					return;
				case ALT_notification:
					((FinalVerdictType_choice_notification_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictType.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FinalVerdictType.choice" : name));
		}
	}
	public static void FinalVerdictType_choice_encoder(final FinalVerdictType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictType_choice_decoder( final TitanOctetString input_stream, final FinalVerdictType_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_logOptions_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_logOptions_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_logOptions_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_logOptions_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Msg__port__recv extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Msg__port__recv_operation operation; //TTCN3_Enumerated_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString sys__name; //CharString_Type
		private final TitanCharString parameter; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Msg__port__recv() {
			this.port__name = new TitanCharString();
			this.operation = new Msg__port__recv_operation();
			this.compref = new TitanInteger();
			this.sys__name = new TitanCharString();
			this.parameter = new TitanCharString();
			this.msgid = new TitanInteger();
		}

		public Msg__port__recv(final TitanCharString port__name, final Msg__port__recv_operation operation, final TitanInteger compref, final TitanCharString sys__name, final TitanCharString parameter, final TitanInteger msgid ) {
			this.port__name = new TitanCharString( port__name );
			this.operation = new Msg__port__recv_operation( operation );
			this.compref = new TitanInteger( compref );
			this.sys__name = new TitanCharString( sys__name );
			this.parameter = new TitanCharString( parameter );
			this.msgid = new TitanInteger( msgid );
		}

		public Msg__port__recv( final Msg__port__recv otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Msg_port_recv.");
			}
			port__name = new TitanCharString();
			operation = new Msg__port__recv_operation();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
			assign( otherValue );
		}

		public Msg__port__recv assign(final Msg__port__recv otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Msg_port_recv");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getsys__name().isBound() ) {
					this.sys__name.assign( otherValue.getsys__name() );
				} else {
					this.sys__name.cleanUp();
				}
				if ( otherValue.getparameter().isBound() ) {
					this.parameter.assign( otherValue.getparameter() );
				} else {
					this.parameter.cleanUp();
				}
				if ( otherValue.getmsgid().isBound() ) {
					this.msgid.assign( otherValue.getmsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Msg__port__recv assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv ) {
				return assign((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_recv", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			sys__name.cleanUp();
			parameter.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( sys__name.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !sys__name.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Msg__port__recv otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.sys__name.operatorEquals( otherValue.sys__name ) ) { return false; }
			if ( !this.parameter.operatorEquals( otherValue.parameter ) ) { return false; }
			if ( !this.msgid.operatorEquals( otherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv ) {
				return operatorEquals((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_recv", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public Msg__port__recv_operation getoperation() {
			return operation;
		}

		public Msg__port__recv_operation constGetoperation() {
			return operation;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanCharString getsys__name() {
			return sys__name;
		}

		public TitanCharString constGetsys__name() {
			return sys__name;
		}

		public TitanCharString getparameter() {
			return parameter;
		}

		public TitanCharString constGetparameter() {
			return parameter;
		}

		public TitanInteger getmsgid() {
			return msgid;
		}

		public TitanInteger constGetmsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(6);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sys_name := ");
			sys__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Msg_port_recv has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsys__name().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sys_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsys__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Msg_port_recv: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Msg_port_recv");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (sys__name.isBound()) {
				sys__name.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			sys__name.encode_text(text_buf);
			parameter.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			sys__name.decode_text(text_buf);
			parameter.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Msg__port__recv_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private Msg__port__recv_operation_template operation; //TTCN3_Enumerated_Type
		private TitanInteger_template compref; //Integer_Type
		private TitanCharString_template sys__name; //CharString_Type
		private TitanCharString_template parameter; //CharString_Type
		private TitanInteger_template msgid; //Integer_Type
		//originally value_list/list_value
		private List<Msg__port__recv_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return port__name;
		}

		public Msg__port__recv_operation_template getoperation() {
			setSpecific();
			return operation;
		}

		public Msg__port__recv_operation_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return operation;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return compref;
		}

		public TitanCharString_template getsys__name() {
			setSpecific();
			return sys__name;
		}

		public TitanCharString_template constGetsys__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sys_name of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return sys__name;
		}

		public TitanCharString_template getparameter() {
			setSpecific();
			return parameter;
		}

		public TitanCharString_template constGetparameter() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return parameter;
		}

		public TitanInteger_template getmsgid() {
			setSpecific();
			return msgid;
		}

		public TitanInteger_template constGetmsgid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return msgid;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				operation = new Msg__port__recv_operation_template();
				compref = new TitanInteger_template();
				sys__name = new TitanCharString_template();
				parameter = new TitanCharString_template();
				msgid = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					operation.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					sys__name.assign(template_sel.ANY_VALUE);
					parameter.assign(template_sel.ANY_VALUE);
					msgid.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Msg__port__recv_template() {
			// do nothing
		}

		public Msg__port__recv_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Msg__port__recv_template( final Msg__port__recv otherValue ) {
			copyValue(otherValue);
		}

		public Msg__port__recv_template( final Msg__port__recv_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Msg__port__recv_template( final Optional<Msg__port__recv> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Msg_port_recv from an unbound optional field.");
			}
		}

		//originally operator=
		public Msg__port__recv_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Msg__port__recv_template assign( final Msg__port__recv other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Msg__port__recv_template assign( final Msg__port__recv_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Msg__port__recv_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv) {
				return assign((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv' can not be cast to {1}", otherValue));
		}

		@Override
		public Msg__port__recv_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Msg__port__recv_template) {
				return assign((Msg__port__recv_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv' can not be cast to {1}_template", otherValue));
		}

		public Msg__port__recv_template assign( final Optional<Msg__port__recv> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return this;
		}

		private void copyValue(final Msg__port__recv other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getsys__name().isBound()) {
				getsys__name().assign(other_value.getsys__name());
			} else {
				getsys__name().cleanUp();
			}
			if (other_value.getparameter().isBound()) {
				getparameter().assign(other_value.getparameter());
			} else {
				getparameter().cleanUp();
			}
			if (other_value.getmsgid().isBound()) {
				getmsgid().assign(other_value.getmsgid());
			} else {
				getmsgid().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Msg__port__recv_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsys__name().get_selection()) {
					getsys__name().cleanUp();
				} else {
					getsys__name().assign(other_value.getsys__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparameter().get_selection()) {
					getparameter().cleanUp();
				} else {
					getparameter().assign(other_value.getparameter());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmsgid().get_selection()) {
					getmsgid().cleanUp();
				} else {
					getmsgid().assign(other_value.getmsgid());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Msg__port__recv_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Msg__port__recv_template temp = new Msg__port__recv_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Msg_port_recv.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Msg__port__recv valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			final Msg__port__recv ret_val = new Msg__port__recv();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (sys__name.isBound()) {
				ret_val.getsys__name().assign(sys__name.valueOf());
			}
			if (parameter.isBound()) {
				ret_val.getparameter().assign(parameter.valueOf());
			}
			if (msgid.isBound()) {
				ret_val.getmsgid().assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Msg__port__recv_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Msg_port_recv.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Msg_port_recv.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Msg__port__recv_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Msg__port__recv_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (sys__name.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!sys__name.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Msg__port__recv other_value) {
			return match(other_value, false);
		}

		public boolean match(final Msg__port__recv other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getsys__name().isBound()) {
					return false;
				}
				if(!sys__name.match(other_value.getsys__name(), legacy)) {
					return false;
				}
				if(!other_value.getparameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getparameter(), legacy)) {
					return false;
				}
				if(!other_value.getmsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getmsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Msg__port__recv) {
				return match((Msg__port__recv)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Msg__port__recv.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(6);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sys_name := ");
				sys__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Msg__port__recv match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Msg__port__recv) {
				log_match((Msg__port__recv)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.");
		}

		public void log_match(final Msg__port__recv match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sys__name.match(match_value.constGetsys__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sys_name");
							sys__name.log_match(match_value.constGetsys__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetparameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetparameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetmsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetmsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ sys_name := ");
				sys__name.log_match(match_value.constGetsys__name(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetparameter(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetmsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				sys__name.encode_text(text_buf);
				parameter.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Msg__port__recv_operation_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				sys__name = new TitanCharString_template();
				sys__name.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Msg__port__recv_template>(size);
				for (int i = 0; i < size; i++) {
					final Msg__port__recv_template temp = new Msg__port__recv_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 6) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Msg_port_recv has 6 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsys__name().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmsgid().set_param(param.get_elem(5));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sys_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsys__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("msgid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmsgid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Msg_port_recv: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Msg_port_recv");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				this.sys__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				this.parameter.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				this.msgid.check_restriction(restriction, name == null ? "@TitanLoggerApi.Msg_port_recv" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Msg_port_recv" : name));
		}
	}
	public static void Msg__port__recv_encoder(final Msg__port__recv input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_decoder( final TitanOctetString input_stream, final Msg__port__recv output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class StartFunction_parameter__list extends Base_Type {

		private List<TitanCharString> valueElements;

		public StartFunction_parameter__list() {
			// do nothing
		}

		public StartFunction_parameter__list( final StartFunction_parameter__list otherValue ) {
			otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			valueElements = copyList( otherValue.valueElements );
		}

		public StartFunction_parameter__list(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
		}

		private static final List<TitanCharString> copyList( final List<TitanCharString> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
			for (final TitanCharString srcElem : srcList) {
				final TitanCharString newElem = getUnboundElem();
				if (srcElem.isBound()) {
					newElem.assign( srcElem );
				}
				newList.add( ( newElem ) );
			}
			return newList;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return valueElements != null;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !isBound() ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		@Override
		public boolean isValue() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem == null || !elem.isValue()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction_parameter__list) {
				return operatorEquals((StartFunction_parameter__list)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type StartFunction_parameter__list.");
		}

		//originally operator==
		public boolean operatorEquals( final StartFunction_parameter__list otherValue ) {
			mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanCharString leftElem = valueElements.get( i );
				final TitanCharString rightElem = otherValue.valueElements.get( i );
				if (leftElem.isBound()) {
					if (rightElem.isBound()) {
						if ( !leftElem.operatorEquals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.isBound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public StartFunction_parameter__list assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction_parameter__list) {
				return assign((StartFunction_parameter__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
		}

		//originally operator=
		public StartFunction_parameter__list assign( final StartFunction_parameter__list aOtherValue ) {
			aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.StartFunction.parameter_list." );

			valueElements = copyList( aOtherValue.valueElements );
			return this;
		}

		public StartFunction_parameter__list assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanCharString>();
			return this;
		}

		//originally operator+
		public StartFunction_parameter__list concatenate(final StartFunction_parameter__list other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @TitanLoggerApi.StartFunction.parameter_list concatenation.");
			}
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final TitanCharString elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public StartFunction_parameter__list concatenate(final TitanNull_Type nullValue) {
			return new StartFunction_parameter__list(this);
		}

		//originally operator<<=
		public StartFunction_parameter__list rotateLeft(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate left operator.");
			return rotateLeft(rotate_count.getInt());
		}

		//originally operator<<=
		public StartFunction_parameter__list rotateLeft(final int rotate_count) {
			return rotateRight(-rotate_count);
		}

		//originally operator>>=
		public StartFunction_parameter__list rotateRight(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate right operator.");
			return rotateRight(rotate_count.getInt());
		}

		//originally operator>>=
		public StartFunction_parameter__list rotateRight(final int rotate_count) {
			if (valueElements == null) {
				throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			final int size = valueElements.size();
			if (size == 0) {
				return new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new StartFunction_parameter__list(this);
			}
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		//originally clean_up
		public void cleanUp() {
			valueElements = null;
		}

		//originally get_at(int)
		public TitanCharString getAt( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.StartFunction.parameter_list using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				setSize(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final TitanCharString newElem = getUnboundElem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		//originally get_at(const INTEGER&)
		public TitanCharString getAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.StartFunction.parameter_list." );
			return getAt( index_value.getInt() );
		}

		//originally get_at(int) const
		public TitanCharString constGetAt( final int index_value ) {
			if ( !isBound() ) {
				throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.StartFunction.parameter_list." );
			}
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.StartFunction.parameter_list using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().getInt();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.StartFunction.parameter_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanCharString elem = valueElements.get( index_value );
			return ( elem != null ) ? elem : getUnboundElem();
		}

		//originally get_at(const INTEGER&) const
		public TitanCharString constGetAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.StartFunction.parameter_list." );
			return constGetAt( index_value.getInt() );
		}

		public TitanInteger sizeOf() {
			mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return sizeOf();
		}

		public TitanInteger lengthOf() {
			mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanCharString elem = valueElements.get( i );
				if ( elem != null && elem.isBound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void setSize(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanCharString>();
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new TitanCharString() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanCharString getUnboundElem() {
			return new TitanCharString();
		}
		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */

		@Override
		public String toString() {
			if (!isBound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public StartFunction_parameter__list substr(final int index, final int returncount) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.StartFunction.parameter_list","element");
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list repl) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			if (repl.valueElements == null) {
				throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.StartFunction.parameter_list","element");
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanCharString elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanCharString elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final TitanCharString elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanCharString(elem));
				}
			}
			return ret_val;
		}

		public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueOf());
		}

		public StartFunction_parameter__list replace(final int index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.getInt(), repl.valueOf());
		}

		public StartFunction_parameter__list replace(final TitanInteger index, final int len, final StartFunction_parameter__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len, repl.valueOf());
		}

		public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len.getInt(), repl.valueOf());
		}
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					setSize(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(i).set_param(current);
							if (!constGetAt(i).isBound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						getAt(current.get_id().get_index()).set_param(current);
						if (!constGetAt(current.get_id().get_index()).isBound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.StartFunction.parameter_list");
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!isBound()) {
						assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthOf().getInt();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.StartFunction.parameter_list");
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class StartFunction_parameter__list_template extends Record_Of_Template {

		//originally single_value/value_elements
		private List<TitanCharString_template> value_elements;

		//originally value_list/list_value
		private List<StartFunction_parameter__list_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((StartFunction_parameter__list)value_ptr, value_index, (StartFunction_parameter__list_template)template_ptr, template_index, legacy);
			}
		};

		public StartFunction_parameter__list_template() {
			// do nothing
		}

		public StartFunction_parameter__list_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public StartFunction_parameter__list_template( final StartFunction_parameter__list otherValue ) {
			copy_value( otherValue );
		}

		public StartFunction_parameter__list_template( final StartFunction_parameter__list_template otherValue ) {
			copyTemplate( otherValue );
		}

		public StartFunction_parameter__list_template( final Optional<StartFunction_parameter__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.StartFunction.parameter_list from an unbound optional field.");
			}
		}

		public StartFunction_parameter__list_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanCharString_template>();
		}

		private void copy_value(final StartFunction_parameter__list other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Initialization of a template of type @TitanLoggerApi.StartFunction.parameter_list with an unbound value.");
			}
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final StartFunction_parameter__list_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanCharString_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGetAt(elem_count).isBound()) {
						value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
					} else {
						value_elements.add( new TitanCharString_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<StartFunction_parameter__list_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final StartFunction_parameter__list_template temp = new StartFunction_parameter__list_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		// originally match
		public boolean match(final StartFunction_parameter__list other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final StartFunction_parameter__list other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
		}

		private boolean match_index(final StartFunction_parameter__list value_ptr, final int value_index, final StartFunction_parameter__list_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof StartFunction_parameter__list) {
				return match((StartFunction_parameter__list)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		//originally operator=
		public StartFunction_parameter__list_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public StartFunction_parameter__list_template assign( final StartFunction_parameter__list other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public StartFunction_parameter__list_template assign( final StartFunction_parameter__list_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public StartFunction_parameter__list_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction_parameter__list) {
				return assign((StartFunction_parameter__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
		}

		@Override
		public StartFunction_parameter__list_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StartFunction_parameter__list_template) {
				return assign((StartFunction_parameter__list_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list_template.");
		}

		public StartFunction_parameter__list_template assign( final Optional<StartFunction_parameter__list> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			return this;
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl.valueOf());
		}

		public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
		}

		public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl);
		}

		public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl);
		}

		public TitanCharString_template getAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.StartFunction.parameter_list using a negative index: {0}.", index_value ) );
			}

			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				setSize(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			return value_elements.get(index_value);
		}

		public TitanCharString_template getAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}

			return getAt(index_value.getInt());
		}

		public TitanCharString_template constGetAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.StartFunction.parameter_list using a negative index: {0}.", index_value ) );
			}

			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.StartFunction.parameter_list.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.StartFunction.parameter_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public TitanCharString_template constGetAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}

			return constGetAt(index_value.getInt());
		}

		private int get_length_for_concat(final AtomicBoolean is_any_value) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					if (templateSelection == template_sel.ANY_VALUE) {
						// ? => { * }
						is_any_value.set( true );
						return 1;
					}
					throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
				case RANGE_LENGTH_RESTRICTION:
					if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
						throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
					}
					// else fall through (range length restriction is allowed if the minimum
					// and maximum value are the same)
				case SINGLE_LENGTH_RESTRICTION:
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
				}
			default:
				throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
			}
		}

		private int get_length_for_concat(final StartFunction_parameter__list operand) {
			operand.mustBound("Operand of record of template concatenation is an unbound value.");
			return operand.valueElements.size();
		}


		private int get_length_for_concat(final template_sel operand) {
			if (operand == template_sel.ANY_VALUE) {
				// ? => { * }
				return 1;
			}
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}

		//TODO: simplify, just use value_elements.add()
		private void concat(final AtomicInteger pos, final StartFunction_parameter__list_template operand) {
			// all errors should have already been caught by the operand's
			// get_length_for_concat() call;
			// the result template (this) should already be set to SPECIFIC_VALUE and
			// single_value.value_elements should already be allocated
			switch (operand.templateSelection) {
			case SPECIFIC_VALUE:
				for (int i = 0; i < operand.value_elements.size(); ++i) {
					value_elements.set( pos.get() + i, new TitanCharString_template(operand.value_elements.get(i)) );
				}
				pos.addAndGet( operand.value_elements.size() );
				break;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (operand.length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					// ? => { * }
					value_elements.set( pos.get(), new TitanCharString_template( template_sel.ANY_OR_OMIT ) );
					pos.incrementAndGet();
					break;
				case RANGE_LENGTH_RESTRICTION:
				case SINGLE_LENGTH_RESTRICTION: {
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
					for (int i = 0; i < N; ++i) {
						value_elements.set( pos.get() + i, new TitanCharString_template( template_sel.ANY_VALUE ) );
					}
					pos.addAndGet( N );
					break; }
				}
			default:
				break;
			}
		}

		public void setSize(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			final template_sel old_selection = templateSelection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanCharString_template>();
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanCharString_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				final int oldSize = value_elements.size();
				for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
					value_elements.remove( new_size );
				}
			}
		}

		public TitanInteger sizeOf() {
			return sizeOf(true);
		}

		public TitanInteger lengthOf() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (templateSelection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.size()<1) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).getInt();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type StartFunction_parameter__list.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
		}

		public TitanInteger n_elem() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type StartFunction_parameter__list containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type StartFunction_parameter__list.");
		}

		private boolean matchv(final StartFunction_parameter__list other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).matchv(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type StartFunction_parameter__list.");
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).isValue()) {
					return false;
				}
			}
			return true;
		}

		public void setType(final template_sel template_type, final int list_length) {
			cleanUp();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<StartFunction_parameter__list_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new StartFunction_parameter__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			set_selection(template_type);
		}

		public StartFunction_parameter__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			return list_value.get(list_index);
		}

		public StartFunction_parameter__list_template get_list_item(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			if (list_index < 0) {
				throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.StartFunction.parameter_list using a negative index ({0}).", list_index ) );
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			return list_value.get( list_index );
		}

		public StartFunction_parameter__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public StartFunction_parameter__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final StartFunction_parameter__list match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StartFunction_parameter__list) {
				log_match((StartFunction_parameter__list)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StartFunction.parameter_list.");
		}

		public void log_match(final StartFunction_parameter__list match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StartFunction_parameter__list_template>(size);
				for (int i = 0; i < size; i++) {
					final StartFunction_parameter__list_template temp2 = new StartFunction_parameter__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					setSize(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					getAt(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				setSize(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							getAt(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						getAt(current_index).set_param(param.get_elem(i));
						current_index++;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@TitanLoggerApi.StartFunction.parameter_list");
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (templateSelection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++)
					value_elements.get(i).check_restriction(restriction, name == null ? "@TitanLoggerApi.StartFunction.parameter_list" : name, false);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) return;
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.StartFunction.parameter_list" : name));
		}
	}
	public static void StartFunction_parameter__list_encoder(final StartFunction_parameter__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction.parameter_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StartFunction_parameter__list_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StartFunction_parameter__list_decoder( final TitanOctetString input_stream, final StartFunction_parameter__list output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction.parameter_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StartFunction_parameter__list_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLogEvent_logEvent_encoder(final LogEventType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_logEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_logEvent_decoder( final TitanOctetString input_stream, final LogEventType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_logEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimerType extends Base_Type {
		private final TitanCharString name; //CharString_Type
		private final TitanFloat value__; //Float_Type

		public TimerType() {
			this.name = new TitanCharString();
			this.value__ = new TitanFloat();
		}

		public TimerType(final TitanCharString name, final TitanFloat value__ ) {
			this.name = new TitanCharString( name );
			this.value__ = new TitanFloat( value__ );
		}

		public TimerType( final TimerType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerType.");
			}
			name = new TitanCharString();
			value__ = new TitanFloat();
			assign( otherValue );
		}

		public TimerType assign(final TimerType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerType");
			}

			if (otherValue != this) {
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
				if ( otherValue.getvalue__().isBound() ) {
					this.value__.assign( otherValue.getvalue__() );
				} else {
					this.value__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerType ) {
				return assign((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerType", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			value__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( value__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !value__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerType otherValue) {
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			if ( !this.value__.operatorEquals( otherValue.value__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerType ) {
				return operatorEquals((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerType", otherValue));
		}

		public TitanCharString getname() {
			return name;
		}

		public TitanCharString constGetname() {
			return name;
		}

		public TitanFloat getvalue__() {
			return value__;
		}

		public TitanFloat constGetvalue__() {
			return value__;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TimerType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TimerType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			value__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			value__.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TimerType_template extends Base_Template {

		private TitanCharString_template name; //CharString_Type
		private TitanFloat_template value__; //Float_Type
		//originally value_list/list_value
		private List<TimerType_template> list_value;

		public TitanCharString_template getname() {
			setSpecific();
			return name;
		}

		public TitanCharString_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.TimerType.");
			}
			return name;
		}

		public TitanFloat_template getvalue__() {
			setSpecific();
			return value__;
		}

		public TitanFloat_template constGetvalue__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.TimerType.");
			}
			return value__;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				name = new TitanCharString_template();
				value__ = new TitanFloat_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					name.assign(template_sel.ANY_VALUE);
					value__.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TimerType_template() {
			// do nothing
		}

		public TimerType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TimerType_template( final TimerType otherValue ) {
			copyValue(otherValue);
		}

		public TimerType_template( final TimerType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TimerType_template( final Optional<TimerType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerType from an unbound optional field.");
			}
		}

		//originally operator=
		public TimerType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimerType_template assign( final TimerType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TimerType_template assign( final TimerType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TimerType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerType) {
				return assign((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerType_template) {
				return assign((TimerType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerType' can not be cast to {1}_template", otherValue));
		}

		public TimerType_template assign( final Optional<TimerType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerType.");
			}
			return this;
		}

		private void copyValue(final TimerType other_value) {
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			if (other_value.getvalue__().isBound()) {
				getvalue__().assign(other_value.getvalue__());
			} else {
				getvalue__().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TimerType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getvalue__().get_selection()) {
					getvalue__().cleanUp();
				} else {
					getvalue__().assign(other_value.getvalue__());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TimerType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TimerType_template temp = new TimerType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerType.");
			}
			final TimerType ret_val = new TimerType();
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			if (value__.isBound()) {
				ret_val.getvalue__().assign(value__.valueOf());
			}
			return ret_val;
		}

		public TimerType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				if(!other_value.getvalue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getvalue__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TimerType) {
				return match((TimerType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerType) {
				log_match((TimerType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerType.");
		}

		public void log_match(final TimerType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !value__.match(match_value.constGetvalue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetvalue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetvalue__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				value__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				value__ = new TitanFloat_template();
				value__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerType_template>(size);
				for (int i = 0; i < size; i++) {
					final TimerType_template temp = new TimerType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TimerType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TimerType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerType" : name, legacy);
				this.value__.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimerType" : name));
		}
	}
	public static void TimerType_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerType_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class DefaultEvent extends Base_Type {
		private final DefaultEvent_choice choice; //TTCN3_Choice_Type

		public DefaultEvent() {
			this.choice = new DefaultEvent_choice();
		}

		public DefaultEvent(final DefaultEvent_choice choice ) {
			this.choice = new DefaultEvent_choice( choice );
		}

		public DefaultEvent( final DefaultEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.DefaultEvent.");
			}
			choice = new DefaultEvent_choice();
			assign( otherValue );
		}

		public DefaultEvent assign(final DefaultEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.DefaultEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public DefaultEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent ) {
				return assign((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final DefaultEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent ) {
				return operatorEquals((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultEvent", otherValue));
		}

		public DefaultEvent_choice getchoice() {
			return choice;
		}

		public DefaultEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.DefaultEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.DefaultEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.DefaultEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class DefaultEvent_template extends Base_Template {

		private DefaultEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<DefaultEvent_template> list_value;

		public DefaultEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public DefaultEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.DefaultEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new DefaultEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public DefaultEvent_template() {
			// do nothing
		}

		public DefaultEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public DefaultEvent_template( final DefaultEvent otherValue ) {
			copyValue(otherValue);
		}

		public DefaultEvent_template( final DefaultEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public DefaultEvent_template( final Optional<DefaultEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.DefaultEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public DefaultEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public DefaultEvent_template assign( final DefaultEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public DefaultEvent_template assign( final DefaultEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public DefaultEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent) {
				return assign((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public DefaultEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof DefaultEvent_template) {
				return assign((DefaultEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEvent' can not be cast to {1}_template", otherValue));
		}

		public DefaultEvent_template assign( final Optional<DefaultEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.DefaultEvent.");
			}
			return this;
		}

		private void copyValue(final DefaultEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final DefaultEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<DefaultEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final DefaultEvent_template temp = new DefaultEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.DefaultEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public DefaultEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.DefaultEvent.");
			}
			final DefaultEvent ret_val = new DefaultEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public DefaultEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.DefaultEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.DefaultEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.DefaultEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<DefaultEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new DefaultEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final DefaultEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final DefaultEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof DefaultEvent) {
				return match((DefaultEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final DefaultEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultEvent) {
				log_match((DefaultEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.");
		}

		public void log_match(final DefaultEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new DefaultEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<DefaultEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final DefaultEvent_template temp = new DefaultEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.DefaultEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.DefaultEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.DefaultEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.DefaultEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.DefaultEvent" : name));
		}
	}
	public static void DefaultEvent_encoder(final DefaultEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEvent_decoder( final TitanOctetString input_stream, final DefaultEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TestcaseType_verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TestcaseType_verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TestcaseType_verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TestcaseType_verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Parallel_src__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_src__port_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_src__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_src__port_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__discard_unhandled_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__discard_unhandled_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__discard_unhandled_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__discard_unhandled_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__Queue_operation extends Base_Type {
		public enum enum_type {
			enqueue__msg (0),
			enqueue__call (1),
			enqueue__reply (2),
			enqueue__exception (3),
			extract__msg (4),
			extract__op (5),
			UNKNOWN_VALUE(6),
			UNBOUND_VALUE(7);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return enqueue__msg;
				case 1:  return enqueue__call;
				case 2:  return enqueue__reply;
				case 3:  return enqueue__exception;
				case 4:  return extract__msg;
				case 5:  return extract__op;
				case 6:  return UNKNOWN_VALUE;
				case 7:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Port__Queue_operation() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Port__Queue_operation(final Port__Queue_operation otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Port__Queue_operation(final Port__Queue_operation.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Port__Queue_operation(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__Queue_operation' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Port__Queue_operation assign(final Port__Queue_operation otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Port__Queue_operation assign(final Base_Type otherValue){
			if( otherValue instanceof Port__Queue_operation ) {
				return assign((Port__Queue_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Port__Queue_operation assign(final Port__Queue_operation.enum_type otherValue){
			return assign( new Port__Queue_operation(otherValue) );
		}

		//originally operator=
		public Port__Queue_operation assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__Queue_operation'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Port__Queue_operation otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Port__Queue_operation) {
				return operatorEquals( (Port__Queue_operation) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.operation.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Port__Queue_operation.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__Queue_operation otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__Queue_operation.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Port__Queue_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Port__Queue_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__Queue_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__Queue_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__Queue_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__Queue_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__Queue_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__Queue_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Port__Queue_operation.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Port__Queue_operation enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("enqueue__msg".equals(strPar) || "enqueue_msg".equals(strPar)) {
				return enum_type.enqueue__msg;
			}
			if ("enqueue__call".equals(strPar) || "enqueue_call".equals(strPar)) {
				return enum_type.enqueue__call;
			}
			if ("enqueue__reply".equals(strPar) || "enqueue_reply".equals(strPar)) {
				return enum_type.enqueue__reply;
			}
			if ("enqueue__exception".equals(strPar) || "enqueue_exception".equals(strPar)) {
				return enum_type.enqueue__exception;
			}
			if ("extract__msg".equals(strPar) || "extract_msg".equals(strPar)) {
				return enum_type.extract__msg;
			}
			if ("extract__op".equals(strPar) || "extract_op".equals(strPar)) {
				return enum_type.extract__op;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Port_Queue.operation");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Port_Queue.operation.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_Queue.operation.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Queue.operation.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__Queue_operation_template extends Base_Template {
		// single_value
		private Port__Queue_operation.enum_type single_value;
		// value_list part
		private ArrayList<Port__Queue_operation_template> value_list;

		private void copy_template(final Port__Queue_operation_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Port__Queue_operation_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Port__Queue_operation_template temp = new Port__Queue_operation_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__Queue_operation.");
			}
		}

		public Port__Queue_operation_template() {
			// do nothing
		}

		public Port__Queue_operation_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Port__Queue_operation_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Port__Queue_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Port__Queue_operation with unknown numeric value "+ otherValue +".");
			}
			single_value = Port__Queue_operation.enum_type.getValue(otherValue);
		}

		public Port__Queue_operation_template(final Port__Queue_operation otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Port__Queue_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Port__Queue_operation. ");
			}
			single_value = otherValue.enum_value;
		}

		public Port__Queue_operation_template(final Port__Queue_operation_template otherValue) {
			copy_template(otherValue);
		}

		public Port__Queue_operation_template(final Port__Queue_operation.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Port__Queue_operation.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Port__Queue_operation_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Port__Queue_operation_template assign(final int otherValue) {
			if (!Port__Queue_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__Queue_operation.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Port__Queue_operation_template assign(final Port__Queue_operation.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Port__Queue_operation_template assign(final Port__Queue_operation_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Port__Queue_operation_template assign(final Port__Queue_operation otherValue){
			if (otherValue.enum_value == Port__Queue_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Port__Queue_operation to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Port__Queue_operation_template assign(final Base_Type otherValue){
			if( otherValue instanceof Port__Queue_operation ) {
				return assign((Port__Queue_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Queue_operation_template assign(final Base_Template otherValue){
			if( otherValue instanceof Port__Queue_operation_template ) {
				return assign((Port__Queue_operation_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Port__Queue_operation.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Port__Queue_operation.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__Queue_operation.");
			}
		}

		// originally match
		public boolean match(final Port__Queue_operation otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Port__Queue_operation otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Port__Queue_operation ) {
				return match((Port__Queue_operation) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
		}

		public Port__Queue_operation valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__Queue_operation.");
			}
			return new Port__Queue_operation(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__Queue_operation.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Port__Queue_operation_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Port__Queue_operation_template());
			}
		}

		public Port__Queue_operation_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__Queue_operation.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Port__Queue_operation.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Port__Queue_operation.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Port__Queue_operation.enum2str(single_value), Port__Queue_operation.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Queue_operation) {
				log_match((Port__Queue_operation)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.operation.");
		}
		public void log_match(final Port__Queue_operation match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Port__Queue_operation.enum_type enum_value = Port__Queue_operation.str_to_enum(param.get_enumerated());
				if (!Port__Queue_operation.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Port_Queue.operation.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Port_Queue.operation");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_Queue.operation.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Port__Queue_operation.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Queue.operation.", temp));
				}
				single_value = Port__Queue_operation.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Port__Queue_operation_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__Queue_operation_template temp = new Port__Queue_operation_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_Queue.operation.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_Queue.operation" : name));
		}
	}
	public static void Port__Queue_operation_encoder(final Port__Queue_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_operation_decoder( final TitanOctetString input_stream, final Port__Queue_operation output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLogEvent_sourceInfo__list_0_encoder(final LocationInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLogEvent_sourceInfo__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLogEvent_sourceInfo__list_0_decoder( final TitanOctetString input_stream, final LocationInfo output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLogEvent_sourceInfo__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerType_value___encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerType_value___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerType_value___decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerType_value___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingProblemType extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final MatchingProblemType_reason reason; //TTCN3_Enumerated_Type
		private final MatchingProblemType_operation operation; //TTCN3_Enumerated_Type
		private final TitanBoolean check__; //Boolean_Type
		private final TitanBoolean any__port; //Boolean_Type

		public MatchingProblemType() {
			this.port__name = new TitanCharString();
			this.reason = new MatchingProblemType_reason();
			this.operation = new MatchingProblemType_operation();
			this.check__ = new TitanBoolean();
			this.any__port = new TitanBoolean();
		}

		public MatchingProblemType(final TitanCharString port__name, final MatchingProblemType_reason reason, final MatchingProblemType_operation operation, final TitanBoolean check__, final TitanBoolean any__port ) {
			this.port__name = new TitanCharString( port__name );
			this.reason = new MatchingProblemType_reason( reason );
			this.operation = new MatchingProblemType_operation( operation );
			this.check__ = new TitanBoolean( check__ );
			this.any__port = new TitanBoolean( any__port );
		}

		public MatchingProblemType( final MatchingProblemType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingProblemType.");
			}
			port__name = new TitanCharString();
			reason = new MatchingProblemType_reason();
			operation = new MatchingProblemType_operation();
			check__ = new TitanBoolean();
			any__port = new TitanBoolean();
			assign( otherValue );
		}

		public MatchingProblemType assign(final MatchingProblemType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingProblemType");
			}

			if (otherValue != this) {
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getoperation().isBound() ) {
					this.operation.assign( otherValue.getoperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( otherValue.getcheck__().isBound() ) {
					this.check__.assign( otherValue.getcheck__() );
				} else {
					this.check__.cleanUp();
				}
				if ( otherValue.getany__port().isBound() ) {
					this.any__port.assign( otherValue.getany__port() );
				} else {
					this.any__port.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingProblemType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType ) {
				return assign((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingProblemType", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			reason.cleanUp();
			operation.cleanUp();
			check__.cleanUp();
			any__port.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( check__.isBound() ) { return true; }
			if ( any__port.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !check__.isValue() ) { return false; }
			if ( !any__port.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingProblemType otherValue) {
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.operation.operatorEquals( otherValue.operation ) ) { return false; }
			if ( !this.check__.operatorEquals( otherValue.check__ ) ) { return false; }
			if ( !this.any__port.operatorEquals( otherValue.any__port ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType ) {
				return operatorEquals((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingProblemType", otherValue));
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public MatchingProblemType_reason getreason() {
			return reason;
		}

		public MatchingProblemType_reason constGetreason() {
			return reason;
		}

		public MatchingProblemType_operation getoperation() {
			return operation;
		}

		public MatchingProblemType_operation constGetoperation() {
			return operation;
		}

		public TitanBoolean getcheck__() {
			return check__;
		}

		public TitanBoolean constGetcheck__() {
			return check__;
		}

		public TitanBoolean getany__port() {
			return any__port;
		}

		public TitanBoolean constGetany__port() {
			return any__port;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(5);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" check_ := ");
			check__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" any_port := ");
			any__port.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingProblemType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcheck__().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getany__port().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("check_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcheck__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("any_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getany__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingProblemType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingProblemType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (check__.isBound()) {
				check__.set_implicit_omit();
			}
			if (any__port.isBound()) {
				any__port.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			reason.encode_text(text_buf);
			operation.encode_text(text_buf);
			check__.encode_text(text_buf);
			any__port.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			reason.decode_text(text_buf);
			operation.decode_text(text_buf);
			check__.decode_text(text_buf);
			any__port.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingProblemType_template extends Base_Template {

		private TitanCharString_template port__name; //CharString_Type
		private MatchingProblemType_reason_template reason; //TTCN3_Enumerated_Type
		private MatchingProblemType_operation_template operation; //TTCN3_Enumerated_Type
		private TitanBoolean_template check__; //Boolean_Type
		private TitanBoolean_template any__port; //Boolean_Type
		//originally value_list/list_value
		private List<MatchingProblemType_template> list_value;

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return port__name;
		}

		public MatchingProblemType_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public MatchingProblemType_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return reason;
		}

		public MatchingProblemType_operation_template getoperation() {
			setSpecific();
			return operation;
		}

		public MatchingProblemType_operation_template constGetoperation() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return operation;
		}

		public TitanBoolean_template getcheck__() {
			setSpecific();
			return check__;
		}

		public TitanBoolean_template constGetcheck__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field check_ of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return check__;
		}

		public TitanBoolean_template getany__port() {
			setSpecific();
			return any__port;
		}

		public TitanBoolean_template constGetany__port() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field any_port of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return any__port;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				port__name = new TitanCharString_template();
				reason = new MatchingProblemType_reason_template();
				operation = new MatchingProblemType_operation_template();
				check__ = new TitanBoolean_template();
				any__port = new TitanBoolean_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					port__name.assign(template_sel.ANY_VALUE);
					reason.assign(template_sel.ANY_VALUE);
					operation.assign(template_sel.ANY_VALUE);
					check__.assign(template_sel.ANY_VALUE);
					any__port.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public MatchingProblemType_template() {
			// do nothing
		}

		public MatchingProblemType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingProblemType_template( final MatchingProblemType otherValue ) {
			copyValue(otherValue);
		}

		public MatchingProblemType_template( final MatchingProblemType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingProblemType_template( final Optional<MatchingProblemType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingProblemType from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingProblemType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingProblemType_template assign( final MatchingProblemType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingProblemType_template assign( final MatchingProblemType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingProblemType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType) {
				return assign((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingProblemType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingProblemType_template) {
				return assign((MatchingProblemType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType' can not be cast to {1}_template", otherValue));
		}

		public MatchingProblemType_template assign( final Optional<MatchingProblemType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return this;
		}

		private void copyValue(final MatchingProblemType other_value) {
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getoperation().isBound()) {
				getoperation().assign(other_value.getoperation());
			} else {
				getoperation().cleanUp();
			}
			if (other_value.getcheck__().isBound()) {
				getcheck__().assign(other_value.getcheck__());
			} else {
				getcheck__().cleanUp();
			}
			if (other_value.getany__port().isBound()) {
				getany__port().assign(other_value.getany__port());
			} else {
				getany__port().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingProblemType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoperation().get_selection()) {
					getoperation().cleanUp();
				} else {
					getoperation().assign(other_value.getoperation());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcheck__().get_selection()) {
					getcheck__().cleanUp();
				} else {
					getcheck__().assign(other_value.getcheck__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getany__port().get_selection()) {
					getany__port().cleanUp();
				} else {
					getany__port().assign(other_value.getany__port());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingProblemType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingProblemType_template temp = new MatchingProblemType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingProblemType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingProblemType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			final MatchingProblemType ret_val = new MatchingProblemType();
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (operation.isBound()) {
				ret_val.getoperation().assign(operation.valueOf());
			}
			if (check__.isBound()) {
				ret_val.getcheck__().assign(check__.valueOf());
			}
			if (any__port.isBound()) {
				ret_val.getany__port().assign(any__port.valueOf());
			}
			return ret_val;
		}

		public MatchingProblemType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingProblemType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingProblemType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingProblemType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingProblemType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (check__.isBound()) {
				return true;
			}
			if (any__port.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!check__.isValue()) {
				return false;
			}
			if (!any__port.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingProblemType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingProblemType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getoperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getoperation(), legacy)) {
					return false;
				}
				if(!other_value.getcheck__().isBound()) {
					return false;
				}
				if(!check__.match(other_value.getcheck__(), legacy)) {
					return false;
				}
				if(!other_value.getany__port().isBound()) {
					return false;
				}
				if(!any__port.match(other_value.getany__port(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingProblemType) {
				return match((MatchingProblemType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingProblemType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(5);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" check_ := ");
				check__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" any_port := ");
				any__port.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingProblemType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingProblemType) {
				log_match((MatchingProblemType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.");
		}

		public void log_match(final MatchingProblemType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetoperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetoperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !check__.match(match_value.constGetcheck__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".check_");
							check__.log_match(match_value.constGetcheck__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !any__port.match(match_value.constGetany__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".any_port");
							any__port.log_match(match_value.constGetany__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetoperation(), legacy);
				TTCN_Logger.log_event_str("{ check_ := ");
				check__.log_match(match_value.constGetcheck__(), legacy);
				TTCN_Logger.log_event_str("{ any_port := ");
				any__port.log_match(match_value.constGetany__port(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				reason.encode_text(text_buf);
				operation.encode_text(text_buf);
				check__.encode_text(text_buf);
				any__port.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				reason = new MatchingProblemType_reason_template();
				reason.decode_text(text_buf);
				operation = new MatchingProblemType_operation_template();
				operation.decode_text(text_buf);
				check__ = new TitanBoolean_template();
				check__.decode_text(text_buf);
				any__port = new TitanBoolean_template();
				any__port.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingProblemType_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingProblemType_template temp = new MatchingProblemType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingProblemType has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoperation().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcheck__().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getany__port().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("operation".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoperation().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("check_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcheck__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("any_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getany__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingProblemType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingProblemType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingProblemType" : name, legacy);
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingProblemType" : name, legacy);
				this.operation.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingProblemType" : name, legacy);
				this.check__.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingProblemType" : name, legacy);
				this.any__port.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingProblemType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingProblemType" : name));
		}
	}
	public static void MatchingProblemType_encoder(final MatchingProblemType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_decoder( final TitanOctetString input_stream, final MatchingProblemType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Strings extends Base_Type {
		private final Strings_str__list str__list; //SequenceOf_Type

		public Strings() {
			this.str__list = new Strings_str__list();
		}

		public Strings(final Strings_str__list str__list ) {
			this.str__list = new Strings_str__list( str__list );
		}

		public Strings( final Strings otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Strings.");
			}
			str__list = new Strings_str__list();
			assign( otherValue );
		}

		public Strings assign(final Strings otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Strings");
			}

			if (otherValue != this) {
				if ( otherValue.getstr__list().isBound() ) {
					this.str__list.assign( otherValue.getstr__list() );
				} else {
					this.str__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Strings assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings ) {
				return assign((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Strings", otherValue));
		}

		public void cleanUp() {
			str__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( str__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !str__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Strings otherValue) {
			if ( !this.str__list.operatorEquals( otherValue.str__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Strings ) {
				return operatorEquals((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Strings", otherValue));
		}

		public Strings_str__list getstr__list() {
			return str__list;
		}

		public Strings_str__list constGetstr__list() {
			return str__list;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" str_list := ");
			str__list.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Strings has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstr__list().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("str_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstr__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Strings: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Strings");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (str__list.isBound()) {
				str__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			str__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			str__list.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Strings_template extends Base_Template {

		private Strings_str__list_template str__list; //SequenceOf_Type
		//originally value_list/list_value
		private List<Strings_template> list_value;

		public Strings_str__list_template getstr__list() {
			setSpecific();
			return str__list;
		}

		public Strings_str__list_template constGetstr__list() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field str_list of a non-specific template of type @TitanLoggerApi.Strings.");
			}
			return str__list;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				str__list = new Strings_str__list_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					str__list.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Strings_template() {
			// do nothing
		}

		public Strings_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Strings_template( final Strings otherValue ) {
			copyValue(otherValue);
		}

		public Strings_template( final Strings_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Strings_template( final Optional<Strings> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Strings from an unbound optional field.");
			}
		}

		//originally operator=
		public Strings_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Strings_template assign( final Strings other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Strings_template assign( final Strings_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Strings_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings) {
				return assign((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Strings' can not be cast to {1}", otherValue));
		}

		@Override
		public Strings_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Strings_template) {
				return assign((Strings_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Strings' can not be cast to {1}_template", otherValue));
		}

		public Strings_template assign( final Optional<Strings> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Strings.");
			}
			return this;
		}

		private void copyValue(final Strings other_value) {
			if (other_value.getstr__list().isBound()) {
				getstr__list().assign(other_value.getstr__list());
			} else {
				getstr__list().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Strings_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getstr__list().get_selection()) {
					getstr__list().cleanUp();
				} else {
					getstr__list().assign(other_value.getstr__list());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Strings_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Strings_template temp = new Strings_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Strings.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Strings valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Strings.");
			}
			final Strings ret_val = new Strings();
			if (str__list.isBound()) {
				ret_val.getstr__list().assign(str__list.valueOf());
			}
			return ret_val;
		}

		public Strings_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Strings.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Strings.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Strings_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Strings_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (str__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!str__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Strings other_value) {
			return match(other_value, false);
		}

		public boolean match(final Strings other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getstr__list().isBound()) {
					return false;
				}
				if(!str__list.match(other_value.getstr__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Strings) {
				return match((Strings)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" str_list := ");
				str__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Strings match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Strings) {
				log_match((Strings)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Strings.");
		}

		public void log_match(final Strings match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !str__list.match(match_value.constGetstr__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".str_list");
							str__list.log_match(match_value.constGetstr__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ str_list := ");
				str__list.log_match(match_value.constGetstr__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				str__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				str__list = new Strings_str__list_template();
				str__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Strings_template>(size);
				for (int i = 0; i < size; i++) {
					final Strings_template temp = new Strings_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Strings.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Strings has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstr__list().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("str_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstr__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Strings: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Strings");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.str__list.check_restriction(restriction, name == null ? "@TitanLoggerApi.Strings" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Strings" : name));
		}
	}
	public static void Strings_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Strings_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Strings_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Strings_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Setstate_state_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Setstate_state_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Setstate_state_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Setstate_state_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class PTC__exit extends Base_Type {
		private final TitanInteger compref; //Integer_Type
		private final TitanInteger pid; //Integer_Type
		private final TitanInteger statuscode; //Integer_Type

		public PTC__exit() {
			this.compref = new TitanInteger();
			this.pid = new TitanInteger();
			this.statuscode = new TitanInteger();
		}

		public PTC__exit(final TitanInteger compref, final TitanInteger pid, final TitanInteger statuscode ) {
			this.compref = new TitanInteger( compref );
			this.pid = new TitanInteger( pid );
			this.statuscode = new TitanInteger( statuscode );
		}

		public PTC__exit( final PTC__exit otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.PTC_exit.");
			}
			compref = new TitanInteger();
			pid = new TitanInteger();
			statuscode = new TitanInteger();
			assign( otherValue );
		}

		public PTC__exit assign(final PTC__exit otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.PTC_exit");
			}

			if (otherValue != this) {
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getpid().isBound() ) {
					this.pid.assign( otherValue.getpid() );
				} else {
					this.pid.cleanUp();
				}
				if ( otherValue.getstatuscode().isBound() ) {
					this.statuscode.assign( otherValue.getstatuscode() );
				} else {
					this.statuscode.cleanUp();
				}
			}

			return this;
		}

		@Override
		public PTC__exit assign(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit ) {
				return assign((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PTC_exit", otherValue));
		}

		public void cleanUp() {
			compref.cleanUp();
			pid.cleanUp();
			statuscode.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( compref.isBound() ) { return true; }
			if ( pid.isBound() ) { return true; }
			if ( statuscode.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !compref.isValue() ) { return false; }
			if ( !pid.isValue() ) { return false; }
			if ( !statuscode.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final PTC__exit otherValue) {
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.pid.operatorEquals( otherValue.pid ) ) { return false; }
			if ( !this.statuscode.operatorEquals( otherValue.statuscode ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit ) {
				return operatorEquals((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PTC_exit", otherValue));
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public TitanInteger getpid() {
			return pid;
		}

		public TitanInteger constGetpid() {
			return pid;
		}

		public TitanInteger getstatuscode() {
			return statuscode;
		}

		public TitanInteger constGetstatuscode() {
			return statuscode;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pid := ");
			pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" statuscode := ");
			statuscode.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.PTC_exit has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpid().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstatuscode().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("statuscode".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstatuscode().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.PTC_exit: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.PTC_exit");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (pid.isBound()) {
				pid.set_implicit_omit();
			}
			if (statuscode.isBound()) {
				statuscode.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			compref.encode_text(text_buf);
			pid.encode_text(text_buf);
			statuscode.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			compref.decode_text(text_buf);
			pid.decode_text(text_buf);
			statuscode.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class PTC__exit_template extends Base_Template {

		private TitanInteger_template compref; //Integer_Type
		private TitanInteger_template pid; //Integer_Type
		private TitanInteger_template statuscode; //Integer_Type
		//originally value_list/list_value
		private List<PTC__exit_template> list_value;

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.PTC_exit.");
			}
			return compref;
		}

		public TitanInteger_template getpid() {
			setSpecific();
			return pid;
		}

		public TitanInteger_template constGetpid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field pid of a non-specific template of type @TitanLoggerApi.PTC_exit.");
			}
			return pid;
		}

		public TitanInteger_template getstatuscode() {
			setSpecific();
			return statuscode;
		}

		public TitanInteger_template constGetstatuscode() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field statuscode of a non-specific template of type @TitanLoggerApi.PTC_exit.");
			}
			return statuscode;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				compref = new TitanInteger_template();
				pid = new TitanInteger_template();
				statuscode = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					compref.assign(template_sel.ANY_VALUE);
					pid.assign(template_sel.ANY_VALUE);
					statuscode.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public PTC__exit_template() {
			// do nothing
		}

		public PTC__exit_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public PTC__exit_template( final PTC__exit otherValue ) {
			copyValue(otherValue);
		}

		public PTC__exit_template( final PTC__exit_template otherValue ) {
			copyTemplate( otherValue );
		}

		public PTC__exit_template( final Optional<PTC__exit> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.PTC_exit from an unbound optional field.");
			}
		}

		//originally operator=
		public PTC__exit_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public PTC__exit_template assign( final PTC__exit other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public PTC__exit_template assign( final PTC__exit_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public PTC__exit_template assign(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit) {
				return assign((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PTC__exit' can not be cast to {1}", otherValue));
		}

		@Override
		public PTC__exit_template assign(final Base_Template otherValue) {
			if (otherValue instanceof PTC__exit_template) {
				return assign((PTC__exit_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PTC__exit' can not be cast to {1}_template", otherValue));
		}

		public PTC__exit_template assign( final Optional<PTC__exit> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.PTC_exit.");
			}
			return this;
		}

		private void copyValue(final PTC__exit other_value) {
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getpid().isBound()) {
				getpid().assign(other_value.getpid());
			} else {
				getpid().cleanUp();
			}
			if (other_value.getstatuscode().isBound()) {
				getstatuscode().assign(other_value.getstatuscode());
			} else {
				getstatuscode().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final PTC__exit_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getpid().get_selection()) {
					getpid().cleanUp();
				} else {
					getpid().assign(other_value.getpid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getstatuscode().get_selection()) {
					getstatuscode().cleanUp();
				} else {
					getstatuscode().assign(other_value.getstatuscode());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<PTC__exit_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final PTC__exit_template temp = new PTC__exit_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.PTC_exit.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public PTC__exit valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.PTC_exit.");
			}
			final PTC__exit ret_val = new PTC__exit();
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (pid.isBound()) {
				ret_val.getpid().assign(pid.valueOf());
			}
			if (statuscode.isBound()) {
				ret_val.getstatuscode().assign(statuscode.valueOf());
			}
			return ret_val;
		}

		public PTC__exit_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.PTC_exit.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.PTC_exit.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.PTC_exit.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<PTC__exit_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new PTC__exit_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (pid.isBound()) {
				return true;
			}
			if (statuscode.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!pid.isValue()) {
				return false;
			}
			if (!statuscode.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final PTC__exit other_value) {
			return match(other_value, false);
		}

		public boolean match(final PTC__exit other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getpid().isBound()) {
					return false;
				}
				if(!pid.match(other_value.getpid(), legacy)) {
					return false;
				}
				if(!other_value.getstatuscode().isBound()) {
					return false;
				}
				if(!statuscode.match(other_value.getstatuscode(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof PTC__exit) {
				return match((PTC__exit)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type PTC__exit.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pid := ");
				pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" statuscode := ");
				statuscode.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final PTC__exit match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PTC__exit) {
				log_match((PTC__exit)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PTC_exit.");
		}

		public void log_match(final PTC__exit match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !pid.match(match_value.constGetpid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".pid");
							pid.log_match(match_value.constGetpid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !statuscode.match(match_value.constGetstatuscode(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".statuscode");
							statuscode.log_match(match_value.constGetstatuscode(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ pid := ");
				pid.log_match(match_value.constGetpid(), legacy);
				TTCN_Logger.log_event_str("{ statuscode := ");
				statuscode.log_match(match_value.constGetstatuscode(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				compref.encode_text(text_buf);
				pid.encode_text(text_buf);
				statuscode.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				pid = new TitanInteger_template();
				pid.decode_text(text_buf);
				statuscode = new TitanInteger_template();
				statuscode.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<PTC__exit_template>(size);
				for (int i = 0; i < size; i++) {
					final PTC__exit_template temp = new PTC__exit_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.PTC_exit has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpid().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getstatuscode().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("statuscode".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getstatuscode().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.PTC_exit: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.PTC_exit");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.PTC_exit" : name, legacy);
				this.pid.check_restriction(restriction, name == null ? "@TitanLoggerApi.PTC_exit" : name, legacy);
				this.statuscode.check_restriction(restriction, name == null ? "@TitanLoggerApi.PTC_exit" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.PTC_exit" : name));
		}
	}
	public static void PTC__exit_encoder(final PTC__exit input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PTC__exit_decoder( final TitanOctetString input_stream, final PTC__exit output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_executorMisc_encoder(final ExecutorUnqualified input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_executorMisc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_executorMisc_decoder( final TitanOctetString input_stream, final ExecutorUnqualified output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_executorMisc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Port__Misc_reason extends Base_Type {
		public enum enum_type {
			removing__unterminated__connection (0),
			removing__unterminated__mapping (1),
			port__was__cleared (2),
			local__connection__established (3),
			local__connection__terminated (4),
			port__is__waiting__for__connection__tcp (5),
			port__is__waiting__for__connection__unix (6),
			connection__established (7),
			destroying__unestablished__connection (8),
			terminating__connection (9),
			sending__termination__request__failed (10),
			termination__request__received (11),
			acknowledging__termination__request__failed (12),
			sending__would__block (13),
			connection__accepted (14),
			connection__reset__by__peer (15),
			connection__closed__by__peer (16),
			port__disconnected (17),
			port__was__mapped__to__system (18),
			port__was__unmapped__from__system (19),
			UNKNOWN_VALUE(20),
			UNBOUND_VALUE(21);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return removing__unterminated__connection;
				case 1:  return removing__unterminated__mapping;
				case 2:  return port__was__cleared;
				case 3:  return local__connection__established;
				case 4:  return local__connection__terminated;
				case 5:  return port__is__waiting__for__connection__tcp;
				case 6:  return port__is__waiting__for__connection__unix;
				case 7:  return connection__established;
				case 8:  return destroying__unestablished__connection;
				case 9:  return terminating__connection;
				case 10:  return sending__termination__request__failed;
				case 11:  return termination__request__received;
				case 12:  return acknowledging__termination__request__failed;
				case 13:  return sending__would__block;
				case 14:  return connection__accepted;
				case 15:  return connection__reset__by__peer;
				case 16:  return connection__closed__by__peer;
				case 17:  return port__disconnected;
				case 18:  return port__was__mapped__to__system;
				case 19:  return port__was__unmapped__from__system;
				case 20:  return UNKNOWN_VALUE;
				case 21:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Port__Misc_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Port__Misc_reason(final Port__Misc_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Port__Misc_reason(final Port__Misc_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Port__Misc_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__Misc_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Port__Misc_reason assign(final Port__Misc_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Port__Misc_reason assign(final Base_Type otherValue){
			if( otherValue instanceof Port__Misc_reason ) {
				return assign((Port__Misc_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Port__Misc_reason assign(final Port__Misc_reason.enum_type otherValue){
			return assign( new Port__Misc_reason(otherValue) );
		}

		//originally operator=
		public Port__Misc_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__Misc_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Port__Misc_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Port__Misc_reason) {
				return operatorEquals( (Port__Misc_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Port__Misc_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__Misc_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Port__Misc_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Port__Misc_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Port__Misc_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__Misc_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Port__Misc_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__Misc_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Port__Misc_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__Misc_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Port__Misc_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Port__Misc_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Port__Misc_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("removing__unterminated__connection".equals(strPar) || "removing_unterminated_connection".equals(strPar)) {
				return enum_type.removing__unterminated__connection;
			}
			if ("removing__unterminated__mapping".equals(strPar) || "removing_unterminated_mapping".equals(strPar)) {
				return enum_type.removing__unterminated__mapping;
			}
			if ("port__was__cleared".equals(strPar) || "port_was_cleared".equals(strPar)) {
				return enum_type.port__was__cleared;
			}
			if ("local__connection__established".equals(strPar) || "local_connection_established".equals(strPar)) {
				return enum_type.local__connection__established;
			}
			if ("local__connection__terminated".equals(strPar) || "local_connection_terminated".equals(strPar)) {
				return enum_type.local__connection__terminated;
			}
			if ("port__is__waiting__for__connection__tcp".equals(strPar) || "port_is_waiting_for_connection_tcp".equals(strPar)) {
				return enum_type.port__is__waiting__for__connection__tcp;
			}
			if ("port__is__waiting__for__connection__unix".equals(strPar) || "port_is_waiting_for_connection_unix".equals(strPar)) {
				return enum_type.port__is__waiting__for__connection__unix;
			}
			if ("connection__established".equals(strPar) || "connection_established".equals(strPar)) {
				return enum_type.connection__established;
			}
			if ("destroying__unestablished__connection".equals(strPar) || "destroying_unestablished_connection".equals(strPar)) {
				return enum_type.destroying__unestablished__connection;
			}
			if ("terminating__connection".equals(strPar) || "terminating_connection".equals(strPar)) {
				return enum_type.terminating__connection;
			}
			if ("sending__termination__request__failed".equals(strPar) || "sending_termination_request_failed".equals(strPar)) {
				return enum_type.sending__termination__request__failed;
			}
			if ("termination__request__received".equals(strPar) || "termination_request_received".equals(strPar)) {
				return enum_type.termination__request__received;
			}
			if ("acknowledging__termination__request__failed".equals(strPar) || "acknowledging_termination_request_failed".equals(strPar)) {
				return enum_type.acknowledging__termination__request__failed;
			}
			if ("sending__would__block".equals(strPar) || "sending_would_block".equals(strPar)) {
				return enum_type.sending__would__block;
			}
			if ("connection__accepted".equals(strPar) || "connection_accepted".equals(strPar)) {
				return enum_type.connection__accepted;
			}
			if ("connection__reset__by__peer".equals(strPar) || "connection_reset_by_peer".equals(strPar)) {
				return enum_type.connection__reset__by__peer;
			}
			if ("connection__closed__by__peer".equals(strPar) || "connection_closed_by_peer".equals(strPar)) {
				return enum_type.connection__closed__by__peer;
			}
			if ("port__disconnected".equals(strPar) || "port_disconnected".equals(strPar)) {
				return enum_type.port__disconnected;
			}
			if ("port__was__mapped__to__system".equals(strPar) || "port_was_mapped_to_system".equals(strPar)) {
				return enum_type.port__was__mapped__to__system;
			}
			if ("port__was__unmapped__from__system".equals(strPar) || "port_was_unmapped_from_system".equals(strPar)) {
				return enum_type.port__was__unmapped__from__system;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Port_Misc.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Port_Misc.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_Misc.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Misc.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Port__Misc_reason_template extends Base_Template {
		// single_value
		private Port__Misc_reason.enum_type single_value;
		// value_list part
		private ArrayList<Port__Misc_reason_template> value_list;

		private void copy_template(final Port__Misc_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Port__Misc_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Port__Misc_reason_template temp = new Port__Misc_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__Misc_reason.");
			}
		}

		public Port__Misc_reason_template() {
			// do nothing
		}

		public Port__Misc_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Port__Misc_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Port__Misc_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Port__Misc_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = Port__Misc_reason.enum_type.getValue(otherValue);
		}

		public Port__Misc_reason_template(final Port__Misc_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Port__Misc_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Port__Misc_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public Port__Misc_reason_template(final Port__Misc_reason_template otherValue) {
			copy_template(otherValue);
		}

		public Port__Misc_reason_template(final Port__Misc_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Port__Misc_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Port__Misc_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Port__Misc_reason_template assign(final int otherValue) {
			if (!Port__Misc_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__Misc_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Port__Misc_reason_template assign(final Port__Misc_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Port__Misc_reason_template assign(final Port__Misc_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Port__Misc_reason_template assign(final Port__Misc_reason otherValue){
			if (otherValue.enum_value == Port__Misc_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Port__Misc_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Port__Misc_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof Port__Misc_reason ) {
				return assign((Port__Misc_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Misc_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof Port__Misc_reason_template ) {
				return assign((Port__Misc_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Port__Misc_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Port__Misc_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__Misc_reason.");
			}
		}

		// originally match
		public boolean match(final Port__Misc_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Port__Misc_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Port__Misc_reason ) {
				return match((Port__Misc_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
		}

		public Port__Misc_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__Misc_reason.");
			}
			return new Port__Misc_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__Misc_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Port__Misc_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Port__Misc_reason_template());
			}
		}

		public Port__Misc_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__Misc_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Port__Misc_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Port__Misc_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Port__Misc_reason.enum2str(single_value), Port__Misc_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Misc_reason) {
				log_match((Port__Misc_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.reason.");
		}
		public void log_match(final Port__Misc_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Port__Misc_reason.enum_type enum_value = Port__Misc_reason.str_to_enum(param.get_enumerated());
				if (!Port__Misc_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Port_Misc.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Port_Misc.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_Misc.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Port__Misc_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Misc.reason.", temp));
				}
				single_value = Port__Misc_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Port__Misc_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final Port__Misc_reason_template temp = new Port__Misc_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_Misc.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Port_Misc.reason" : name));
		}
	}
	public static void Port__Misc_reason_encoder(final Port__Misc_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_reason_decoder( final TitanOctetString input_stream, final Port__Misc_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void QualifiedName_testcase__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(QualifiedName_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger QualifiedName_testcase__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(QualifiedName_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLog extends Base_Type {
		private final TitanLog_sequence__list sequence__list; //SequenceOf_Type

		public TitanLog() {
			this.sequence__list = new TitanLog_sequence__list();
		}

		public TitanLog(final TitanLog_sequence__list sequence__list ) {
			this.sequence__list = new TitanLog_sequence__list( sequence__list );
		}

		public TitanLog( final TitanLog otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLog.");
			}
			sequence__list = new TitanLog_sequence__list();
			assign( otherValue );
		}

		public TitanLog assign(final TitanLog otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLog");
			}

			if (otherValue != this) {
				if ( otherValue.getsequence__list().isBound() ) {
					this.sequence__list.assign( otherValue.getsequence__list() );
				} else {
					this.sequence__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLog assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog ) {
				return assign((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog", otherValue));
		}

		public void cleanUp() {
			sequence__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( sequence__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !sequence__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLog otherValue) {
			if ( !this.sequence__list.operatorEquals( otherValue.sequence__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog ) {
				return operatorEquals((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog", otherValue));
		}

		public TitanLog_sequence__list getsequence__list() {
			return sequence__list;
		}

		public TitanLog_sequence__list constGetsequence__list() {
			return sequence__list;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" sequence_list := ");
			sequence__list.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TitanLog has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsequence__list().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sequence_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsequence__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLog: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TitanLog");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (sequence__list.isBound()) {
				sequence__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			sequence__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			sequence__list.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLog_template extends Base_Template {

		private TitanLog_sequence__list_template sequence__list; //SequenceOf_Type
		//originally value_list/list_value
		private List<TitanLog_template> list_value;

		public TitanLog_sequence__list_template getsequence__list() {
			setSpecific();
			return sequence__list;
		}

		public TitanLog_sequence__list_template constGetsequence__list() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field sequence_list of a non-specific template of type @TitanLoggerApi.TitanLog.");
			}
			return sequence__list;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				sequence__list = new TitanLog_sequence__list_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					sequence__list.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TitanLog_template() {
			// do nothing
		}

		public TitanLog_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLog_template( final TitanLog otherValue ) {
			copyValue(otherValue);
		}

		public TitanLog_template( final TitanLog_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLog_template( final Optional<TitanLog> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog from an unbound optional field.");
			}
		}

		//originally operator=
		public TitanLog_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_template assign( final TitanLog other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_template assign( final TitanLog_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLog_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog) {
				return assign((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLog_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_template) {
				return assign((TitanLog_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog' can not be cast to {1}_template", otherValue));
		}

		public TitanLog_template assign( final Optional<TitanLog> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.");
			}
			return this;
		}

		private void copyValue(final TitanLog other_value) {
			if (other_value.getsequence__list().isBound()) {
				getsequence__list().assign(other_value.getsequence__list());
			} else {
				getsequence__list().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLog_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsequence__list().get_selection()) {
					getsequence__list().cleanUp();
				} else {
					getsequence__list().assign(other_value.getsequence__list());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLog_template temp = new TitanLog_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLog valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.");
			}
			final TitanLog ret_val = new TitanLog();
			if (sequence__list.isBound()) {
				ret_val.getsequence__list().assign(sequence__list.valueOf());
			}
			return ret_val;
		}

		public TitanLog_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLog.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLog_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLog_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (sequence__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!sequence__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLog other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLog other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getsequence__list().isBound()) {
					return false;
				}
				if(!sequence__list.match(other_value.getsequence__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLog) {
				return match((TitanLog)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" sequence_list := ");
				sequence__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLog match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog) {
				log_match((TitanLog)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.");
		}

		public void log_match(final TitanLog match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !sequence__list.match(match_value.constGetsequence__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sequence_list");
							sequence__list.log_match(match_value.constGetsequence__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ sequence_list := ");
				sequence__list.log_match(match_value.constGetsequence__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sequence__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sequence__list = new TitanLog_sequence__list_template();
				sequence__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_template temp = new TitanLog_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLog.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TitanLog has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsequence__list().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("sequence_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsequence__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLog: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TitanLog");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.sequence__list.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLog" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLog" : name));
		}
	}
	public static void TitanLog_encoder(final TitanLog input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_decoder( final TitanOctetString input_stream, final TitanLog output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ErrorEvent extends Base_Type {
		private final TitanCharString text; //CharString_Type

		public ErrorEvent() {
			this.text = new TitanCharString();
		}

		public ErrorEvent(final TitanCharString text ) {
			this.text = new TitanCharString( text );
		}

		public ErrorEvent( final ErrorEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ErrorEvent.");
			}
			text = new TitanCharString();
			assign( otherValue );
		}

		public ErrorEvent assign(final ErrorEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ErrorEvent");
			}

			if (otherValue != this) {
				if ( otherValue.gettext().isBound() ) {
					this.text.assign( otherValue.gettext() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ErrorEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent ) {
				return assign((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ErrorEvent", otherValue));
		}

		public void cleanUp() {
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ErrorEvent otherValue) {
			if ( !this.text.operatorEquals( otherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent ) {
				return operatorEquals((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ErrorEvent", otherValue));
		}

		public TitanCharString gettext() {
			return text;
		}

		public TitanCharString constGettext() {
			return text;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ErrorEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ErrorEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ErrorEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			text.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ErrorEvent_template extends Base_Template {

		private TitanCharString_template text; //CharString_Type
		//originally value_list/list_value
		private List<ErrorEvent_template> list_value;

		public TitanCharString_template gettext() {
			setSpecific();
			return text;
		}

		public TitanCharString_template constGettext() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.ErrorEvent.");
			}
			return text;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				text = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					text.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ErrorEvent_template() {
			// do nothing
		}

		public ErrorEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ErrorEvent_template( final ErrorEvent otherValue ) {
			copyValue(otherValue);
		}

		public ErrorEvent_template( final ErrorEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ErrorEvent_template( final Optional<ErrorEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ErrorEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public ErrorEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ErrorEvent_template assign( final ErrorEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ErrorEvent_template assign( final ErrorEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ErrorEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent) {
				return assign((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ErrorEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ErrorEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ErrorEvent_template) {
				return assign((ErrorEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ErrorEvent' can not be cast to {1}_template", otherValue));
		}

		public ErrorEvent_template assign( final Optional<ErrorEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ErrorEvent.");
			}
			return this;
		}

		private void copyValue(final ErrorEvent other_value) {
			if (other_value.gettext().isBound()) {
				gettext().assign(other_value.gettext());
			} else {
				gettext().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ErrorEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettext().get_selection()) {
					gettext().cleanUp();
				} else {
					gettext().assign(other_value.gettext());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ErrorEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ErrorEvent_template temp = new ErrorEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ErrorEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ErrorEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ErrorEvent.");
			}
			final ErrorEvent ret_val = new ErrorEvent();
			if (text.isBound()) {
				ret_val.gettext().assign(text.valueOf());
			}
			return ret_val;
		}

		public ErrorEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ErrorEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ErrorEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ErrorEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ErrorEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ErrorEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ErrorEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ErrorEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.gettext().isBound()) {
					return false;
				}
				if(!text.match(other_value.gettext(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ErrorEvent) {
				return match((ErrorEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ErrorEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ErrorEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ErrorEvent) {
				log_match((ErrorEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ErrorEvent.");
		}

		public void log_match(final ErrorEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !text.match(match_value.constGettext(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGettext(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGettext(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ErrorEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final ErrorEvent_template temp = new ErrorEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ErrorEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ErrorEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ErrorEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.text.check_restriction(restriction, name == null ? "@TitanLoggerApi.ErrorEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ErrorEvent" : name));
		}
	}
	public static void ErrorEvent_encoder(final ErrorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ErrorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ErrorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ErrorEvent_decoder( final TitanOctetString input_stream, final ErrorEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ErrorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ErrorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingProblemType_any__port_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingProblemType_any__port_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingProblemType_any__port_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingProblemType_any__port_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_portEvent_encoder(final PortEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_portEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_portEvent_decoder( final TitanOctetString input_stream, final PortEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_portEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__recv_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingDoneType_ptc_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingDoneType_ptc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingDoneType_ptc_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingDoneType_ptc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void VerdictType_toVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictType_toVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictType_toVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictType_toVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void VerdictType_verdictReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(VerdictType_verdictReason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger VerdictType_verdictReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(VerdictType_verdictReason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorEvent extends Base_Type {
		private final ExecutorEvent_choice choice; //TTCN3_Choice_Type

		public ExecutorEvent() {
			this.choice = new ExecutorEvent_choice();
		}

		public ExecutorEvent(final ExecutorEvent_choice choice ) {
			this.choice = new ExecutorEvent_choice( choice );
		}

		public ExecutorEvent( final ExecutorEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorEvent.");
			}
			choice = new ExecutorEvent_choice();
			assign( otherValue );
		}

		public ExecutorEvent assign(final ExecutorEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent ) {
				return assign((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent ) {
				return operatorEquals((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorEvent", otherValue));
		}

		public ExecutorEvent_choice getchoice() {
			return choice;
		}

		public ExecutorEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutorEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutorEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorEvent_template extends Base_Template {

		private ExecutorEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<ExecutorEvent_template> list_value;

		public ExecutorEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public ExecutorEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.ExecutorEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new ExecutorEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ExecutorEvent_template() {
			// do nothing
		}

		public ExecutorEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutorEvent_template( final ExecutorEvent otherValue ) {
			copyValue(otherValue);
		}

		public ExecutorEvent_template( final ExecutorEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutorEvent_template( final Optional<ExecutorEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutorEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorEvent_template assign( final ExecutorEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutorEvent_template assign( final ExecutorEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutorEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent) {
				return assign((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorEvent_template) {
				return assign((ExecutorEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorEvent' can not be cast to {1}_template", otherValue));
		}

		public ExecutorEvent_template assign( final Optional<ExecutorEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorEvent.");
			}
			return this;
		}

		private void copyValue(final ExecutorEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutorEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutorEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutorEvent_template temp = new ExecutorEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorEvent.");
			}
			final ExecutorEvent ret_val = new ExecutorEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public ExecutorEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorEvent) {
				return match((ExecutorEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorEvent) {
				log_match((ExecutorEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.");
		}

		public void log_match(final ExecutorEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new ExecutorEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorEvent_template temp = new ExecutorEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutorEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutorEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorEvent" : name));
		}
	}
	public static void ExecutorEvent_encoder(final ExecutorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_decoder( final TitanOctetString input_stream, final ExecutorEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_passPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_passPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_passPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_passPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_extcommandStart_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_extcommandStart_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_extcommandStart_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_extcommandStart_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_compname_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_compname_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_compname_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_compname_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Parallel extends Base_Type {
		private final Parallel_reason reason; //TTCN3_Enumerated_Type
		private final TitanBoolean alive__; //Boolean_Type
		private final TitanCharString function__name; //CharString_Type
		private final TitanInteger src__compref; //Integer_Type
		private final TitanCharString src__port; //CharString_Type
		private final TitanInteger dst__compref; //Integer_Type
		private final TitanCharString dst__port; //CharString_Type

		public Parallel() {
			this.reason = new Parallel_reason();
			this.alive__ = new TitanBoolean();
			this.function__name = new TitanCharString();
			this.src__compref = new TitanInteger();
			this.src__port = new TitanCharString();
			this.dst__compref = new TitanInteger();
			this.dst__port = new TitanCharString();
		}

		public Parallel(final Parallel_reason reason, final TitanBoolean alive__, final TitanCharString function__name, final TitanInteger src__compref, final TitanCharString src__port, final TitanInteger dst__compref, final TitanCharString dst__port ) {
			this.reason = new Parallel_reason( reason );
			this.alive__ = new TitanBoolean( alive__ );
			this.function__name = new TitanCharString( function__name );
			this.src__compref = new TitanInteger( src__compref );
			this.src__port = new TitanCharString( src__port );
			this.dst__compref = new TitanInteger( dst__compref );
			this.dst__port = new TitanCharString( dst__port );
		}

		public Parallel( final Parallel otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Parallel.");
			}
			reason = new Parallel_reason();
			alive__ = new TitanBoolean();
			function__name = new TitanCharString();
			src__compref = new TitanInteger();
			src__port = new TitanCharString();
			dst__compref = new TitanInteger();
			dst__port = new TitanCharString();
			assign( otherValue );
		}

		public Parallel assign(final Parallel otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Parallel");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getalive__().isBound() ) {
					this.alive__.assign( otherValue.getalive__() );
				} else {
					this.alive__.cleanUp();
				}
				if ( otherValue.getfunction__name().isBound() ) {
					this.function__name.assign( otherValue.getfunction__name() );
				} else {
					this.function__name.cleanUp();
				}
				if ( otherValue.getsrc__compref().isBound() ) {
					this.src__compref.assign( otherValue.getsrc__compref() );
				} else {
					this.src__compref.cleanUp();
				}
				if ( otherValue.getsrc__port().isBound() ) {
					this.src__port.assign( otherValue.getsrc__port() );
				} else {
					this.src__port.cleanUp();
				}
				if ( otherValue.getdst__compref().isBound() ) {
					this.dst__compref.assign( otherValue.getdst__compref() );
				} else {
					this.dst__compref.cleanUp();
				}
				if ( otherValue.getdst__port().isBound() ) {
					this.dst__port.assign( otherValue.getdst__port() );
				} else {
					this.dst__port.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Parallel assign(final Base_Type otherValue) {
			if (otherValue instanceof Parallel ) {
				return assign((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Parallel", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			alive__.cleanUp();
			function__name.cleanUp();
			src__compref.cleanUp();
			src__port.cleanUp();
			dst__compref.cleanUp();
			dst__port.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( alive__.isBound() ) { return true; }
			if ( function__name.isBound() ) { return true; }
			if ( src__compref.isBound() ) { return true; }
			if ( src__port.isBound() ) { return true; }
			if ( dst__compref.isBound() ) { return true; }
			if ( dst__port.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !alive__.isValue() ) { return false; }
			if ( !function__name.isValue() ) { return false; }
			if ( !src__compref.isValue() ) { return false; }
			if ( !src__port.isValue() ) { return false; }
			if ( !dst__compref.isValue() ) { return false; }
			if ( !dst__port.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Parallel otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.alive__.operatorEquals( otherValue.alive__ ) ) { return false; }
			if ( !this.function__name.operatorEquals( otherValue.function__name ) ) { return false; }
			if ( !this.src__compref.operatorEquals( otherValue.src__compref ) ) { return false; }
			if ( !this.src__port.operatorEquals( otherValue.src__port ) ) { return false; }
			if ( !this.dst__compref.operatorEquals( otherValue.dst__compref ) ) { return false; }
			if ( !this.dst__port.operatorEquals( otherValue.dst__port ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Parallel ) {
				return operatorEquals((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Parallel", otherValue));
		}

		public Parallel_reason getreason() {
			return reason;
		}

		public Parallel_reason constGetreason() {
			return reason;
		}

		public TitanBoolean getalive__() {
			return alive__;
		}

		public TitanBoolean constGetalive__() {
			return alive__;
		}

		public TitanCharString getfunction__name() {
			return function__name;
		}

		public TitanCharString constGetfunction__name() {
			return function__name;
		}

		public TitanInteger getsrc__compref() {
			return src__compref;
		}

		public TitanInteger constGetsrc__compref() {
			return src__compref;
		}

		public TitanCharString getsrc__port() {
			return src__port;
		}

		public TitanCharString constGetsrc__port() {
			return src__port;
		}

		public TitanInteger getdst__compref() {
			return dst__compref;
		}

		public TitanInteger constGetdst__compref() {
			return dst__compref;
		}

		public TitanCharString getdst__port() {
			return dst__port;
		}

		public TitanCharString constGetdst__port() {
			return dst__port;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(7);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" alive_ := ");
			alive__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" function_name := ");
			function__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" src_compref := ");
			src__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" src_port := ");
			src__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dst_compref := ");
			dst__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dst_port := ");
			dst__port.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Parallel has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getalive__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfunction__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrc__compref().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrc__port().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdst__compref().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdst__port().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("alive_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getalive__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("function_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfunction__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("src_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrc__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("src_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrc__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dst_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdst__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dst_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdst__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Parallel: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Parallel");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (alive__.isBound()) {
				alive__.set_implicit_omit();
			}
			if (function__name.isBound()) {
				function__name.set_implicit_omit();
			}
			if (src__compref.isBound()) {
				src__compref.set_implicit_omit();
			}
			if (src__port.isBound()) {
				src__port.set_implicit_omit();
			}
			if (dst__compref.isBound()) {
				dst__compref.set_implicit_omit();
			}
			if (dst__port.isBound()) {
				dst__port.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			alive__.encode_text(text_buf);
			function__name.encode_text(text_buf);
			src__compref.encode_text(text_buf);
			src__port.encode_text(text_buf);
			dst__compref.encode_text(text_buf);
			dst__port.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			alive__.decode_text(text_buf);
			function__name.decode_text(text_buf);
			src__compref.decode_text(text_buf);
			src__port.decode_text(text_buf);
			dst__compref.decode_text(text_buf);
			dst__port.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Parallel_template extends Base_Template {

		private Parallel_reason_template reason; //TTCN3_Enumerated_Type
		private TitanBoolean_template alive__; //Boolean_Type
		private TitanCharString_template function__name; //CharString_Type
		private TitanInteger_template src__compref; //Integer_Type
		private TitanCharString_template src__port; //CharString_Type
		private TitanInteger_template dst__compref; //Integer_Type
		private TitanCharString_template dst__port; //CharString_Type
		//originally value_list/list_value
		private List<Parallel_template> list_value;

		public Parallel_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public Parallel_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return reason;
		}

		public TitanBoolean_template getalive__() {
			setSpecific();
			return alive__;
		}

		public TitanBoolean_template constGetalive__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field alive_ of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return alive__;
		}

		public TitanCharString_template getfunction__name() {
			setSpecific();
			return function__name;
		}

		public TitanCharString_template constGetfunction__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field function_name of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return function__name;
		}

		public TitanInteger_template getsrc__compref() {
			setSpecific();
			return src__compref;
		}

		public TitanInteger_template constGetsrc__compref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field src_compref of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return src__compref;
		}

		public TitanCharString_template getsrc__port() {
			setSpecific();
			return src__port;
		}

		public TitanCharString_template constGetsrc__port() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field src_port of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return src__port;
		}

		public TitanInteger_template getdst__compref() {
			setSpecific();
			return dst__compref;
		}

		public TitanInteger_template constGetdst__compref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dst_compref of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return dst__compref;
		}

		public TitanCharString_template getdst__port() {
			setSpecific();
			return dst__port;
		}

		public TitanCharString_template constGetdst__port() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field dst_port of a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			return dst__port;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new Parallel_reason_template();
				alive__ = new TitanBoolean_template();
				function__name = new TitanCharString_template();
				src__compref = new TitanInteger_template();
				src__port = new TitanCharString_template();
				dst__compref = new TitanInteger_template();
				dst__port = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					alive__.assign(template_sel.ANY_VALUE);
					function__name.assign(template_sel.ANY_VALUE);
					src__compref.assign(template_sel.ANY_VALUE);
					src__port.assign(template_sel.ANY_VALUE);
					dst__compref.assign(template_sel.ANY_VALUE);
					dst__port.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Parallel_template() {
			// do nothing
		}

		public Parallel_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Parallel_template( final Parallel otherValue ) {
			copyValue(otherValue);
		}

		public Parallel_template( final Parallel_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Parallel_template( final Optional<Parallel> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Parallel from an unbound optional field.");
			}
		}

		//originally operator=
		public Parallel_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Parallel_template assign( final Parallel other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Parallel_template assign( final Parallel_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Parallel_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Parallel) {
				return assign((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel' can not be cast to {1}", otherValue));
		}

		@Override
		public Parallel_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Parallel_template) {
				return assign((Parallel_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel' can not be cast to {1}_template", otherValue));
		}

		public Parallel_template assign( final Optional<Parallel> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Parallel.");
			}
			return this;
		}

		private void copyValue(final Parallel other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getalive__().isBound()) {
				getalive__().assign(other_value.getalive__());
			} else {
				getalive__().cleanUp();
			}
			if (other_value.getfunction__name().isBound()) {
				getfunction__name().assign(other_value.getfunction__name());
			} else {
				getfunction__name().cleanUp();
			}
			if (other_value.getsrc__compref().isBound()) {
				getsrc__compref().assign(other_value.getsrc__compref());
			} else {
				getsrc__compref().cleanUp();
			}
			if (other_value.getsrc__port().isBound()) {
				getsrc__port().assign(other_value.getsrc__port());
			} else {
				getsrc__port().cleanUp();
			}
			if (other_value.getdst__compref().isBound()) {
				getdst__compref().assign(other_value.getdst__compref());
			} else {
				getdst__compref().cleanUp();
			}
			if (other_value.getdst__port().isBound()) {
				getdst__port().assign(other_value.getdst__port());
			} else {
				getdst__port().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Parallel_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getalive__().get_selection()) {
					getalive__().cleanUp();
				} else {
					getalive__().assign(other_value.getalive__());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfunction__name().get_selection()) {
					getfunction__name().cleanUp();
				} else {
					getfunction__name().assign(other_value.getfunction__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsrc__compref().get_selection()) {
					getsrc__compref().cleanUp();
				} else {
					getsrc__compref().assign(other_value.getsrc__compref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getsrc__port().get_selection()) {
					getsrc__port().cleanUp();
				} else {
					getsrc__port().assign(other_value.getsrc__port());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getdst__compref().get_selection()) {
					getdst__compref().cleanUp();
				} else {
					getdst__compref().assign(other_value.getdst__compref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getdst__port().get_selection()) {
					getdst__port().cleanUp();
				} else {
					getdst__port().assign(other_value.getdst__port());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Parallel_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Parallel_template temp = new Parallel_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Parallel.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Parallel valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			final Parallel ret_val = new Parallel();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (alive__.isBound()) {
				ret_val.getalive__().assign(alive__.valueOf());
			}
			if (function__name.isBound()) {
				ret_val.getfunction__name().assign(function__name.valueOf());
			}
			if (src__compref.isBound()) {
				ret_val.getsrc__compref().assign(src__compref.valueOf());
			}
			if (src__port.isBound()) {
				ret_val.getsrc__port().assign(src__port.valueOf());
			}
			if (dst__compref.isBound()) {
				ret_val.getdst__compref().assign(dst__compref.valueOf());
			}
			if (dst__port.isBound()) {
				ret_val.getdst__port().assign(dst__port.valueOf());
			}
			return ret_val;
		}

		public Parallel_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Parallel.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Parallel.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Parallel.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Parallel_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Parallel_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (alive__.isBound()) {
				return true;
			}
			if (function__name.isBound()) {
				return true;
			}
			if (src__compref.isBound()) {
				return true;
			}
			if (src__port.isBound()) {
				return true;
			}
			if (dst__compref.isBound()) {
				return true;
			}
			if (dst__port.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!alive__.isValue()) {
				return false;
			}
			if (!function__name.isValue()) {
				return false;
			}
			if (!src__compref.isValue()) {
				return false;
			}
			if (!src__port.isValue()) {
				return false;
			}
			if (!dst__compref.isValue()) {
				return false;
			}
			if (!dst__port.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Parallel other_value) {
			return match(other_value, false);
		}

		public boolean match(final Parallel other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getalive__().isBound()) {
					return false;
				}
				if(!alive__.match(other_value.getalive__(), legacy)) {
					return false;
				}
				if(!other_value.getfunction__name().isBound()) {
					return false;
				}
				if(!function__name.match(other_value.getfunction__name(), legacy)) {
					return false;
				}
				if(!other_value.getsrc__compref().isBound()) {
					return false;
				}
				if(!src__compref.match(other_value.getsrc__compref(), legacy)) {
					return false;
				}
				if(!other_value.getsrc__port().isBound()) {
					return false;
				}
				if(!src__port.match(other_value.getsrc__port(), legacy)) {
					return false;
				}
				if(!other_value.getdst__compref().isBound()) {
					return false;
				}
				if(!dst__compref.match(other_value.getdst__compref(), legacy)) {
					return false;
				}
				if(!other_value.getdst__port().isBound()) {
					return false;
				}
				if(!dst__port.match(other_value.getdst__port(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Parallel) {
				return match((Parallel)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Parallel.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(7);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" alive_ := ");
				alive__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" function_name := ");
				function__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" src_compref := ");
				src__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" src_port := ");
				src__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dst_compref := ");
				dst__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dst_port := ");
				dst__port.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Parallel match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Parallel) {
				log_match((Parallel)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.");
		}

		public void log_match(final Parallel match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !alive__.match(match_value.constGetalive__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".alive_");
							alive__.log_match(match_value.constGetalive__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !function__name.match(match_value.constGetfunction__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".function_name");
							function__name.log_match(match_value.constGetfunction__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !src__compref.match(match_value.constGetsrc__compref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".src_compref");
							src__compref.log_match(match_value.constGetsrc__compref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !src__port.match(match_value.constGetsrc__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".src_port");
							src__port.log_match(match_value.constGetsrc__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dst__compref.match(match_value.constGetdst__compref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dst_compref");
							dst__compref.log_match(match_value.constGetdst__compref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dst__port.match(match_value.constGetdst__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dst_port");
							dst__port.log_match(match_value.constGetdst__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ alive_ := ");
				alive__.log_match(match_value.constGetalive__(), legacy);
				TTCN_Logger.log_event_str("{ function_name := ");
				function__name.log_match(match_value.constGetfunction__name(), legacy);
				TTCN_Logger.log_event_str("{ src_compref := ");
				src__compref.log_match(match_value.constGetsrc__compref(), legacy);
				TTCN_Logger.log_event_str("{ src_port := ");
				src__port.log_match(match_value.constGetsrc__port(), legacy);
				TTCN_Logger.log_event_str("{ dst_compref := ");
				dst__compref.log_match(match_value.constGetdst__compref(), legacy);
				TTCN_Logger.log_event_str("{ dst_port := ");
				dst__port.log_match(match_value.constGetdst__port(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				alive__.encode_text(text_buf);
				function__name.encode_text(text_buf);
				src__compref.encode_text(text_buf);
				src__port.encode_text(text_buf);
				dst__compref.encode_text(text_buf);
				dst__port.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new Parallel_reason_template();
				reason.decode_text(text_buf);
				alive__ = new TitanBoolean_template();
				alive__.decode_text(text_buf);
				function__name = new TitanCharString_template();
				function__name.decode_text(text_buf);
				src__compref = new TitanInteger_template();
				src__compref.decode_text(text_buf);
				src__port = new TitanCharString_template();
				src__port.decode_text(text_buf);
				dst__compref = new TitanInteger_template();
				dst__compref.decode_text(text_buf);
				dst__port = new TitanCharString_template();
				dst__port.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Parallel_template>(size);
				for (int i = 0; i < size; i++) {
					final Parallel_template temp = new Parallel_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Parallel.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 7) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Parallel has 7 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getalive__().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfunction__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrc__compref().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getsrc__port().set_param(param.get_elem(4));
				}
				if (param.get_size() > 5 && param.get_elem(5).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdst__compref().set_param(param.get_elem(5));
				}
				if (param.get_size() > 6 && param.get_elem(6).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getdst__port().set_param(param.get_elem(6));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("alive_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getalive__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("function_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfunction__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("src_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrc__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("src_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getsrc__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dst_compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdst__compref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("dst_port".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getdst__port().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Parallel: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Parallel");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.alive__.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.function__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.src__compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.src__port.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.dst__compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				this.dst__port.check_restriction(restriction, name == null ? "@TitanLoggerApi.Parallel" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Parallel" : name));
		}
	}
	public static void Parallel_encoder(final Parallel input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Parallel_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Parallel_decoder( final TitanOctetString input_stream, final Parallel output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Parallel_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorRuntime extends Base_Type {
		private final ExecutorRuntime_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanCharString> module__name; //CharString_Type
		private final Optional<TitanCharString> testcase__name; //CharString_Type
		private final Optional<TitanInteger> pid; //Integer_Type
		private final Optional<TitanInteger> fd__setsize; //Integer_Type

		public ExecutorRuntime() {
			this.reason = new ExecutorRuntime_reason();
			this.module__name = new Optional<TitanCharString>(TitanCharString.class);
			this.testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			this.pid = new Optional<TitanInteger>(TitanInteger.class);
			this.fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
		}

		public ExecutorRuntime(final ExecutorRuntime_reason reason, final Optional<TitanCharString> module__name, final Optional<TitanCharString> testcase__name, final Optional<TitanInteger> pid, final Optional<TitanInteger> fd__setsize ) {
			this.reason = new ExecutorRuntime_reason( reason );
			this.module__name = new Optional<TitanCharString>(TitanCharString.class);
			this.module__name.assign( module__name );
			this.testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			this.testcase__name.assign( testcase__name );
			this.pid = new Optional<TitanInteger>(TitanInteger.class);
			this.pid.assign( pid );
			this.fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
			this.fd__setsize.assign( fd__setsize );
		}

		public ExecutorRuntime( final ExecutorRuntime otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorRuntime.");
			}
			reason = new ExecutorRuntime_reason();
			module__name = new Optional<TitanCharString>(TitanCharString.class);
			testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			pid = new Optional<TitanInteger>(TitanInteger.class);
			fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
			assign( otherValue );
		}

		public ExecutorRuntime assign(final ExecutorRuntime otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorRuntime");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getmodule__name().isBound() ) {
					this.module__name.assign( otherValue.getmodule__name() );
				} else {
					this.module__name.cleanUp();
				}
				if ( otherValue.gettestcase__name().isBound() ) {
					this.testcase__name.assign( otherValue.gettestcase__name() );
				} else {
					this.testcase__name.cleanUp();
				}
				if ( otherValue.getpid().isBound() ) {
					this.pid.assign( otherValue.getpid() );
				} else {
					this.pid.cleanUp();
				}
				if ( otherValue.getfd__setsize().isBound() ) {
					this.fd__setsize.assign( otherValue.getfd__setsize() );
				} else {
					this.fd__setsize.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorRuntime assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime ) {
				return assign((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorRuntime", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			module__name.cleanUp();
			testcase__name.cleanUp();
			pid.cleanUp();
			fd__setsize.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(module__name.get_selection()) || module__name.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(testcase__name.get_selection()) || testcase__name.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(pid.get_selection()) || pid.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(fd__setsize.get_selection()) || fd__setsize.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(module__name.get_selection()) && !module__name.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(testcase__name.get_selection()) && !testcase__name.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(pid.get_selection()) && !pid.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(fd__setsize.get_selection()) && !fd__setsize.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorRuntime otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.module__name.operatorEquals( otherValue.module__name ) ) { return false; }
			if ( !this.testcase__name.operatorEquals( otherValue.testcase__name ) ) { return false; }
			if ( !this.pid.operatorEquals( otherValue.pid ) ) { return false; }
			if ( !this.fd__setsize.operatorEquals( otherValue.fd__setsize ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime ) {
				return operatorEquals((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorRuntime", otherValue));
		}

		public ExecutorRuntime_reason getreason() {
			return reason;
		}

		public ExecutorRuntime_reason constGetreason() {
			return reason;
		}

		public Optional<TitanCharString> getmodule__name() {
			return module__name;
		}

		public Optional<TitanCharString> constGetmodule__name() {
			return module__name;
		}

		public Optional<TitanCharString> gettestcase__name() {
			return testcase__name;
		}

		public Optional<TitanCharString> constGettestcase__name() {
			return testcase__name;
		}

		public Optional<TitanInteger> getpid() {
			return pid;
		}

		public Optional<TitanInteger> constGetpid() {
			return pid;
		}

		public Optional<TitanInteger> getfd__setsize() {
			return fd__setsize;
		}

		public Optional<TitanInteger> constGetfd__setsize() {
			return fd__setsize;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (module__name.isPresent()) {
				sizeof++;
			}
			if (testcase__name.isPresent()) {
				sizeof++;
			}
			if (pid.isPresent()) {
				sizeof++;
			}
			if (fd__setsize.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" module_name := ");
			module__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" testcase_name := ");
			testcase__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pid := ");
			pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" fd_setsize := ");
			fd__setsize.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutorRuntime has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettestcase__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpid().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfd__setsize().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("testcase_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettestcase__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fd_setsize".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfd__setsize().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorRuntime: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutorRuntime");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (module__name.isBound()) {
				module__name.set_implicit_omit();
			} else {
				module__name.assign(template_sel.OMIT_VALUE);
			}
			if (testcase__name.isBound()) {
				testcase__name.set_implicit_omit();
			} else {
				testcase__name.assign(template_sel.OMIT_VALUE);
			}
			if (pid.isBound()) {
				pid.set_implicit_omit();
			} else {
				pid.assign(template_sel.OMIT_VALUE);
			}
			if (fd__setsize.isBound()) {
				fd__setsize.set_implicit_omit();
			} else {
				fd__setsize.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			module__name.encode_text(text_buf);
			testcase__name.encode_text(text_buf);
			pid.encode_text(text_buf);
			fd__setsize.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			module__name.decode_text(text_buf);
			testcase__name.decode_text(text_buf);
			pid.decode_text(text_buf);
			fd__setsize.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorRuntime_template extends Base_Template {

		private ExecutorRuntime_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template module__name; //CharString_Type
		private TitanCharString_template testcase__name; //CharString_Type
		private TitanInteger_template pid; //Integer_Type
		private TitanInteger_template fd__setsize; //Integer_Type
		//originally value_list/list_value
		private List<ExecutorRuntime_template> list_value;

		public ExecutorRuntime_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public ExecutorRuntime_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return reason;
		}

		public TitanCharString_template getmodule__name() {
			setSpecific();
			return module__name;
		}

		public TitanCharString_template constGetmodule__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field module_name of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return module__name;
		}

		public TitanCharString_template gettestcase__name() {
			setSpecific();
			return testcase__name;
		}

		public TitanCharString_template constGettestcase__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field testcase_name of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return testcase__name;
		}

		public TitanInteger_template getpid() {
			setSpecific();
			return pid;
		}

		public TitanInteger_template constGetpid() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field pid of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return pid;
		}

		public TitanInteger_template getfd__setsize() {
			setSpecific();
			return fd__setsize;
		}

		public TitanInteger_template constGetfd__setsize() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field fd_setsize of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return fd__setsize;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new ExecutorRuntime_reason_template();
				module__name = new TitanCharString_template();
				testcase__name = new TitanCharString_template();
				pid = new TitanInteger_template();
				fd__setsize = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					module__name.assign(template_sel.ANY_OR_OMIT);
					testcase__name.assign(template_sel.ANY_OR_OMIT);
					pid.assign(template_sel.ANY_OR_OMIT);
					fd__setsize.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public ExecutorRuntime_template() {
			// do nothing
		}

		public ExecutorRuntime_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutorRuntime_template( final ExecutorRuntime otherValue ) {
			copyValue(otherValue);
		}

		public ExecutorRuntime_template( final ExecutorRuntime_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutorRuntime_template( final Optional<ExecutorRuntime> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorRuntime from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutorRuntime_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorRuntime_template assign( final ExecutorRuntime other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutorRuntime_template assign( final ExecutorRuntime_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutorRuntime_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime) {
				return assign((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorRuntime_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorRuntime_template) {
				return assign((ExecutorRuntime_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime' can not be cast to {1}_template", otherValue));
		}

		public ExecutorRuntime_template assign( final Optional<ExecutorRuntime> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return this;
		}

		private void copyValue(final ExecutorRuntime other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getmodule__name().isBound()) {
				if (other_value.getmodule__name().isPresent()) {
					getmodule__name().assign(other_value.getmodule__name().get());
				} else {
					getmodule__name().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getmodule__name().cleanUp();
			}
			if (other_value.gettestcase__name().isBound()) {
				if (other_value.gettestcase__name().isPresent()) {
					gettestcase__name().assign(other_value.gettestcase__name().get());
				} else {
					gettestcase__name().assign(template_sel.OMIT_VALUE);
				}
			} else {
				gettestcase__name().cleanUp();
			}
			if (other_value.getpid().isBound()) {
				if (other_value.getpid().isPresent()) {
					getpid().assign(other_value.getpid().get());
				} else {
					getpid().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getpid().cleanUp();
			}
			if (other_value.getfd__setsize().isBound()) {
				if (other_value.getfd__setsize().isPresent()) {
					getfd__setsize().assign(other_value.getfd__setsize().get());
				} else {
					getfd__setsize().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getfd__setsize().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutorRuntime_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getmodule__name().get_selection()) {
					getmodule__name().cleanUp();
				} else {
					getmodule__name().assign(other_value.getmodule__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettestcase__name().get_selection()) {
					gettestcase__name().cleanUp();
				} else {
					gettestcase__name().assign(other_value.gettestcase__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getpid().get_selection()) {
					getpid().cleanUp();
				} else {
					getpid().assign(other_value.getpid());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfd__setsize().get_selection()) {
					getfd__setsize().cleanUp();
				} else {
					getfd__setsize().assign(other_value.getfd__setsize());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutorRuntime_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutorRuntime_template temp = new ExecutorRuntime_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorRuntime valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			final ExecutorRuntime ret_val = new ExecutorRuntime();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (module__name.isOmit()) {
				ret_val.getmodule__name().assign(template_sel.OMIT_VALUE);
			} else if (module__name.isBound()) {
				ret_val.getmodule__name().assign(module__name.valueOf());
			}
			if (testcase__name.isOmit()) {
				ret_val.gettestcase__name().assign(template_sel.OMIT_VALUE);
			} else if (testcase__name.isBound()) {
				ret_val.gettestcase__name().assign(testcase__name.valueOf());
			}
			if (pid.isOmit()) {
				ret_val.getpid().assign(template_sel.OMIT_VALUE);
			} else if (pid.isBound()) {
				ret_val.getpid().assign(pid.valueOf());
			}
			if (fd__setsize.isOmit()) {
				ret_val.getfd__setsize().assign(template_sel.OMIT_VALUE);
			} else if (fd__setsize.isBound()) {
				ret_val.getfd__setsize().assign(fd__setsize.valueOf());
			}
			return ret_val;
		}

		public ExecutorRuntime_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorRuntime_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorRuntime_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (module__name.isOmit() || module__name.isBound()) {
				return true;
			}
			if (testcase__name.isOmit() || testcase__name.isBound()) {
				return true;
			}
			if (pid.isOmit() || pid.isBound()) {
				return true;
			}
			if (fd__setsize.isOmit() || fd__setsize.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!module__name.isOmit() && !module__name.isValue()) {
				return false;
			}
			if (!testcase__name.isOmit() && !testcase__name.isValue()) {
				return false;
			}
			if (!pid.isOmit() && !pid.isValue()) {
				return false;
			}
			if (!fd__setsize.isOmit() && !fd__setsize.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorRuntime other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorRuntime other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getmodule__name().isBound()) {
					return false;
				}
				if((other_value.getmodule__name().isPresent() ? !module__name.match(other_value.getmodule__name().get(), legacy) : !module__name.match_omit(legacy))) {
					return false;
				}
				if(!other_value.gettestcase__name().isBound()) {
					return false;
				}
				if((other_value.gettestcase__name().isPresent() ? !testcase__name.match(other_value.gettestcase__name().get(), legacy) : !testcase__name.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getpid().isBound()) {
					return false;
				}
				if((other_value.getpid().isPresent() ? !pid.match(other_value.getpid().get(), legacy) : !pid.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getfd__setsize().isBound()) {
					return false;
				}
				if((other_value.getfd__setsize().isPresent() ? !fd__setsize.match(other_value.getfd__setsize().get(), legacy) : !fd__setsize.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorRuntime) {
				return match((ExecutorRuntime)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorRuntime.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (module__name.isPresent()) {
					sizeof++;
				}
				if (testcase__name.isPresent()) {
					sizeof++;
				}
				if (pid.isPresent()) {
					sizeof++;
				}
				if (fd__setsize.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" module_name := ");
				module__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" testcase_name := ");
				testcase__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pid := ");
				pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" fd_setsize := ");
				fd__setsize.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorRuntime match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorRuntime) {
				log_match((ExecutorRuntime)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.");
		}

		public void log_match(final ExecutorRuntime match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetmodule__name().isPresent()) {
							if( !module__name.match(match_value.constGetmodule__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".module_name");
								module__name.log_match(match_value.constGetmodule__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!module__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".module_name := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								module__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGettestcase__name().isPresent()) {
							if( !testcase__name.match(match_value.constGettestcase__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".testcase_name");
								testcase__name.log_match(match_value.constGettestcase__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!testcase__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".testcase_name := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								testcase__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetpid().isPresent()) {
							if( !pid.match(match_value.constGetpid().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".pid");
								pid.log_match(match_value.constGetpid().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!pid.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".pid := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								pid.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetfd__setsize().isPresent()) {
							if( !fd__setsize.match(match_value.constGetfd__setsize().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".fd_setsize");
								fd__setsize.log_match(match_value.constGetfd__setsize().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!fd__setsize.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".fd_setsize := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								fd__setsize.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ module_name := ");
				module__name.log_match(match_value.constGetmodule__name(), legacy);
				TTCN_Logger.log_event_str("{ testcase_name := ");
				testcase__name.log_match(match_value.constGettestcase__name(), legacy);
				TTCN_Logger.log_event_str("{ pid := ");
				pid.log_match(match_value.constGetpid(), legacy);
				TTCN_Logger.log_event_str("{ fd_setsize := ");
				fd__setsize.log_match(match_value.constGetfd__setsize(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				module__name.encode_text(text_buf);
				testcase__name.encode_text(text_buf);
				pid.encode_text(text_buf);
				fd__setsize.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorRuntime_reason_template();
				reason.decode_text(text_buf);
				module__name = new TitanCharString_template();
				module__name.decode_text(text_buf);
				testcase__name = new TitanCharString_template();
				testcase__name.decode_text(text_buf);
				pid = new TitanInteger_template();
				pid.decode_text(text_buf);
				fd__setsize = new TitanInteger_template();
				fd__setsize.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorRuntime_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorRuntime_template temp = new ExecutorRuntime_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 5) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutorRuntime has 5 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getmodule__name().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettestcase__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getpid().set_param(param.get_elem(3));
				}
				if (param.get_size() > 4 && param.get_elem(4).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfd__setsize().set_param(param.get_elem(4));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("module_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getmodule__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("testcase_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettestcase__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("pid".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getpid().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("fd_setsize".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfd__setsize().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorRuntime: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutorRuntime");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorRuntime" : name, legacy);
				this.module__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorRuntime" : name, legacy);
				this.testcase__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorRuntime" : name, legacy);
				this.pid.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorRuntime" : name, legacy);
				this.fd__setsize.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorRuntime" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorRuntime" : name));
		}
	}
	public static void ExecutorRuntime_encoder(final ExecutorRuntime input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorRuntime_decoder( final TitanOctetString input_stream, final ExecutorRuntime output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FunctionEvent_choice_random_operation_encoder(final RandomAction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_random_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_random_operation_decoder( final TitanOctetString input_stream, final RandomAction output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_random_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void SetVerdictType_oldVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_oldVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_oldVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_oldVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FinalVerdictType extends Base_Type {
		private final FinalVerdictType_choice choice; //TTCN3_Choice_Type

		public FinalVerdictType() {
			this.choice = new FinalVerdictType_choice();
		}

		public FinalVerdictType(final FinalVerdictType_choice choice ) {
			this.choice = new FinalVerdictType_choice( choice );
		}

		public FinalVerdictType( final FinalVerdictType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FinalVerdictType.");
			}
			choice = new FinalVerdictType_choice();
			assign( otherValue );
		}

		public FinalVerdictType assign(final FinalVerdictType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FinalVerdictType");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FinalVerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType ) {
				return assign((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FinalVerdictType otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType ) {
				return operatorEquals((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictType", otherValue));
		}

		public FinalVerdictType_choice getchoice() {
			return choice;
		}

		public FinalVerdictType_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.FinalVerdictType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FinalVerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.FinalVerdictType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FinalVerdictType_template extends Base_Template {

		private FinalVerdictType_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<FinalVerdictType_template> list_value;

		public FinalVerdictType_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public FinalVerdictType_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.FinalVerdictType.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new FinalVerdictType_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public FinalVerdictType_template() {
			// do nothing
		}

		public FinalVerdictType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public FinalVerdictType_template( final FinalVerdictType otherValue ) {
			copyValue(otherValue);
		}

		public FinalVerdictType_template( final FinalVerdictType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public FinalVerdictType_template( final Optional<FinalVerdictType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.FinalVerdictType from an unbound optional field.");
			}
		}

		//originally operator=
		public FinalVerdictType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictType_template assign( final FinalVerdictType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public FinalVerdictType_template assign( final FinalVerdictType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public FinalVerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType) {
				return assign((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public FinalVerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FinalVerdictType_template) {
				return assign((FinalVerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType' can not be cast to {1}_template", otherValue));
		}

		public FinalVerdictType_template assign( final Optional<FinalVerdictType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FinalVerdictType.");
			}
			return this;
		}

		private void copyValue(final FinalVerdictType other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final FinalVerdictType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<FinalVerdictType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final FinalVerdictType_template temp = new FinalVerdictType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FinalVerdictType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FinalVerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FinalVerdictType.");
			}
			final FinalVerdictType ret_val = new FinalVerdictType();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public FinalVerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FinalVerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FinalVerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FinalVerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FinalVerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FinalVerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FinalVerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final FinalVerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FinalVerdictType) {
				return match((FinalVerdictType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FinalVerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictType) {
				log_match((FinalVerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.");
		}

		public void log_match(final FinalVerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new FinalVerdictType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FinalVerdictType_template>(size);
				for (int i = 0; i < size; i++) {
					final FinalVerdictType_template temp = new FinalVerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.FinalVerdictType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.FinalVerdictType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.FinalVerdictType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.FinalVerdictType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FinalVerdictType" : name));
		}
	}
	public static void FinalVerdictType_encoder(final FinalVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictType_decoder( final TitanOctetString input_stream, final FinalVerdictType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FinalVerdictType_choice_notification extends Base_Type {
		public enum enum_type {
			setting__final__verdict__of__the__test__case (0),
			no__ptcs__were__created (1),
			UNKNOWN_VALUE(2),
			UNBOUND_VALUE(3);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return setting__final__verdict__of__the__test__case;
				case 1:  return no__ptcs__were__created;
				case 2:  return UNKNOWN_VALUE;
				case 3:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public FinalVerdictType_choice_notification() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public FinalVerdictType_choice_notification(final FinalVerdictType_choice_notification otherValue) {
			enum_value = otherValue.enum_value;
		}

		public FinalVerdictType_choice_notification(final FinalVerdictType_choice_notification.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public FinalVerdictType_choice_notification(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `FinalVerdictType_choice_notification' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public FinalVerdictType_choice_notification assign(final FinalVerdictType_choice_notification otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public FinalVerdictType_choice_notification assign(final Base_Type otherValue){
			if( otherValue instanceof FinalVerdictType_choice_notification ) {
				return assign((FinalVerdictType_choice_notification) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public FinalVerdictType_choice_notification assign(final FinalVerdictType_choice_notification.enum_type otherValue){
			return assign( new FinalVerdictType_choice_notification(otherValue) );
		}

		//originally operator=
		public FinalVerdictType_choice_notification assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `FinalVerdictType_choice_notification'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final FinalVerdictType_choice_notification otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof FinalVerdictType_choice_notification) {
				return operatorEquals( (FinalVerdictType_choice_notification) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.notification.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final FinalVerdictType_choice_notification.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final FinalVerdictType_choice_notification otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final FinalVerdictType_choice_notification.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final FinalVerdictType_choice_notification.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final FinalVerdictType_choice_notification otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final FinalVerdictType_choice_notification.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final FinalVerdictType_choice_notification otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final FinalVerdictType_choice_notification.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final FinalVerdictType_choice_notification otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final FinalVerdictType_choice_notification.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final FinalVerdictType_choice_notification otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final FinalVerdictType_choice_notification.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final FinalVerdictType_choice_notification enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("setting__final__verdict__of__the__test__case".equals(strPar) || "setting_final_verdict_of_the_test_case".equals(strPar)) {
				return enum_type.setting__final__verdict__of__the__test__case;
			}
			if ("no__ptcs__were__created".equals(strPar) || "no_ptcs_were_created".equals(strPar)) {
				return enum_type.no__ptcs__were__created;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.FinalVerdictType.choice.notification");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.FinalVerdictType.choice.notification.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FinalVerdictType_choice_notification_template extends Base_Template {
		// single_value
		private FinalVerdictType_choice_notification.enum_type single_value;
		// value_list part
		private ArrayList<FinalVerdictType_choice_notification_template> value_list;

		private void copy_template(final FinalVerdictType_choice_notification_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<FinalVerdictType_choice_notification_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final FinalVerdictType_choice_notification_template temp = new FinalVerdictType_choice_notification_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type FinalVerdictType_choice_notification.");
			}
		}

		public FinalVerdictType_choice_notification_template() {
			// do nothing
		}

		public FinalVerdictType_choice_notification_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public FinalVerdictType_choice_notification_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!FinalVerdictType_choice_notification.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type FinalVerdictType_choice_notification with unknown numeric value "+ otherValue +".");
			}
			single_value = FinalVerdictType_choice_notification.enum_type.getValue(otherValue);
		}

		public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type FinalVerdictType_choice_notification. ");
			}
			single_value = otherValue.enum_value;
		}

		public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification_template otherValue) {
			copy_template(otherValue);
		}

		public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public FinalVerdictType_choice_notification_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_notification_template assign(final int otherValue) {
			if (!FinalVerdictType_choice_notification.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type FinalVerdictType_choice_notification.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification otherValue){
			if (otherValue.enum_value == FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type FinalVerdictType_choice_notification to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public FinalVerdictType_choice_notification_template assign(final Base_Type otherValue){
			if( otherValue instanceof FinalVerdictType_choice_notification ) {
				return assign((FinalVerdictType_choice_notification) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
		}

		@Override
		public FinalVerdictType_choice_notification_template assign(final Base_Template otherValue){
			if( otherValue instanceof FinalVerdictType_choice_notification_template ) {
				return assign((FinalVerdictType_choice_notification_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final FinalVerdictType_choice_notification.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final FinalVerdictType_choice_notification.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type FinalVerdictType_choice_notification.");
			}
		}

		// originally match
		public boolean match(final FinalVerdictType_choice_notification otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final FinalVerdictType_choice_notification otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof FinalVerdictType_choice_notification ) {
				return match((FinalVerdictType_choice_notification) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
		}

		public FinalVerdictType_choice_notification valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type FinalVerdictType_choice_notification.");
			}
			return new FinalVerdictType_choice_notification(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type FinalVerdictType_choice_notification.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<FinalVerdictType_choice_notification_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new FinalVerdictType_choice_notification_template());
			}
		}

		public FinalVerdictType_choice_notification_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type FinalVerdictType_choice_notification.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type FinalVerdictType_choice_notification.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type FinalVerdictType_choice_notification.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(FinalVerdictType_choice_notification.enum2str(single_value), FinalVerdictType_choice_notification.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictType_choice_notification) {
				log_match((FinalVerdictType_choice_notification)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.notification.");
		}
		public void log_match(final FinalVerdictType_choice_notification match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final FinalVerdictType_choice_notification.enum_type enum_value = FinalVerdictType_choice_notification.str_to_enum(param.get_enumerated());
				if (!FinalVerdictType_choice_notification.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.FinalVerdictType.choice.notification.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.FinalVerdictType.choice.notification");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!FinalVerdictType_choice_notification.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.", temp));
				}
				single_value = FinalVerdictType_choice_notification.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<FinalVerdictType_choice_notification_template>(size);
				for (int i = 0; i < size; i++) {
					final FinalVerdictType_choice_notification_template temp = new FinalVerdictType_choice_notification_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FinalVerdictType.choice.notification" : name));
		}
	}
	public static void FinalVerdictType_choice_notification_encoder(final FinalVerdictType_choice_notification input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice.notification' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictType_choice_notification_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictType_choice_notification_decoder( final TitanOctetString input_stream, final FinalVerdictType_choice_notification output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice.notification' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictType_choice_notification_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorUnqualified_reason extends Base_Type {
		public enum enum_type {
			local__address__was__set (0),
			address__of__mc__was__set (1),
			address__of__control__connection (2),
			host__support__unix__domain__sockets (3),
			UNKNOWN_VALUE(4),
			UNBOUND_VALUE(5);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return local__address__was__set;
				case 1:  return address__of__mc__was__set;
				case 2:  return address__of__control__connection;
				case 3:  return host__support__unix__domain__sockets;
				case 4:  return UNKNOWN_VALUE;
				case 5:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ExecutorUnqualified_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ExecutorUnqualified_reason(final ExecutorUnqualified_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ExecutorUnqualified_reason(final ExecutorUnqualified_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ExecutorUnqualified_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorUnqualified_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ExecutorUnqualified_reason assign(final ExecutorUnqualified_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ExecutorUnqualified_reason assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorUnqualified_reason ) {
				return assign((ExecutorUnqualified_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ExecutorUnqualified_reason assign(final ExecutorUnqualified_reason.enum_type otherValue){
			return assign( new ExecutorUnqualified_reason(otherValue) );
		}

		//originally operator=
		public ExecutorUnqualified_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorUnqualified_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorUnqualified_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ExecutorUnqualified_reason) {
				return operatorEquals( (ExecutorUnqualified_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorUnqualified_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorUnqualified_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorUnqualified_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ExecutorUnqualified_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ExecutorUnqualified_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorUnqualified_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorUnqualified_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorUnqualified_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorUnqualified_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorUnqualified_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorUnqualified_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ExecutorUnqualified_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ExecutorUnqualified_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("local__address__was__set".equals(strPar) || "local_address_was_set".equals(strPar)) {
				return enum_type.local__address__was__set;
			}
			if ("address__of__mc__was__set".equals(strPar) || "address_of_mc_was_set".equals(strPar)) {
				return enum_type.address__of__mc__was__set;
			}
			if ("address__of__control__connection".equals(strPar) || "address_of_control_connection".equals(strPar)) {
				return enum_type.address__of__control__connection;
			}
			if ("host__support__unix__domain__sockets".equals(strPar) || "host_support_unix_domain_sockets".equals(strPar)) {
				return enum_type.host__support__unix__domain__sockets;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ExecutorUnqualified.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorUnqualified.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorUnqualified_reason_template extends Base_Template {
		// single_value
		private ExecutorUnqualified_reason.enum_type single_value;
		// value_list part
		private ArrayList<ExecutorUnqualified_reason_template> value_list;

		private void copy_template(final ExecutorUnqualified_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ExecutorUnqualified_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ExecutorUnqualified_reason_template temp = new ExecutorUnqualified_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorUnqualified_reason.");
			}
		}

		public ExecutorUnqualified_reason_template() {
			// do nothing
		}

		public ExecutorUnqualified_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ExecutorUnqualified_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ExecutorUnqualified_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ExecutorUnqualified_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = ExecutorUnqualified_reason.enum_type.getValue(otherValue);
		}

		public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorUnqualified_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason_template otherValue) {
			copy_template(otherValue);
		}

		public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ExecutorUnqualified_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_reason_template assign(final int otherValue) {
			if (!ExecutorUnqualified_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorUnqualified_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason otherValue){
			if (otherValue.enum_value == ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorUnqualified_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ExecutorUnqualified_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorUnqualified_reason ) {
				return assign((ExecutorUnqualified_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorUnqualified_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof ExecutorUnqualified_reason_template ) {
				return assign((ExecutorUnqualified_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ExecutorUnqualified_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ExecutorUnqualified_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorUnqualified_reason.");
			}
		}

		// originally match
		public boolean match(final ExecutorUnqualified_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ExecutorUnqualified_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ExecutorUnqualified_reason ) {
				return match((ExecutorUnqualified_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
		}

		public ExecutorUnqualified_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorUnqualified_reason.");
			}
			return new ExecutorUnqualified_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorUnqualified_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ExecutorUnqualified_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ExecutorUnqualified_reason_template());
			}
		}

		public ExecutorUnqualified_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorUnqualified_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorUnqualified_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorUnqualified_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ExecutorUnqualified_reason.enum2str(single_value), ExecutorUnqualified_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorUnqualified_reason) {
				log_match((ExecutorUnqualified_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.reason.");
		}
		public void log_match(final ExecutorUnqualified_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ExecutorUnqualified_reason.enum_type enum_value = ExecutorUnqualified_reason.str_to_enum(param.get_enumerated());
				if (!ExecutorUnqualified_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorUnqualified.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ExecutorUnqualified.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ExecutorUnqualified_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.", temp));
				}
				single_value = ExecutorUnqualified_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ExecutorUnqualified_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorUnqualified_reason_template temp = new ExecutorUnqualified_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorUnqualified.reason" : name));
		}
	}
	public static void ExecutorUnqualified_reason_encoder(final ExecutorUnqualified_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorUnqualified_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorUnqualified_reason_decoder( final TitanOctetString input_stream, final ExecutorUnqualified_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorUnqualified_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__out_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParPort_srcCompref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_srcCompref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_srcCompref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_srcCompref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Msg__port__recv_operation extends Base_Type {
		public enum enum_type {
			receive__op (0),
			check__receive__op (1),
			trigger__op (2),
			UNKNOWN_VALUE(3),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return receive__op;
				case 1:  return check__receive__op;
				case 2:  return trigger__op;
				case 3:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Msg__port__recv_operation() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Msg__port__recv_operation(final Msg__port__recv_operation otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Msg__port__recv_operation(final Msg__port__recv_operation.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Msg__port__recv_operation(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Msg__port__recv_operation' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Msg__port__recv_operation assign(final Msg__port__recv_operation otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Msg__port__recv_operation assign(final Base_Type otherValue){
			if( otherValue instanceof Msg__port__recv_operation ) {
				return assign((Msg__port__recv_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Msg__port__recv_operation assign(final Msg__port__recv_operation.enum_type otherValue){
			return assign( new Msg__port__recv_operation(otherValue) );
		}

		//originally operator=
		public Msg__port__recv_operation assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Msg__port__recv_operation'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Msg__port__recv_operation otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Msg__port__recv_operation) {
				return operatorEquals( (Msg__port__recv_operation) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.operation.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Msg__port__recv_operation.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Msg__port__recv_operation otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Msg__port__recv_operation.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Msg__port__recv_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Msg__port__recv_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Msg__port__recv_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Msg__port__recv_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Msg__port__recv_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Msg__port__recv_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Msg__port__recv_operation.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Msg__port__recv_operation otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Msg__port__recv_operation.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Msg__port__recv_operation enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("receive__op".equals(strPar) || "receive_op".equals(strPar)) {
				return enum_type.receive__op;
			}
			if ("check__receive__op".equals(strPar) || "check_receive_op".equals(strPar)) {
				return enum_type.check__receive__op;
			}
			if ("trigger__op".equals(strPar) || "trigger_op".equals(strPar)) {
				return enum_type.trigger__op;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Msg_port_recv.operation");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Msg_port_recv.operation.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Msg_port_recv.operation.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Msg__port__recv_operation_template extends Base_Template {
		// single_value
		private Msg__port__recv_operation.enum_type single_value;
		// value_list part
		private ArrayList<Msg__port__recv_operation_template> value_list;

		private void copy_template(final Msg__port__recv_operation_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Msg__port__recv_operation_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Msg__port__recv_operation_template temp = new Msg__port__recv_operation_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Msg__port__recv_operation.");
			}
		}

		public Msg__port__recv_operation_template() {
			// do nothing
		}

		public Msg__port__recv_operation_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Msg__port__recv_operation_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Msg__port__recv_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Msg__port__recv_operation with unknown numeric value "+ otherValue +".");
			}
			single_value = Msg__port__recv_operation.enum_type.getValue(otherValue);
		}

		public Msg__port__recv_operation_template(final Msg__port__recv_operation otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Msg__port__recv_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Msg__port__recv_operation. ");
			}
			single_value = otherValue.enum_value;
		}

		public Msg__port__recv_operation_template(final Msg__port__recv_operation_template otherValue) {
			copy_template(otherValue);
		}

		public Msg__port__recv_operation_template(final Msg__port__recv_operation.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Msg__port__recv_operation.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Msg__port__recv_operation_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Msg__port__recv_operation_template assign(final int otherValue) {
			if (!Msg__port__recv_operation.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Msg__port__recv_operation.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Msg__port__recv_operation_template assign(final Msg__port__recv_operation.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Msg__port__recv_operation_template assign(final Msg__port__recv_operation_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Msg__port__recv_operation_template assign(final Msg__port__recv_operation otherValue){
			if (otherValue.enum_value == Msg__port__recv_operation.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Msg__port__recv_operation to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Msg__port__recv_operation_template assign(final Base_Type otherValue){
			if( otherValue instanceof Msg__port__recv_operation ) {
				return assign((Msg__port__recv_operation) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
		}

		@Override
		public Msg__port__recv_operation_template assign(final Base_Template otherValue){
			if( otherValue instanceof Msg__port__recv_operation_template ) {
				return assign((Msg__port__recv_operation_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Msg__port__recv_operation.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Msg__port__recv_operation.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Msg__port__recv_operation.");
			}
		}

		// originally match
		public boolean match(final Msg__port__recv_operation otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Msg__port__recv_operation otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Msg__port__recv_operation ) {
				return match((Msg__port__recv_operation) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
		}

		public Msg__port__recv_operation valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Msg__port__recv_operation.");
			}
			return new Msg__port__recv_operation(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Msg__port__recv_operation.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Msg__port__recv_operation_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Msg__port__recv_operation_template());
			}
		}

		public Msg__port__recv_operation_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Msg__port__recv_operation.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Msg__port__recv_operation.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Msg__port__recv_operation.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Msg__port__recv_operation.enum2str(single_value), Msg__port__recv_operation.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Msg__port__recv_operation) {
				log_match((Msg__port__recv_operation)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.operation.");
		}
		public void log_match(final Msg__port__recv_operation match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Msg__port__recv_operation.enum_type enum_value = Msg__port__recv_operation.str_to_enum(param.get_enumerated());
				if (!Msg__port__recv_operation.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Msg_port_recv.operation.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Msg_port_recv.operation");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Msg__port__recv_operation.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Msg_port_recv.operation.", temp));
				}
				single_value = Msg__port__recv_operation.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Msg__port__recv_operation_template>(size);
				for (int i = 0; i < size; i++) {
					final Msg__port__recv_operation_template temp = new Msg__port__recv_operation_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Msg_port_recv.operation" : name));
		}
	}
	public static void Msg__port__recv_operation_encoder(final Msg__port__recv_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_operation_decoder( final TitanOctetString input_stream, final Msg__port__recv_operation output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_operation_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__mapped_target__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__mapped_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__mapped_target__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__mapped_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_remote__component_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_remote__component_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_remote__component_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_remote__component_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParPort_srcPort_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParPort_srcPort_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParPort_srcPort_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParPort_srcPort_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void QualifiedName_module__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(QualifiedName_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger QualifiedName_module__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(QualifiedName_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Verdict extends Base_Type {
		public enum enum_type {
			v0none (0),
			v1pass (1),
			v2inconc (2),
			v3fail (3),
			v4error (4),
			UNKNOWN_VALUE(5),
			UNBOUND_VALUE(6);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return v0none;
				case 1:  return v1pass;
				case 2:  return v2inconc;
				case 3:  return v3fail;
				case 4:  return v4error;
				case 5:  return UNKNOWN_VALUE;
				case 6:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public Verdict() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public Verdict(final Verdict otherValue) {
			enum_value = otherValue.enum_value;
		}

		public Verdict(final Verdict.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public Verdict(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Verdict' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public Verdict assign(final Verdict otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public Verdict assign(final Base_Type otherValue){
			if( otherValue instanceof Verdict ) {
				return assign((Verdict) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public Verdict assign(final Verdict.enum_type otherValue){
			return assign( new Verdict(otherValue) );
		}

		//originally operator=
		public Verdict assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Verdict'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final Verdict otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof Verdict) {
				return operatorEquals( (Verdict) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Verdict.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final Verdict.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final Verdict otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Verdict.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final Verdict.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final Verdict otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Verdict.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final Verdict otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final Verdict.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final Verdict otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Verdict.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final Verdict otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final Verdict.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final Verdict enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("v0none".equals(strPar)) {
				return enum_type.v0none;
			}
			if ("v1pass".equals(strPar)) {
				return enum_type.v1pass;
			}
			if ("v2inconc".equals(strPar)) {
				return enum_type.v2inconc;
			}
			if ("v3fail".equals(strPar)) {
				return enum_type.v3fail;
			}
			if ("v4error".equals(strPar)) {
				return enum_type.v4error;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.Verdict");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.Verdict.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Verdict.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Verdict.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Verdict_template extends Base_Template {
		// single_value
		private Verdict.enum_type single_value;
		// value_list part
		private ArrayList<Verdict_template> value_list;

		private void copy_template(final Verdict_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<Verdict_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final Verdict_template temp = new Verdict_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Verdict.");
			}
		}

		public Verdict_template() {
			// do nothing
		}

		public Verdict_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public Verdict_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!Verdict.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type Verdict with unknown numeric value "+ otherValue +".");
			}
			single_value = Verdict.enum_type.getValue(otherValue);
		}

		public Verdict_template(final Verdict otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == Verdict.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type Verdict. ");
			}
			single_value = otherValue.enum_value;
		}

		public Verdict_template(final Verdict_template otherValue) {
			copy_template(otherValue);
		}

		public Verdict_template(final Verdict.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != Verdict.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public Verdict_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public Verdict_template assign(final int otherValue) {
			if (!Verdict.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Verdict.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public Verdict_template assign(final Verdict.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public Verdict_template assign(final Verdict_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public Verdict_template assign(final Verdict otherValue){
			if (otherValue.enum_value == Verdict.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type Verdict to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public Verdict_template assign(final Base_Type otherValue){
			if( otherValue instanceof Verdict ) {
				return assign((Verdict) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
		}

		@Override
		public Verdict_template assign(final Base_Template otherValue){
			if( otherValue instanceof Verdict_template ) {
				return assign((Verdict_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final Verdict.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final Verdict.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Verdict.");
			}
		}

		// originally match
		public boolean match(final Verdict otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final Verdict otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof Verdict ) {
				return match((Verdict) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
		}

		public Verdict valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Verdict.");
			}
			return new Verdict(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type Verdict.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<Verdict_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new Verdict_template());
			}
		}

		public Verdict_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type Verdict.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type Verdict.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type Verdict.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(Verdict.enum2str(single_value), Verdict.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Verdict) {
				log_match((Verdict)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Verdict.");
		}
		public void log_match(final Verdict match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final Verdict.enum_type enum_value = Verdict.str_to_enum(param.get_enumerated());
				if (!Verdict.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.Verdict.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.Verdict");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Verdict.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!Verdict.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Verdict.", temp));
				}
				single_value = Verdict.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<Verdict_template>(size);
				for (int i = 0; i < size; i++) {
					final Verdict_template temp = new Verdict_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Verdict.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Verdict" : name));
		}
	}
	public static void Verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Verdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_tc__loc_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_tc__loc_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_tc__loc_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_tc__loc_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FunctionEvent_choice_random_intseed_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_random_intseed_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_random_intseed_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_random_intseed_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PTC__exit_statuscode_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PTC__exit_statuscode_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PTC__exit_statuscode_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PTC__exit_statuscode_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_statistics_encoder(final StatisticsType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_statistics_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_statistics_decoder( final TitanOctetString input_stream, final StatisticsType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_statistics_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ParallelPTC_reason extends Base_Type {
		public enum enum_type {
			init__component__start (0),
			init__component__finish (1),
			terminating__component (2),
			component__shut__down (3),
			error__idle__ptc (4),
			ptc__created (5),
			ptc__created__pid (6),
			function__started (7),
			function__stopped (8),
			function__finished (9),
			function__error (10),
			ptc__done (11),
			ptc__killed (12),
			stopping__mtc (13),
			ptc__stopped (14),
			all__comps__stopped (15),
			ptc__was__killed (16),
			all__comps__killed (17),
			kill__request__frm__mc (18),
			mtc__finished (19),
			ptc__finished (20),
			starting__function (21),
			UNKNOWN_VALUE(22),
			UNBOUND_VALUE(23);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return init__component__start;
				case 1:  return init__component__finish;
				case 2:  return terminating__component;
				case 3:  return component__shut__down;
				case 4:  return error__idle__ptc;
				case 5:  return ptc__created;
				case 6:  return ptc__created__pid;
				case 7:  return function__started;
				case 8:  return function__stopped;
				case 9:  return function__finished;
				case 10:  return function__error;
				case 11:  return ptc__done;
				case 12:  return ptc__killed;
				case 13:  return stopping__mtc;
				case 14:  return ptc__stopped;
				case 15:  return all__comps__stopped;
				case 16:  return ptc__was__killed;
				case 17:  return all__comps__killed;
				case 18:  return kill__request__frm__mc;
				case 19:  return mtc__finished;
				case 20:  return ptc__finished;
				case 21:  return starting__function;
				case 22:  return UNKNOWN_VALUE;
				case 23:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ParallelPTC_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ParallelPTC_reason(final ParallelPTC_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ParallelPTC_reason(final ParallelPTC_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ParallelPTC_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ParallelPTC_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ParallelPTC_reason assign(final ParallelPTC_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ParallelPTC_reason assign(final Base_Type otherValue){
			if( otherValue instanceof ParallelPTC_reason ) {
				return assign((ParallelPTC_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ParallelPTC_reason assign(final ParallelPTC_reason.enum_type otherValue){
			return assign( new ParallelPTC_reason(otherValue) );
		}

		//originally operator=
		public ParallelPTC_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ParallelPTC_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ParallelPTC_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ParallelPTC_reason) {
				return operatorEquals( (ParallelPTC_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ParallelPTC_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ParallelPTC_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ParallelPTC_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ParallelPTC_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ParallelPTC_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ParallelPTC_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ParallelPTC_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ParallelPTC_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ParallelPTC_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ParallelPTC_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ParallelPTC_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ParallelPTC_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ParallelPTC_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("init__component__start".equals(strPar) || "init_component_start".equals(strPar)) {
				return enum_type.init__component__start;
			}
			if ("init__component__finish".equals(strPar) || "init_component_finish".equals(strPar)) {
				return enum_type.init__component__finish;
			}
			if ("terminating__component".equals(strPar) || "terminating_component".equals(strPar)) {
				return enum_type.terminating__component;
			}
			if ("component__shut__down".equals(strPar) || "component_shut_down".equals(strPar)) {
				return enum_type.component__shut__down;
			}
			if ("error__idle__ptc".equals(strPar) || "error_idle_ptc".equals(strPar)) {
				return enum_type.error__idle__ptc;
			}
			if ("ptc__created".equals(strPar) || "ptc_created".equals(strPar)) {
				return enum_type.ptc__created;
			}
			if ("ptc__created__pid".equals(strPar) || "ptc_created_pid".equals(strPar)) {
				return enum_type.ptc__created__pid;
			}
			if ("function__started".equals(strPar) || "function_started".equals(strPar)) {
				return enum_type.function__started;
			}
			if ("function__stopped".equals(strPar) || "function_stopped".equals(strPar)) {
				return enum_type.function__stopped;
			}
			if ("function__finished".equals(strPar) || "function_finished".equals(strPar)) {
				return enum_type.function__finished;
			}
			if ("function__error".equals(strPar) || "function_error".equals(strPar)) {
				return enum_type.function__error;
			}
			if ("ptc__done".equals(strPar) || "ptc_done".equals(strPar)) {
				return enum_type.ptc__done;
			}
			if ("ptc__killed".equals(strPar) || "ptc_killed".equals(strPar)) {
				return enum_type.ptc__killed;
			}
			if ("stopping__mtc".equals(strPar) || "stopping_mtc".equals(strPar)) {
				return enum_type.stopping__mtc;
			}
			if ("ptc__stopped".equals(strPar) || "ptc_stopped".equals(strPar)) {
				return enum_type.ptc__stopped;
			}
			if ("all__comps__stopped".equals(strPar) || "all_comps_stopped".equals(strPar)) {
				return enum_type.all__comps__stopped;
			}
			if ("ptc__was__killed".equals(strPar) || "ptc_was_killed".equals(strPar)) {
				return enum_type.ptc__was__killed;
			}
			if ("all__comps__killed".equals(strPar) || "all_comps_killed".equals(strPar)) {
				return enum_type.all__comps__killed;
			}
			if ("kill__request__frm__mc".equals(strPar) || "kill_request_frm_mc".equals(strPar)) {
				return enum_type.kill__request__frm__mc;
			}
			if ("mtc__finished".equals(strPar) || "mtc_finished".equals(strPar)) {
				return enum_type.mtc__finished;
			}
			if ("ptc__finished".equals(strPar) || "ptc_finished".equals(strPar)) {
				return enum_type.ptc__finished;
			}
			if ("starting__function".equals(strPar) || "starting_function".equals(strPar)) {
				return enum_type.starting__function;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ParallelPTC.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ParallelPTC.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParallelPTC.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ParallelPTC_reason_template extends Base_Template {
		// single_value
		private ParallelPTC_reason.enum_type single_value;
		// value_list part
		private ArrayList<ParallelPTC_reason_template> value_list;

		private void copy_template(final ParallelPTC_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ParallelPTC_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ParallelPTC_reason_template temp = new ParallelPTC_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ParallelPTC_reason.");
			}
		}

		public ParallelPTC_reason_template() {
			// do nothing
		}

		public ParallelPTC_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ParallelPTC_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ParallelPTC_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ParallelPTC_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = ParallelPTC_reason.enum_type.getValue(otherValue);
		}

		public ParallelPTC_reason_template(final ParallelPTC_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ParallelPTC_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ParallelPTC_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public ParallelPTC_reason_template(final ParallelPTC_reason_template otherValue) {
			copy_template(otherValue);
		}

		public ParallelPTC_reason_template(final ParallelPTC_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ParallelPTC_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ParallelPTC_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ParallelPTC_reason_template assign(final int otherValue) {
			if (!ParallelPTC_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ParallelPTC_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ParallelPTC_reason_template assign(final ParallelPTC_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ParallelPTC_reason_template assign(final ParallelPTC_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ParallelPTC_reason_template assign(final ParallelPTC_reason otherValue){
			if (otherValue.enum_value == ParallelPTC_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ParallelPTC_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ParallelPTC_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof ParallelPTC_reason ) {
				return assign((ParallelPTC_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public ParallelPTC_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof ParallelPTC_reason_template ) {
				return assign((ParallelPTC_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ParallelPTC_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ParallelPTC_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ParallelPTC_reason.");
			}
		}

		// originally match
		public boolean match(final ParallelPTC_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ParallelPTC_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ParallelPTC_reason ) {
				return match((ParallelPTC_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
		}

		public ParallelPTC_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ParallelPTC_reason.");
			}
			return new ParallelPTC_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ParallelPTC_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ParallelPTC_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ParallelPTC_reason_template());
			}
		}

		public ParallelPTC_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ParallelPTC_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ParallelPTC_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ParallelPTC_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ParallelPTC_reason.enum2str(single_value), ParallelPTC_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelPTC_reason) {
				log_match((ParallelPTC_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.reason.");
		}
		public void log_match(final ParallelPTC_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ParallelPTC_reason.enum_type enum_value = ParallelPTC_reason.str_to_enum(param.get_enumerated());
				if (!ParallelPTC_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ParallelPTC.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ParallelPTC.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ParallelPTC_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParallelPTC.reason.", temp));
				}
				single_value = ParallelPTC_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ParallelPTC_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final ParallelPTC_reason_template temp = new ParallelPTC_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ParallelPTC.reason" : name));
		}
	}
	public static void ParallelPTC_reason_encoder(final ParallelPTC_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_reason_decoder( final TitanOctetString input_stream, final ParallelPTC_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_debugLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_debugLog_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_debugLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_debugLog_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Categorized_category_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Categorized_category_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Categorized_category_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Categorized_category_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorUnqualified_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorUnqualified_name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorUnqualified_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorUnqualified_name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Misc_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Misc_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Misc_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Misc_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TimerGuardType extends Base_Type {
		private final TitanFloat value__; //Float_Type

		public TimerGuardType() {
			this.value__ = new TitanFloat();
		}

		public TimerGuardType(final TitanFloat value__ ) {
			this.value__ = new TitanFloat( value__ );
		}

		public TimerGuardType( final TimerGuardType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerGuardType.");
			}
			value__ = new TitanFloat();
			assign( otherValue );
		}

		public TimerGuardType assign(final TimerGuardType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerGuardType");
			}

			if (otherValue != this) {
				if ( otherValue.getvalue__().isBound() ) {
					this.value__.assign( otherValue.getvalue__() );
				} else {
					this.value__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerGuardType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType ) {
				return assign((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerGuardType", otherValue));
		}

		public void cleanUp() {
			value__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( value__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !value__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerGuardType otherValue) {
			if ( !this.value__.operatorEquals( otherValue.value__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType ) {
				return operatorEquals((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerGuardType", otherValue));
		}

		public TitanFloat getvalue__() {
			return value__;
		}

		public TitanFloat constGetvalue__() {
			return value__;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TimerGuardType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerGuardType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TimerGuardType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			value__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			value__.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TimerGuardType_template extends Base_Template {

		private TitanFloat_template value__; //Float_Type
		//originally value_list/list_value
		private List<TimerGuardType_template> list_value;

		public TitanFloat_template getvalue__() {
			setSpecific();
			return value__;
		}

		public TitanFloat_template constGetvalue__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.TimerGuardType.");
			}
			return value__;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value__ = new TitanFloat_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					value__.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TimerGuardType_template() {
			// do nothing
		}

		public TimerGuardType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TimerGuardType_template( final TimerGuardType otherValue ) {
			copyValue(otherValue);
		}

		public TimerGuardType_template( final TimerGuardType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TimerGuardType_template( final Optional<TimerGuardType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerGuardType from an unbound optional field.");
			}
		}

		//originally operator=
		public TimerGuardType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TimerGuardType_template assign( final TimerGuardType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TimerGuardType_template assign( final TimerGuardType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TimerGuardType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType) {
				return assign((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerGuardType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerGuardType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerGuardType_template) {
				return assign((TimerGuardType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerGuardType' can not be cast to {1}_template", otherValue));
		}

		public TimerGuardType_template assign( final Optional<TimerGuardType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerGuardType.");
			}
			return this;
		}

		private void copyValue(final TimerGuardType other_value) {
			if (other_value.getvalue__().isBound()) {
				getvalue__().assign(other_value.getvalue__());
			} else {
				getvalue__().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TimerGuardType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getvalue__().get_selection()) {
					getvalue__().cleanUp();
				} else {
					getvalue__().assign(other_value.getvalue__());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TimerGuardType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TimerGuardType_template temp = new TimerGuardType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerGuardType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerGuardType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerGuardType.");
			}
			final TimerGuardType ret_val = new TimerGuardType();
			if (value__.isBound()) {
				ret_val.getvalue__().assign(value__.valueOf());
			}
			return ret_val;
		}

		public TimerGuardType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerGuardType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerGuardType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerGuardType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerGuardType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerGuardType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerGuardType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerGuardType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getvalue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getvalue__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TimerGuardType) {
				return match((TimerGuardType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerGuardType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerGuardType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerGuardType) {
				log_match((TimerGuardType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerGuardType.");
		}

		public void log_match(final TimerGuardType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !value__.match(match_value.constGetvalue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetvalue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetvalue__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				value__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				value__ = new TitanFloat_template();
				value__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerGuardType_template>(size);
				for (int i = 0; i < size; i++) {
					final TimerGuardType_template temp = new TimerGuardType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TimerGuardType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getvalue__().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("value_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getvalue__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TimerGuardType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TimerGuardType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.value__.check_restriction(restriction, name == null ? "@TitanLoggerApi.TimerGuardType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TimerGuardType" : name));
		}
	}
	public static void TimerGuardType_encoder(final TimerGuardType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerGuardType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerGuardType_decoder( final TitanOctetString input_stream, final TimerGuardType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerGuardType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_startTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_startTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_startTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_startTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void SetVerdictType_newVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_newVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_newVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_newVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class StartFunction extends Base_Type {
		private final TitanCharString function__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final StartFunction_parameter__list parameter__list; //SequenceOf_Type

		public StartFunction() {
			this.function__name = new TitanCharString();
			this.compref = new TitanInteger();
			this.parameter__list = new StartFunction_parameter__list();
		}

		public StartFunction(final TitanCharString function__name, final TitanInteger compref, final StartFunction_parameter__list parameter__list ) {
			this.function__name = new TitanCharString( function__name );
			this.compref = new TitanInteger( compref );
			this.parameter__list = new StartFunction_parameter__list( parameter__list );
		}

		public StartFunction( final StartFunction otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StartFunction.");
			}
			function__name = new TitanCharString();
			compref = new TitanInteger();
			parameter__list = new StartFunction_parameter__list();
			assign( otherValue );
		}

		public StartFunction assign(final StartFunction otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StartFunction");
			}

			if (otherValue != this) {
				if ( otherValue.getfunction__name().isBound() ) {
					this.function__name.assign( otherValue.getfunction__name() );
				} else {
					this.function__name.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( otherValue.getparameter__list().isBound() ) {
					this.parameter__list.assign( otherValue.getparameter__list() );
				} else {
					this.parameter__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StartFunction assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction ) {
				return assign((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StartFunction", otherValue));
		}

		public void cleanUp() {
			function__name.cleanUp();
			compref.cleanUp();
			parameter__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( function__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( parameter__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !function__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !parameter__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StartFunction otherValue) {
			if ( !this.function__name.operatorEquals( otherValue.function__name ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			if ( !this.parameter__list.operatorEquals( otherValue.parameter__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction ) {
				return operatorEquals((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StartFunction", otherValue));
		}

		public TitanCharString getfunction__name() {
			return function__name;
		}

		public TitanCharString constGetfunction__name() {
			return function__name;
		}

		public TitanInteger getcompref() {
			return compref;
		}

		public TitanInteger constGetcompref() {
			return compref;
		}

		public StartFunction_parameter__list getparameter__list() {
			return parameter__list;
		}

		public StartFunction_parameter__list constGetparameter__list() {
			return parameter__list;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(3);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" function_name := ");
			function__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter_list := ");
			parameter__list.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.StartFunction has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfunction__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter__list().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("function_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfunction__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StartFunction: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.StartFunction");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (function__name.isBound()) {
				function__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (parameter__list.isBound()) {
				parameter__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			function__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			parameter__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			function__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			parameter__list.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class StartFunction_template extends Base_Template {

		private TitanCharString_template function__name; //CharString_Type
		private TitanInteger_template compref; //Integer_Type
		private StartFunction_parameter__list_template parameter__list; //SequenceOf_Type
		//originally value_list/list_value
		private List<StartFunction_template> list_value;

		public TitanCharString_template getfunction__name() {
			setSpecific();
			return function__name;
		}

		public TitanCharString_template constGetfunction__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field function_name of a non-specific template of type @TitanLoggerApi.StartFunction.");
			}
			return function__name;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.StartFunction.");
			}
			return compref;
		}

		public StartFunction_parameter__list_template getparameter__list() {
			setSpecific();
			return parameter__list;
		}

		public StartFunction_parameter__list_template constGetparameter__list() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field parameter_list of a non-specific template of type @TitanLoggerApi.StartFunction.");
			}
			return parameter__list;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				function__name = new TitanCharString_template();
				compref = new TitanInteger_template();
				parameter__list = new StartFunction_parameter__list_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					function__name.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_VALUE);
					parameter__list.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public StartFunction_template() {
			// do nothing
		}

		public StartFunction_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public StartFunction_template( final StartFunction otherValue ) {
			copyValue(otherValue);
		}

		public StartFunction_template( final StartFunction_template otherValue ) {
			copyTemplate( otherValue );
		}

		public StartFunction_template( final Optional<StartFunction> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.StartFunction from an unbound optional field.");
			}
		}

		//originally operator=
		public StartFunction_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public StartFunction_template assign( final StartFunction other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public StartFunction_template assign( final StartFunction_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public StartFunction_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction) {
				return assign((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StartFunction' can not be cast to {1}", otherValue));
		}

		@Override
		public StartFunction_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StartFunction_template) {
				return assign((StartFunction_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StartFunction' can not be cast to {1}_template", otherValue));
		}

		public StartFunction_template assign( final Optional<StartFunction> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StartFunction.");
			}
			return this;
		}

		private void copyValue(final StartFunction other_value) {
			if (other_value.getfunction__name().isBound()) {
				getfunction__name().assign(other_value.getfunction__name());
			} else {
				getfunction__name().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				getcompref().assign(other_value.getcompref());
			} else {
				getcompref().cleanUp();
			}
			if (other_value.getparameter__list().isBound()) {
				getparameter__list().assign(other_value.getparameter__list());
			} else {
				getparameter__list().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final StartFunction_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getfunction__name().get_selection()) {
					getfunction__name().cleanUp();
				} else {
					getfunction__name().assign(other_value.getfunction__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getparameter__list().get_selection()) {
					getparameter__list().cleanUp();
				} else {
					getparameter__list().assign(other_value.getparameter__list());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<StartFunction_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final StartFunction_template temp = new StartFunction_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StartFunction.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StartFunction valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StartFunction.");
			}
			final StartFunction ret_val = new StartFunction();
			if (function__name.isBound()) {
				ret_val.getfunction__name().assign(function__name.valueOf());
			}
			if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			if (parameter__list.isBound()) {
				ret_val.getparameter__list().assign(parameter__list.valueOf());
			}
			return ret_val;
		}

		public StartFunction_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StartFunction.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StartFunction.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StartFunction_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StartFunction_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (function__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (parameter__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!function__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!parameter__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StartFunction other_value) {
			return match(other_value, false);
		}

		public boolean match(final StartFunction other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getfunction__name().isBound()) {
					return false;
				}
				if(!function__name.match(other_value.getfunction__name(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getcompref(), legacy)) {
					return false;
				}
				if(!other_value.getparameter__list().isBound()) {
					return false;
				}
				if(!parameter__list.match(other_value.getparameter__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof StartFunction) {
				return match((StartFunction)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(3);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" function_name := ");
				function__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter_list := ");
				parameter__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StartFunction match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StartFunction) {
				log_match((StartFunction)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StartFunction.");
		}

		public void log_match(final StartFunction match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !function__name.match(match_value.constGetfunction__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".function_name");
							function__name.log_match(match_value.constGetfunction__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetcompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetcompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter__list.match(match_value.constGetparameter__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter_list");
							parameter__list.log_match(match_value.constGetparameter__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ function_name := ");
				function__name.log_match(match_value.constGetfunction__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str("{ parameter_list := ");
				parameter__list.log_match(match_value.constGetparameter__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				function__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				parameter__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				function__name = new TitanCharString_template();
				function__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				parameter__list = new StartFunction_parameter__list_template();
				parameter__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StartFunction_template>(size);
				for (int i = 0; i < size; i++) {
					final StartFunction_template temp = new StartFunction_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StartFunction.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 3) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.StartFunction has 3 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getfunction__name().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getparameter__list().set_param(param.get_elem(2));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("function_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getfunction__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("parameter_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getparameter__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StartFunction: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.StartFunction");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.function__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.StartFunction" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.StartFunction" : name, legacy);
				this.parameter__list.check_restriction(restriction, name == null ? "@TitanLoggerApi.StartFunction" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.StartFunction" : name));
		}
	}
	public static void StartFunction_encoder(final StartFunction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StartFunction_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StartFunction_decoder( final TitanOctetString input_stream, final StartFunction output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StartFunction_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorUnqualified extends Base_Type {
		private final ExecutorUnqualified_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString name; //CharString_Type
		private final TitanCharString addr; //CharString_Type
		private final TitanInteger port__; //Integer_Type

		public ExecutorUnqualified() {
			this.reason = new ExecutorUnqualified_reason();
			this.name = new TitanCharString();
			this.addr = new TitanCharString();
			this.port__ = new TitanInteger();
		}

		public ExecutorUnqualified(final ExecutorUnqualified_reason reason, final TitanCharString name, final TitanCharString addr, final TitanInteger port__ ) {
			this.reason = new ExecutorUnqualified_reason( reason );
			this.name = new TitanCharString( name );
			this.addr = new TitanCharString( addr );
			this.port__ = new TitanInteger( port__ );
		}

		public ExecutorUnqualified( final ExecutorUnqualified otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			reason = new ExecutorUnqualified_reason();
			name = new TitanCharString();
			addr = new TitanCharString();
			port__ = new TitanInteger();
			assign( otherValue );
		}

		public ExecutorUnqualified assign(final ExecutorUnqualified otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorUnqualified");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getname().isBound() ) {
					this.name.assign( otherValue.getname() );
				} else {
					this.name.cleanUp();
				}
				if ( otherValue.getaddr().isBound() ) {
					this.addr.assign( otherValue.getaddr() );
				} else {
					this.addr.cleanUp();
				}
				if ( otherValue.getport__().isBound() ) {
					this.port__.assign( otherValue.getport__() );
				} else {
					this.port__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorUnqualified assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified ) {
				return assign((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorUnqualified", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			name.cleanUp();
			addr.cleanUp();
			port__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			if ( addr.isBound() ) { return true; }
			if ( port__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			if ( !addr.isValue() ) { return false; }
			if ( !port__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorUnqualified otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.name.operatorEquals( otherValue.name ) ) { return false; }
			if ( !this.addr.operatorEquals( otherValue.addr ) ) { return false; }
			if ( !this.port__.operatorEquals( otherValue.port__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified ) {
				return operatorEquals((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorUnqualified", otherValue));
		}

		public ExecutorUnqualified_reason getreason() {
			return reason;
		}

		public ExecutorUnqualified_reason constGetreason() {
			return reason;
		}

		public TitanCharString getname() {
			return name;
		}

		public TitanCharString constGetname() {
			return name;
		}

		public TitanCharString getaddr() {
			return addr;
		}

		public TitanCharString constGetaddr() {
			return addr;
		}

		public TitanInteger getport__() {
			return port__;
		}

		public TitanInteger constGetport__() {
			return port__;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" addr := ");
			addr.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_ := ");
			port__.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutorUnqualified has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getaddr().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("addr".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getaddr().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorUnqualified: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutorUnqualified");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (addr.isBound()) {
				addr.set_implicit_omit();
			}
			if (port__.isBound()) {
				port__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			name.encode_text(text_buf);
			addr.encode_text(text_buf);
			port__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			name.decode_text(text_buf);
			addr.decode_text(text_buf);
			port__.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorUnqualified_template extends Base_Template {

		private ExecutorUnqualified_reason_template reason; //TTCN3_Enumerated_Type
		private TitanCharString_template name; //CharString_Type
		private TitanCharString_template addr; //CharString_Type
		private TitanInteger_template port__; //Integer_Type
		//originally value_list/list_value
		private List<ExecutorUnqualified_template> list_value;

		public ExecutorUnqualified_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public ExecutorUnqualified_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return reason;
		}

		public TitanCharString_template getname() {
			setSpecific();
			return name;
		}

		public TitanCharString_template constGetname() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return name;
		}

		public TitanCharString_template getaddr() {
			setSpecific();
			return addr;
		}

		public TitanCharString_template constGetaddr() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field addr of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return addr;
		}

		public TitanInteger_template getport__() {
			setSpecific();
			return port__;
		}

		public TitanInteger_template constGetport__() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_ of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return port__;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new ExecutorUnqualified_reason_template();
				name = new TitanCharString_template();
				addr = new TitanCharString_template();
				port__ = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					name.assign(template_sel.ANY_VALUE);
					addr.assign(template_sel.ANY_VALUE);
					port__.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ExecutorUnqualified_template() {
			// do nothing
		}

		public ExecutorUnqualified_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutorUnqualified_template( final ExecutorUnqualified otherValue ) {
			copyValue(otherValue);
		}

		public ExecutorUnqualified_template( final ExecutorUnqualified_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutorUnqualified_template( final Optional<ExecutorUnqualified> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorUnqualified from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutorUnqualified_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_template assign( final ExecutorUnqualified other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutorUnqualified_template assign( final ExecutorUnqualified_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutorUnqualified_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified) {
				return assign((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorUnqualified_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorUnqualified_template) {
				return assign((ExecutorUnqualified_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified' can not be cast to {1}_template", otherValue));
		}

		public ExecutorUnqualified_template assign( final Optional<ExecutorUnqualified> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return this;
		}

		private void copyValue(final ExecutorUnqualified other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getname().isBound()) {
				getname().assign(other_value.getname());
			} else {
				getname().cleanUp();
			}
			if (other_value.getaddr().isBound()) {
				getaddr().assign(other_value.getaddr());
			} else {
				getaddr().cleanUp();
			}
			if (other_value.getport__().isBound()) {
				getport__().assign(other_value.getport__());
			} else {
				getport__().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutorUnqualified_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getname().get_selection()) {
					getname().cleanUp();
				} else {
					getname().assign(other_value.getname());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getaddr().get_selection()) {
					getaddr().cleanUp();
				} else {
					getaddr().assign(other_value.getaddr());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__().get_selection()) {
					getport__().cleanUp();
				} else {
					getport__().assign(other_value.getport__());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutorUnqualified_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutorUnqualified_template temp = new ExecutorUnqualified_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorUnqualified valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			final ExecutorUnqualified ret_val = new ExecutorUnqualified();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (name.isBound()) {
				ret_val.getname().assign(name.valueOf());
			}
			if (addr.isBound()) {
				ret_val.getaddr().assign(addr.valueOf());
			}
			if (port__.isBound()) {
				ret_val.getport__().assign(port__.valueOf());
			}
			return ret_val;
		}

		public ExecutorUnqualified_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorUnqualified_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorUnqualified_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (addr.isBound()) {
				return true;
			}
			if (port__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!addr.isValue()) {
				return false;
			}
			if (!port__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorUnqualified other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorUnqualified other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getname().isBound()) {
					return false;
				}
				if(!name.match(other_value.getname(), legacy)) {
					return false;
				}
				if(!other_value.getaddr().isBound()) {
					return false;
				}
				if(!addr.match(other_value.getaddr(), legacy)) {
					return false;
				}
				if(!other_value.getport__().isBound()) {
					return false;
				}
				if(!port__.match(other_value.getport__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorUnqualified) {
				return match((ExecutorUnqualified)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorUnqualified.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" addr := ");
				addr.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_ := ");
				port__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorUnqualified match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorUnqualified) {
				log_match((ExecutorUnqualified)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.");
		}

		public void log_match(final ExecutorUnqualified match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !addr.match(match_value.constGetaddr(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".addr");
							addr.log_match(match_value.constGetaddr(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__.match(match_value.constGetport__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_");
							port__.log_match(match_value.constGetport__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetname(), legacy);
				TTCN_Logger.log_event_str("{ addr := ");
				addr.log_match(match_value.constGetaddr(), legacy);
				TTCN_Logger.log_event_str("{ port_ := ");
				port__.log_match(match_value.constGetport__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				name.encode_text(text_buf);
				addr.encode_text(text_buf);
				port__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorUnqualified_reason_template();
				reason.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				addr = new TitanCharString_template();
				addr.decode_text(text_buf);
				port__ = new TitanInteger_template();
				port__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorUnqualified_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorUnqualified_template temp = new ExecutorUnqualified_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutorUnqualified has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getname().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getaddr().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getname().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("addr".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getaddr().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorUnqualified: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutorUnqualified");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorUnqualified" : name, legacy);
				this.name.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorUnqualified" : name, legacy);
				this.addr.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorUnqualified" : name, legacy);
				this.port__.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorUnqualified" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorUnqualified" : name));
		}
	}
	public static void ExecutorUnqualified_encoder(final ExecutorUnqualified input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorUnqualified_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorUnqualified_decoder( final TitanOctetString input_stream, final ExecutorUnqualified output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorUnqualified_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_failPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_failPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_failPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_failPercent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StartFunction_function__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StartFunction_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StartFunction_function__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StartFunction_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_timerEvent_encoder(final TimerEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_timerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_timerEvent_decoder( final TitanOctetString input_stream, final TimerEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_timerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TitanLog_sequence__list_0_entityId_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_sequence__list_0_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_sequence__list_0_entityId_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_sequence__list_0_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class DefaultEnd extends Base_Type {
		public enum enum_type {
			break__ (0),
			finish (1),
			repeat__ (2),
			UNKNOWN_VALUE(3),
			UNBOUND_VALUE(4);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return break__;
				case 1:  return finish;
				case 2:  return repeat__;
				case 3:  return UNKNOWN_VALUE;
				case 4:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public DefaultEnd() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public DefaultEnd(final DefaultEnd otherValue) {
			enum_value = otherValue.enum_value;
		}

		public DefaultEnd(final DefaultEnd.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public DefaultEnd(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `DefaultEnd' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public DefaultEnd assign(final DefaultEnd otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public DefaultEnd assign(final Base_Type otherValue){
			if( otherValue instanceof DefaultEnd ) {
				return assign((DefaultEnd) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public DefaultEnd assign(final DefaultEnd.enum_type otherValue){
			return assign( new DefaultEnd(otherValue) );
		}

		//originally operator=
		public DefaultEnd assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `DefaultEnd'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final DefaultEnd otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof DefaultEnd) {
				return operatorEquals( (DefaultEnd) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEnd.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final DefaultEnd.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final DefaultEnd otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final DefaultEnd.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final DefaultEnd.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final DefaultEnd otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final DefaultEnd.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final DefaultEnd otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final DefaultEnd.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final DefaultEnd otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final DefaultEnd.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final DefaultEnd otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final DefaultEnd.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final DefaultEnd enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("break__".equals(strPar) || "break_".equals(strPar)) {
				return enum_type.break__;
			}
			if ("finish".equals(strPar)) {
				return enum_type.finish;
			}
			if ("repeat__".equals(strPar) || "repeat_".equals(strPar)) {
				return enum_type.repeat__;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.DefaultEnd");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.DefaultEnd.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.DefaultEnd.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.DefaultEnd.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class DefaultEnd_template extends Base_Template {
		// single_value
		private DefaultEnd.enum_type single_value;
		// value_list part
		private ArrayList<DefaultEnd_template> value_list;

		private void copy_template(final DefaultEnd_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<DefaultEnd_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final DefaultEnd_template temp = new DefaultEnd_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type DefaultEnd.");
			}
		}

		public DefaultEnd_template() {
			// do nothing
		}

		public DefaultEnd_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public DefaultEnd_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!DefaultEnd.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type DefaultEnd with unknown numeric value "+ otherValue +".");
			}
			single_value = DefaultEnd.enum_type.getValue(otherValue);
		}

		public DefaultEnd_template(final DefaultEnd otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == DefaultEnd.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type DefaultEnd. ");
			}
			single_value = otherValue.enum_value;
		}

		public DefaultEnd_template(final DefaultEnd_template otherValue) {
			copy_template(otherValue);
		}

		public DefaultEnd_template(final DefaultEnd.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != DefaultEnd.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public DefaultEnd_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public DefaultEnd_template assign(final int otherValue) {
			if (!DefaultEnd.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type DefaultEnd.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public DefaultEnd_template assign(final DefaultEnd.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public DefaultEnd_template assign(final DefaultEnd_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public DefaultEnd_template assign(final DefaultEnd otherValue){
			if (otherValue.enum_value == DefaultEnd.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type DefaultEnd to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public DefaultEnd_template assign(final Base_Type otherValue){
			if( otherValue instanceof DefaultEnd ) {
				return assign((DefaultEnd) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
		}

		@Override
		public DefaultEnd_template assign(final Base_Template otherValue){
			if( otherValue instanceof DefaultEnd_template ) {
				return assign((DefaultEnd_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final DefaultEnd.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final DefaultEnd.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type DefaultEnd.");
			}
		}

		// originally match
		public boolean match(final DefaultEnd otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final DefaultEnd otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof DefaultEnd ) {
				return match((DefaultEnd) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
		}

		public DefaultEnd valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type DefaultEnd.");
			}
			return new DefaultEnd(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type DefaultEnd.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<DefaultEnd_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new DefaultEnd_template());
			}
		}

		public DefaultEnd_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type DefaultEnd.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type DefaultEnd.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type DefaultEnd.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(DefaultEnd.enum2str(single_value), DefaultEnd.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultEnd) {
				log_match((DefaultEnd)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEnd.");
		}
		public void log_match(final DefaultEnd match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final DefaultEnd.enum_type enum_value = DefaultEnd.str_to_enum(param.get_enumerated());
				if (!DefaultEnd.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.DefaultEnd.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.DefaultEnd");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.DefaultEnd.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!DefaultEnd.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.DefaultEnd.", temp));
				}
				single_value = DefaultEnd.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<DefaultEnd_template>(size);
				for (int i = 0; i < size; i++) {
					final DefaultEnd_template temp = new DefaultEnd_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.DefaultEnd.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.DefaultEnd" : name));
		}
	}
	public static void DefaultEnd_encoder(final DefaultEnd input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEnd_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEnd_decoder( final TitanOctetString input_stream, final DefaultEnd output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEnd_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Queue_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Categorized extends Base_Type {
		private final TitanInteger category; //Integer_Type
		private final TitanCharString text; //CharString_Type

		public Categorized() {
			this.category = new TitanInteger();
			this.text = new TitanCharString();
		}

		public Categorized(final TitanInteger category, final TitanCharString text ) {
			this.category = new TitanInteger( category );
			this.text = new TitanCharString( text );
		}

		public Categorized( final Categorized otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Categorized.");
			}
			category = new TitanInteger();
			text = new TitanCharString();
			assign( otherValue );
		}

		public Categorized assign(final Categorized otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Categorized");
			}

			if (otherValue != this) {
				if ( otherValue.getcategory().isBound() ) {
					this.category.assign( otherValue.getcategory() );
				} else {
					this.category.cleanUp();
				}
				if ( otherValue.gettext().isBound() ) {
					this.text.assign( otherValue.gettext() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Categorized assign(final Base_Type otherValue) {
			if (otherValue instanceof Categorized ) {
				return assign((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Categorized", otherValue));
		}

		public void cleanUp() {
			category.cleanUp();
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( category.isBound() ) { return true; }
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !category.isValue() ) { return false; }
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Categorized otherValue) {
			if ( !this.category.operatorEquals( otherValue.category ) ) { return false; }
			if ( !this.text.operatorEquals( otherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Categorized ) {
				return operatorEquals((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Categorized", otherValue));
		}

		public TitanInteger getcategory() {
			return category;
		}

		public TitanInteger constGetcategory() {
			return category;
		}

		public TitanCharString gettext() {
			return text;
		}

		public TitanCharString constGettext() {
			return text;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" category := ");
			category.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Categorized has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcategory().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("category".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcategory().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Categorized: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Categorized");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (category.isBound()) {
				category.set_implicit_omit();
			}
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			category.encode_text(text_buf);
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			category.decode_text(text_buf);
			text.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Categorized_template extends Base_Template {

		private TitanInteger_template category; //Integer_Type
		private TitanCharString_template text; //CharString_Type
		//originally value_list/list_value
		private List<Categorized_template> list_value;

		public TitanInteger_template getcategory() {
			setSpecific();
			return category;
		}

		public TitanInteger_template constGetcategory() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field category of a non-specific template of type @TitanLoggerApi.Categorized.");
			}
			return category;
		}

		public TitanCharString_template gettext() {
			setSpecific();
			return text;
		}

		public TitanCharString_template constGettext() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.Categorized.");
			}
			return text;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				category = new TitanInteger_template();
				text = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					category.assign(template_sel.ANY_VALUE);
					text.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Categorized_template() {
			// do nothing
		}

		public Categorized_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Categorized_template( final Categorized otherValue ) {
			copyValue(otherValue);
		}

		public Categorized_template( final Categorized_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Categorized_template( final Optional<Categorized> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Categorized from an unbound optional field.");
			}
		}

		//originally operator=
		public Categorized_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Categorized_template assign( final Categorized other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Categorized_template assign( final Categorized_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Categorized_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Categorized) {
				return assign((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Categorized' can not be cast to {1}", otherValue));
		}

		@Override
		public Categorized_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Categorized_template) {
				return assign((Categorized_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Categorized' can not be cast to {1}_template", otherValue));
		}

		public Categorized_template assign( final Optional<Categorized> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Categorized.");
			}
			return this;
		}

		private void copyValue(final Categorized other_value) {
			if (other_value.getcategory().isBound()) {
				getcategory().assign(other_value.getcategory());
			} else {
				getcategory().cleanUp();
			}
			if (other_value.gettext().isBound()) {
				gettext().assign(other_value.gettext());
			} else {
				gettext().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Categorized_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcategory().get_selection()) {
					getcategory().cleanUp();
				} else {
					getcategory().assign(other_value.getcategory());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettext().get_selection()) {
					gettext().cleanUp();
				} else {
					gettext().assign(other_value.gettext());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Categorized_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Categorized_template temp = new Categorized_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Categorized.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Categorized valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Categorized.");
			}
			final Categorized ret_val = new Categorized();
			if (category.isBound()) {
				ret_val.getcategory().assign(category.valueOf());
			}
			if (text.isBound()) {
				ret_val.gettext().assign(text.valueOf());
			}
			return ret_val;
		}

		public Categorized_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Categorized.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Categorized.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Categorized.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Categorized_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Categorized_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (category.isBound()) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!category.isValue()) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Categorized other_value) {
			return match(other_value, false);
		}

		public boolean match(final Categorized other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getcategory().isBound()) {
					return false;
				}
				if(!category.match(other_value.getcategory(), legacy)) {
					return false;
				}
				if(!other_value.gettext().isBound()) {
					return false;
				}
				if(!text.match(other_value.gettext(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Categorized) {
				return match((Categorized)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Categorized.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" category := ");
				category.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Categorized match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Categorized) {
				log_match((Categorized)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Categorized.");
		}

		public void log_match(final Categorized match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !category.match(match_value.constGetcategory(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".category");
							category.log_match(match_value.constGetcategory(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !text.match(match_value.constGettext(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGettext(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ category := ");
				category.log_match(match_value.constGetcategory(), legacy);
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGettext(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				category.encode_text(text_buf);
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				category = new TitanInteger_template();
				category.decode_text(text_buf);
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Categorized_template>(size);
				for (int i = 0; i < size; i++) {
					final Categorized_template temp = new Categorized_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Categorized.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Categorized has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcategory().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettext().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("category".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcategory().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("text".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettext().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Categorized: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Categorized");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.category.check_restriction(restriction, name == null ? "@TitanLoggerApi.Categorized" : name, legacy);
				this.text.check_restriction(restriction, name == null ? "@TitanLoggerApi.Categorized" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Categorized" : name));
		}
	}
	public static void Categorized_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Categorized_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Categorized_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Categorized_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Port__Queue_address___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Port__Queue_address___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Port__Queue_address___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Port__Queue_address___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ExecutorEvent_choice_extcommandSuccess_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorEvent_choice_extcommandSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorEvent_choice_extcommandSuccess_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorEvent_choice_extcommandSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLog_sequence__list extends Base_Type {

		private List<TitanLog_sequence__list_0> valueElements;

		public TitanLog_sequence__list() {
			// do nothing
		}

		public TitanLog_sequence__list( final TitanLog_sequence__list otherValue ) {
			otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			valueElements = copyList( otherValue.valueElements );
		}

		public TitanLog_sequence__list(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanLog_sequence__list_0>();
		}

		private static final List<TitanLog_sequence__list_0> copyList( final List<TitanLog_sequence__list_0> srcList ) {
			if ( srcList == null ) {
				return null;
			}

			final List<TitanLog_sequence__list_0> newList = new ArrayList<TitanLog_sequence__list_0>( srcList.size() );
			for (final TitanLog_sequence__list_0 srcElem : srcList) {
				final TitanLog_sequence__list_0 newElem = getUnboundElem();
				if (srcElem.isBound()) {
					newElem.assign( srcElem );
				}
				newList.add( ( newElem ) );
			}
			return newList;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return valueElements != null;
		}

		public void mustBound( final String aErrorMessage ) {
			if ( !isBound() ) {
				throw new TtcnError( aErrorMessage );
			}
		}

		@Override
		public boolean isValue() {
			if (valueElements == null) {
				return false;
			}
			for (int i=0; i < valueElements.size(); i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(i);
				if (elem == null || !elem.isValue()) {
					return false;
				}
			}
			return true;
		}


		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list) {
				return operatorEquals((TitanLog_sequence__list)otherValue);
			}
			throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLog_sequence__list.");
		}

		//originally operator==
		public boolean operatorEquals( final TitanLog_sequence__list otherValue ) {
			mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");

			final int size = valueElements.size();
			if ( size != otherValue.valueElements.size() ) {
				return false;
			}

			for ( int i = 0; i < size; i++ ) {
				final TitanLog_sequence__list_0 leftElem = valueElements.get( i );
				final TitanLog_sequence__list_0 rightElem = otherValue.valueElements.get( i );
				if (leftElem.isBound()) {
					if (rightElem.isBound()) {
						if ( !leftElem.operatorEquals( rightElem ) ) {
							return false;
						}
					} else {
						return false;
					}
				} else if (rightElem.isBound()) {
					return false;
				}
			}

			return true;
		}

		@Override
		public TitanLog_sequence__list assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list) {
				return assign((TitanLog_sequence__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
		}

		//originally operator=
		public TitanLog_sequence__list assign( final TitanLog_sequence__list aOtherValue ) {
			aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLog.sequence_list." );

			valueElements = copyList( aOtherValue.valueElements );
			return this;
		}

		public TitanLog_sequence__list assign(final TitanNull_Type nullValue) {
			valueElements = new ArrayList<TitanLog_sequence__list_0>();
			return this;
		}

		//originally operator+
		public TitanLog_sequence__list concatenate(final TitanLog_sequence__list other_value) {
			if (valueElements == null || other_value.valueElements == null) {
				throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLog.sequence_list concatenation.");
			}
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i < valueElements.size(); i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			for (int i = 0; i < other_value.valueElements.size(); i++) {
				final TitanLog_sequence__list_0 elem = other_value.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list concatenate(final TitanNull_Type nullValue) {
			return new TitanLog_sequence__list(this);
		}

		//originally operator<<=
		public TitanLog_sequence__list rotateLeft(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate left operator.");
			return rotateLeft(rotate_count.getInt());
		}

		//originally operator<<=
		public TitanLog_sequence__list rotateLeft(final int rotate_count) {
			return rotateRight(-rotate_count);
		}

		//originally operator>>=
		public TitanLog_sequence__list rotateRight(final TitanInteger rotate_count) {
			rotate_count.mustBound("Unbound integer operand of rotate right operator.");
			return rotateRight(rotate_count.getInt());
		}

		//originally operator>>=
		public TitanLog_sequence__list rotateRight(final int rotate_count) {
			if (valueElements == null) {
				throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			final int size = valueElements.size();
			if (size == 0) {
				return new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			}
			int rc;
			if (rotate_count >= 0) {
				rc = rotate_count % size;
			} else {
				rc = size - ((-rotate_count) % size);
			}
			if (rc == 0) {
				return new TitanLog_sequence__list(this);
			}
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int i = size - rc; i < size; i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			for (int i = 0; i < size - rc; i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			return ret_val;
		}

		//originally clean_up
		public void cleanUp() {
			valueElements = null;
		}

		//originally get_at(int)
		public TitanLog_sequence__list_0 getAt( final int index_value ) {
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list using a negative index: "+index_value+".");
			}

			if (valueElements == null || index_value >= valueElements.size() ) {
				//increase list size
				setSize(index_value + 1);
			}

			if ( valueElements.get( index_value ) == null ) {
				final TitanLog_sequence__list_0 newElem = getUnboundElem();
				valueElements.set( index_value, newElem );
			}
			return valueElements.get( index_value );
		}

		//originally get_at(const INTEGER&)
		public TitanLog_sequence__list_0 getAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list." );
			return getAt( index_value.getInt() );
		}

		//originally get_at(int) const
		public TitanLog_sequence__list_0 constGetAt( final int index_value ) {
			if ( !isBound() ) {
				throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLog.sequence_list." );
			}
			if (index_value < 0) {
				throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list using a negative index: "+index_value+".");
			}
			final int nofElements = n_elem().getInt();
			if ( index_value >= nofElements ) {
				throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLog.sequence_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
			}

			final TitanLog_sequence__list_0 elem = valueElements.get( index_value );
			return ( elem != null ) ? elem : getUnboundElem();
		}

		//originally get_at(const INTEGER&) const
		public TitanLog_sequence__list_0 constGetAt(final TitanInteger index_value) {
			index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list." );
			return constGetAt( index_value.getInt() );
		}

		public TitanInteger sizeOf() {
			mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			return new TitanInteger(valueElements.size());
		}

		public TitanInteger n_elem() {
			return sizeOf();
		}

		public TitanInteger lengthOf() {
			mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
				final TitanLog_sequence__list_0 elem = valueElements.get( i );
				if ( elem != null && elem.isBound() ) {
					return new TitanInteger(i + 1);
				}
			}
			return new TitanInteger(0);
		}

		public void setSize(final int newSize) {
			if (newSize < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			if ( valueElements == null ) {
				valueElements = new ArrayList<TitanLog_sequence__list_0>();
			}
			if (newSize > valueElements.size()) {
				for ( int i = valueElements.size(); i < newSize; i++ ) {
					valueElements.add( new TitanLog_sequence__list_0() );
				}
			} else if (newSize < valueElements.size()) {
				while(valueElements.size() > newSize) {
					valueElements.remove(valueElements.size()-1);
				}
			}
		}

		private static TitanLog_sequence__list_0 getUnboundElem() {
			return new TitanLog_sequence__list_0();
		}
		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */

		@Override
		public String toString() {
			if (!isBound()) {
				return "<unbound>";
			}
			final StringBuilder sb = new StringBuilder();
			sb.append('{');
			final int size = ( valueElements == null ) ? 0 : valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					sb.append(',');
				}
				sb.append(valueElements.get(i).toString());
			}
			sb.append('}');
			return sb.toString();
		}

		public TitanLog_sequence__list substr(final int index, final int returncount) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLog.sequence_list","element");
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int i=0; i<returncount; i++) {
				if (valueElements.get(i+index) != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(valueElements.get(i+index)));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list repl) {
			if (valueElements == null) {
				throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			if (repl.valueElements == null) {
				throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLog.sequence_list","element");
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int i = 0; i < index; i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			for (int i = 0; i < repl.valueElements.size(); i++) {
				final TitanLog_sequence__list_0 elem = repl.valueElements.get(i);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			for (int i = 0; i < valueElements.size() - index - len; i++) {
				final TitanLog_sequence__list_0 elem = valueElements.get(index + i + len);
				if (elem != null) {
					ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len, repl.valueOf());
		}

		public TitanLog_sequence__list replace(final int index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index, len.getInt(), repl.valueOf());
		}

		public TitanLog_sequence__list replace(final TitanInteger index, final int len, final TitanLog_sequence__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len, repl.valueOf());
		}

		public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return replace(index.getInt(), len.getInt(), repl.valueOf());
		}
		public void log() {
			if (valueElements == null) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_event_str("{ ");
			final int size = valueElements.size();
			for (int i = 0; i < size; i++ ) {
				if ( i > 0 ) {
					TTCN_Logger.log_event_str(", ");
				}
				valueElements.get(i).log();
			}
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record of value");
			switch (param.get_operation_type()) {
			case OT_ASSIGN:
				if (param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
					assign(TitanNull_Type.NULL_VALUE);
					return;
				}
				switch (param.get_type()) {
				case MP_Value_List:
					setSize(param.get_size());
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(i).set_param(current);
							if (!constGetAt(i).isBound()) {
								valueElements.set(i, null);
							}
						}
					}
					break;
				case MP_Indexed_List:
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						getAt(current.get_id().get_index()).set_param(current);
						if (!constGetAt(current.get_id().get_index()).isBound()) {
							valueElements.set(i, null);
						}
					}
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLog.sequence_list");
				}
				break;
			case OT_CONCAT:
				switch (param.get_type()) {
				case MP_Value_List: {
					if (!isBound()) {
						assign(TitanNull_Type.NULL_VALUE);
					}
					final int start_idx = lengthOf().getInt();
					for (int i = 0; i < param.get_size(); i++) {
						final Module_Parameter current = param.get_elem(i);
						if (current.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getAt(start_idx + i).set_param(current);
						}
					}
					break;
				}
				case MP_Indexed_List:
					param.error("Cannot concatenate an indexed value list");
					break;
				default:
					param.type_error("record of value", "@TitanLoggerApi.TitanLog.sequence_list");
				}
				break;
			default:
				throw new TtcnError("Internal error: Unknown operation type");
			}
		}

		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanLog_sequence__list_0>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanLog_sequence__list_0 temp2 = new TitanLog_sequence__list_0();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLog_sequence__list_template extends Record_Of_Template {

		//originally single_value/value_elements
		private List<TitanLog_sequence__list_0_template> value_elements;

		//originally value_list/list_value
		private List<TitanLog_sequence__list_template> list_value;

		private final match_function_t match_function_specific = new match_function_t() {
			@Override
			public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
				return match_index((TitanLog_sequence__list)value_ptr, value_index, (TitanLog_sequence__list_template)template_ptr, template_index, legacy);
			}
		};

		public TitanLog_sequence__list_template() {
			// do nothing
		}

		public TitanLog_sequence__list_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLog_sequence__list_template( final TitanLog_sequence__list otherValue ) {
			copy_value( otherValue );
		}

		public TitanLog_sequence__list_template( final TitanLog_sequence__list_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLog_sequence__list_template( final Optional<TitanLog_sequence__list> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list from an unbound optional field.");
			}
		}

		public TitanLog_sequence__list_template( final TitanNull_Type nullValue ) {
			super( template_sel.SPECIFIC_VALUE );
			value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
		}

		private void copy_value(final TitanLog_sequence__list other_value) {
			if (!other_value.isBound()) {
				throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLog.sequence_list with an unbound value.");
			}
			value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
			final int otherSize = other_value.valueElements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanLog_sequence__list_0_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanLog_sequence__list_0_template() );
				}
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLog_sequence__list_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
				final int otherSize = other_value.value_elements.size();
				for (int elem_count = 0; elem_count < otherSize; elem_count++) {
					if (other_value.constGetAt(elem_count).isBound()) {
						value_elements.add( new TitanLog_sequence__list_0_template(other_value.constGetAt(elem_count)) );
					} else {
						value_elements.add( new TitanLog_sequence__list_0_template() );
					}
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_sequence__list_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLog_sequence__list_template temp = new TitanLog_sequence__list_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		// originally match
		public boolean match(final TitanLog_sequence__list other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final TitanLog_sequence__list other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < list_value.size(); i++) {
					if(list_value.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
		}

		private boolean match_index(final TitanLog_sequence__list value_ptr, final int value_index, final TitanLog_sequence__list_template template_ptr, final int template_index, final boolean legacy) {
			if (value_index >= 0) {
				return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
			} else {
				return template_ptr.value_elements.get(template_index).is_any_or_omit();
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLog_sequence__list) {
				return match((TitanLog_sequence__list)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < list_value.size(); i++) {
						if (list_value.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		//originally operator=
		public TitanLog_sequence__list_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_template assign( final TitanLog_sequence__list other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_template assign( final TitanLog_sequence__list_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLog_sequence__list_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list) {
				return assign((TitanLog_sequence__list)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
		}

		@Override
		public TitanLog_sequence__list_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_template) {
				return assign((TitanLog_sequence__list_template)otherValue);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_template.");
		}

		public TitanLog_sequence__list_template assign( final Optional<TitanLog_sequence__list> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copy_value(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			return this;
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				value_elements.clear();
				value_elements = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value.clear();
				list_value = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl.valueOf());
		}

		public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			if (!repl.isValue()) {
				throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
		}

		public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index, len, repl);
		}

		public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list repl) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
			}
			return valueOf().replace(index.getInt(), len.getInt(), repl);
		}

		public TitanLog_sequence__list_0_template getAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list using a negative index: {0}.", index_value ) );
			}

			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if(index_value < value_elements.size()) {

					break;
				}
				// no break
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case UNINITIALIZED_TEMPLATE:
				setSize(index_value + 1);
				break;
			default:
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			return value_elements.get(index_value);
		}

		public TitanLog_sequence__list_0_template getAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}

			return getAt(index_value.getInt());
		}

		public TitanLog_sequence__list_0_template constGetAt(final int index_value) {
			if (index_value < 0) {
				throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list using a negative index: {0}.", index_value ) );
			}

			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.");
			}

			if (index_value >= value_elements.size()) {
				throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLog.sequence_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
			}

			return value_elements.get(index_value);
		}

		public TitanLog_sequence__list_0_template constGetAt(final TitanInteger index_value) {
			if (!index_value.isBound()) {
				throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}

			return constGetAt(index_value.getInt());
		}

		private int get_length_for_concat(final AtomicBoolean is_any_value) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return value_elements.size();
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					if (templateSelection == template_sel.ANY_VALUE) {
						// ? => { * }
						is_any_value.set( true );
						return 1;
					}
					throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
				case RANGE_LENGTH_RESTRICTION:
					if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
						throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
					}
					// else fall through (range length restriction is allowed if the minimum
					// and maximum value are the same)
				case SINGLE_LENGTH_RESTRICTION:
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
				}
			default:
				throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
			}
		}

		private int get_length_for_concat(final TitanLog_sequence__list operand) {
			operand.mustBound("Operand of record of template concatenation is an unbound value.");
			return operand.valueElements.size();
		}


		private int get_length_for_concat(final template_sel operand) {
			if (operand == template_sel.ANY_VALUE) {
				// ? => { * }
				return 1;
			}
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}

		//TODO: simplify, just use value_elements.add()
		private void concat(final AtomicInteger pos, final TitanLog_sequence__list_template operand) {
			// all errors should have already been caught by the operand's
			// get_length_for_concat() call;
			// the result template (this) should already be set to SPECIFIC_VALUE and
			// single_value.value_elements should already be allocated
			switch (operand.templateSelection) {
			case SPECIFIC_VALUE:
				for (int i = 0; i < operand.value_elements.size(); ++i) {
					value_elements.set( pos.get() + i, new TitanLog_sequence__list_0_template(operand.value_elements.get(i)) );
				}
				pos.addAndGet( operand.value_elements.size() );
				break;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				switch (operand.length_restriction_type) {
				case NO_LENGTH_RESTRICTION:
					// ? => { * }
					value_elements.set( pos.get(), new TitanLog_sequence__list_0_template( template_sel.ANY_OR_OMIT ) );
					pos.incrementAndGet();
					break;
				case RANGE_LENGTH_RESTRICTION:
				case SINGLE_LENGTH_RESTRICTION: {
					// ? length(N) or * length(N) => { ?, ?, ... ? } N times
					final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
					for (int i = 0; i < N; ++i) {
						value_elements.set( pos.get() + i, new TitanLog_sequence__list_0_template( template_sel.ANY_VALUE ) );
					}
					pos.addAndGet( N );
					break; }
				}
			default:
				break;
			}
		}

		public void setSize(final int new_size) {
			if (new_size < 0) {
				throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			final template_sel old_selection = templateSelection;
			if (old_selection != template_sel.SPECIFIC_VALUE) {
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				value_elements = null;
			}
			if (value_elements == null) {
				value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
			}
			if (new_size > value_elements.size()) {
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanLog_sequence__list_0_template(template_sel.ANY_VALUE) );
					}
				} else {
					for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
						value_elements.add( new TitanLog_sequence__list_0_template() );
					}
				}
			} else if (new_size < value_elements.size()) {
				final int oldSize = value_elements.size();
				for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
					value_elements.remove( new_size );
				}
			}
		}

		public TitanInteger sizeOf() {
			return sizeOf(true);
		}

		public TitanInteger lengthOf() {
			return sizeOf(false);
		}

		public TitanInteger sizeOf(final boolean is_size) {
			final String op_name = is_size ? "size" : "length";
			if (is_ifPresent) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list which has an ifpresent attribute.", op_name ) );
			}
			int min_size;
			boolean has_any_or_none;
			switch (templateSelection)
			{
			case SPECIFIC_VALUE: {
				min_size = 0;
				has_any_or_none = false;
				int elem_count = value_elements.size();
				if (!is_size) {
					while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
						elem_count--;
					}
				}
				for (int i=0; i<elem_count; i++)
				{
					switch (value_elements.get(i).get_selection())
					{
					case OMIT_VALUE:
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing omit element.", op_name ) );
					case ANY_OR_OMIT:
						has_any_or_none = true;
						break;
					default:
						min_size++;
						break;
					}
				}
			} break;
			case OMIT_VALUE:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing omit value.", op_name ) );
			case ANY_VALUE:
			case ANY_OR_OMIT:
				min_size = 0;
				has_any_or_none = true;
				break;
			case VALUE_LIST:
			{
				if (list_value.size()<1) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing an empty list.", op_name ) );
				}
				final int item_size = list_value.get(0).sizeOf(is_size).getInt();
				for (int i = 1; i < list_value.size(); i++) {
					if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
						throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing a value list with different sizes.", op_name ) );
					}
				}
				min_size = item_size;
				has_any_or_none = false;
				break;
			}
			case COMPLEMENTED_LIST:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing complemented list.", op_name ) );
			default:
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLog_sequence__list.", op_name ) );
			}
			return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanLog_sequence__list_0_template"));
		}

		public TitanInteger n_elem() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(value_elements.size());
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing n_elem() operation on a template of type TitanLog_sequence__list containing complemented list.");
			case UNINITIALIZED_TEMPLATE:
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
			case VALUE_LIST:
			case VALUE_RANGE:
			case STRING_PATTERN:
			case SUPERSET_MATCH:
			case SUBSET_MATCH:
			case DECODE_MATCH:
				break;
			}
			throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLog_sequence__list.");
		}

		private boolean matchv(final TitanLog_sequence__list other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			final int value_length = other_value.sizeOf().getInt();
			if (!match_length(value_length)) {
				return false;
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).matchv(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLog_sequence__list.");
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (!value_elements.get(elem_count).isValue()) {
					return false;
				}
			}
			return true;
		}

		public void setType(final template_sel template_type, final int list_length) {
			cleanUp();
			switch (template_type) {
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_sequence__list_template>( list_length );
				for (int list_count = 0; list_count < list_length; list_count++) {
					list_value.add( new TitanLog_sequence__list_template() );
				}
				break;
			default:
				throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			set_selection(template_type);
		}

		public TitanLog_sequence__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			return list_value.get(list_index);
		}

		public TitanLog_sequence__list_template get_list_item(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			if (list_index < 0) {
				throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLog.sequence_list using a negative index ({0}).", list_index ) );
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			return list_value.get( list_index );
		}

		public TitanLog_sequence__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

		public void log_match(final TitanLog_sequence__list match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog_sequence__list) {
				log_match((TitanLog_sequence__list)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.");
		}

		public void log_match(final TitanLog_sequence__list match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
							if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
								TTCN_Logger.log_logmatch_info("[%d]", elem_count);
								value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						log_match_length(value_elements.size());
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
				TTCN_Logger.log_event_str("{ ");
				for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
					if (elem_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
				}
				TTCN_Logger.log_event_str(" }");
				log_match_length(value_elements.size());
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
				}
				value_elements = new ArrayList<TitanLog_sequence__list_0_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanLog_sequence__list_0_template temp2 = new TitanLog_sequence__list_0_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_sequence__list_template temp2 = new TitanLog_sequence__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record of template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Indexed_List:
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					setSize(0);
				}
				for (int i = 0; i < param.get_size(); i++) {
					getAt(param.get_elem(i).get_id().get_index()).set_param(param.get_elem(i));
				}
				break;
			case MP_Value_List: {
				setSize(param.get_size());
				int current_index = 0;
				for (int i = 0; i < param.get_size(); i++) {
					switch (param.get_elem(i).get_type()) {
					case MP_NotUsed:
						current_index++;
						break;
					case MP_Permutation_Template: {
						final int permutation_start_index = current_index;
						final Module_Parameter param_i = param.get_elem(i);
						for (int perm_i = 0; perm_i < param_i.get_size(); perm_i++) {
							getAt(current_index).set_param(param_i.get_elem(perm_i));
							current_index++;
						}
						final int permutation_end_index = current_index - 1;
						add_permutation(permutation_start_index, permutation_end_index);
						break;
					}
					default:
						getAt(current_index).set_param(param.get_elem(i));
						current_index++;
					}
				}
				break;
			}
			default:
				param.type_error("record of template", "@TitanLoggerApi.TitanLog.sequence_list");
			}
			is_ifPresent = param.get_ifpresent();
			set_length_range(param);
		}

		@Override
		public boolean get_istemplate_kind(final String type) {
			if ("AnyElement".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
						return true;
					}
				}
				return false;
			} else if ("AnyElementsOrNone".equals(type)) {
				if (templateSelection != template_sel.SPECIFIC_VALUE) {
					return false;
				}
				for (int i = 0; i < value_elements.size(); i++) {
					if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
						return true;
					}
				}
				return false;
			} else if ("permutation".equals(type)) {
				return get_number_of_permutations() != 0;
			} else if ("length".equals(type)) {
				return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
			} else {
				return super.get_istemplate_kind(type);
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && (restriction==template_res.TR_VALUE)) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection==template_sel.OMIT_VALUE) {
					return;
				}
				// no break
			case TR_VALUE:
				if (templateSelection!=template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				for (int i=0; i<value_elements.size(); i++)
					value_elements.get(i).check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLog.sequence_list" : name, false);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) return;
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLog.sequence_list" : name));
		}
	}
	public static void TitanLog_sequence__list_encoder(final TitanLog_sequence__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_sequence__list_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_sequence__list_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_sequence__list_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__out_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void MatchingEvent_choice_matchingProblem_encoder(final MatchingProblemType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_matchingProblem_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_matchingProblem_decoder( final TitanOctetString input_stream, final MatchingProblemType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_matchingProblem_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void DefaultEvent_choice_defaultopActivate_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(DefaultEvent_choice_defaultopActivate_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger DefaultEvent_choice_defaultopActivate_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(DefaultEvent_choice_defaultopActivate_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__out_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__out_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__out_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__out_compref_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void StatisticsType_choice_verdictStatistics_error___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_choice_verdictStatistics_error___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_choice_verdictStatistics_error___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_choice_verdictStatistics_error___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FunctionEvent_choice_unqualified_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_unqualified_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_unqualified_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_unqualified_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelPTC_status_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelPTC_status_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelPTC_status_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelPTC_status_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FinalVerdictType_choice_info_encoder(final FinalVerdictInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FinalVerdictType_choice_info_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FinalVerdictType_choice_info_decoder( final TitanOctetString input_stream, final FinalVerdictInfo output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FinalVerdictType_choice_info_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_unqualifiedTimer_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_unqualifiedTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_unqualifiedTimer_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_unqualifiedTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__discard_incoming_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__discard_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__discard_incoming_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__discard_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void FunctionEvent_choice_random_retval_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_random_retval_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_random_retval_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_random_retval_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutionSummaryType extends Base_Type {
		private final TitanInteger numberOfTestcases; //Integer_Type
		private final TitanCharString overallStatistics; //CharString_Type

		public ExecutionSummaryType() {
			this.numberOfTestcases = new TitanInteger();
			this.overallStatistics = new TitanCharString();
		}

		public ExecutionSummaryType(final TitanInteger numberOfTestcases, final TitanCharString overallStatistics ) {
			this.numberOfTestcases = new TitanInteger( numberOfTestcases );
			this.overallStatistics = new TitanCharString( overallStatistics );
		}

		public ExecutionSummaryType( final ExecutionSummaryType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			numberOfTestcases = new TitanInteger();
			overallStatistics = new TitanCharString();
			assign( otherValue );
		}

		public ExecutionSummaryType assign(final ExecutionSummaryType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutionSummaryType");
			}

			if (otherValue != this) {
				if ( otherValue.getnumberOfTestcases().isBound() ) {
					this.numberOfTestcases.assign( otherValue.getnumberOfTestcases() );
				} else {
					this.numberOfTestcases.cleanUp();
				}
				if ( otherValue.getoverallStatistics().isBound() ) {
					this.overallStatistics.assign( otherValue.getoverallStatistics() );
				} else {
					this.overallStatistics.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutionSummaryType assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType ) {
				return assign((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutionSummaryType", otherValue));
		}

		public void cleanUp() {
			numberOfTestcases.cleanUp();
			overallStatistics.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( numberOfTestcases.isBound() ) { return true; }
			if ( overallStatistics.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !numberOfTestcases.isValue() ) { return false; }
			if ( !overallStatistics.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutionSummaryType otherValue) {
			if ( !this.numberOfTestcases.operatorEquals( otherValue.numberOfTestcases ) ) { return false; }
			if ( !this.overallStatistics.operatorEquals( otherValue.overallStatistics ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType ) {
				return operatorEquals((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutionSummaryType", otherValue));
		}

		public TitanInteger getnumberOfTestcases() {
			return numberOfTestcases;
		}

		public TitanInteger constGetnumberOfTestcases() {
			return numberOfTestcases;
		}

		public TitanCharString getoverallStatistics() {
			return overallStatistics;
		}

		public TitanCharString constGetoverallStatistics() {
			return overallStatistics;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" numberOfTestcases := ");
			numberOfTestcases.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" overallStatistics := ");
			overallStatistics.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutionSummaryType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnumberOfTestcases().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoverallStatistics().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("numberOfTestcases".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnumberOfTestcases().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("overallStatistics".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoverallStatistics().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutionSummaryType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutionSummaryType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (numberOfTestcases.isBound()) {
				numberOfTestcases.set_implicit_omit();
			}
			if (overallStatistics.isBound()) {
				overallStatistics.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			numberOfTestcases.encode_text(text_buf);
			overallStatistics.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			numberOfTestcases.decode_text(text_buf);
			overallStatistics.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutionSummaryType_template extends Base_Template {

		private TitanInteger_template numberOfTestcases; //Integer_Type
		private TitanCharString_template overallStatistics; //CharString_Type
		//originally value_list/list_value
		private List<ExecutionSummaryType_template> list_value;

		public TitanInteger_template getnumberOfTestcases() {
			setSpecific();
			return numberOfTestcases;
		}

		public TitanInteger_template constGetnumberOfTestcases() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field numberOfTestcases of a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			return numberOfTestcases;
		}

		public TitanCharString_template getoverallStatistics() {
			setSpecific();
			return overallStatistics;
		}

		public TitanCharString_template constGetoverallStatistics() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field overallStatistics of a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			return overallStatistics;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				numberOfTestcases = new TitanInteger_template();
				overallStatistics = new TitanCharString_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					numberOfTestcases.assign(template_sel.ANY_VALUE);
					overallStatistics.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public ExecutionSummaryType_template() {
			// do nothing
		}

		public ExecutionSummaryType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutionSummaryType_template( final ExecutionSummaryType otherValue ) {
			copyValue(otherValue);
		}

		public ExecutionSummaryType_template( final ExecutionSummaryType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutionSummaryType_template( final Optional<ExecutionSummaryType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutionSummaryType from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutionSummaryType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutionSummaryType_template assign( final ExecutionSummaryType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutionSummaryType_template assign( final ExecutionSummaryType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutionSummaryType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType) {
				return assign((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutionSummaryType' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutionSummaryType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutionSummaryType_template) {
				return assign((ExecutionSummaryType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutionSummaryType' can not be cast to {1}_template", otherValue));
		}

		public ExecutionSummaryType_template assign( final Optional<ExecutionSummaryType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			return this;
		}

		private void copyValue(final ExecutionSummaryType other_value) {
			if (other_value.getnumberOfTestcases().isBound()) {
				getnumberOfTestcases().assign(other_value.getnumberOfTestcases());
			} else {
				getnumberOfTestcases().cleanUp();
			}
			if (other_value.getoverallStatistics().isBound()) {
				getoverallStatistics().assign(other_value.getoverallStatistics());
			} else {
				getoverallStatistics().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutionSummaryType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getnumberOfTestcases().get_selection()) {
					getnumberOfTestcases().cleanUp();
				} else {
					getnumberOfTestcases().assign(other_value.getnumberOfTestcases());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getoverallStatistics().get_selection()) {
					getoverallStatistics().cleanUp();
				} else {
					getoverallStatistics().assign(other_value.getoverallStatistics());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutionSummaryType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutionSummaryType_template temp = new ExecutionSummaryType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutionSummaryType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			final ExecutionSummaryType ret_val = new ExecutionSummaryType();
			if (numberOfTestcases.isBound()) {
				ret_val.getnumberOfTestcases().assign(numberOfTestcases.valueOf());
			}
			if (overallStatistics.isBound()) {
				ret_val.getoverallStatistics().assign(overallStatistics.valueOf());
			}
			return ret_val;
		}

		public ExecutionSummaryType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutionSummaryType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutionSummaryType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (numberOfTestcases.isBound()) {
				return true;
			}
			if (overallStatistics.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!numberOfTestcases.isValue()) {
				return false;
			}
			if (!overallStatistics.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutionSummaryType other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutionSummaryType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getnumberOfTestcases().isBound()) {
					return false;
				}
				if(!numberOfTestcases.match(other_value.getnumberOfTestcases(), legacy)) {
					return false;
				}
				if(!other_value.getoverallStatistics().isBound()) {
					return false;
				}
				if(!overallStatistics.match(other_value.getoverallStatistics(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutionSummaryType) {
				return match((ExecutionSummaryType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutionSummaryType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" numberOfTestcases := ");
				numberOfTestcases.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" overallStatistics := ");
				overallStatistics.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutionSummaryType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutionSummaryType) {
				log_match((ExecutionSummaryType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutionSummaryType.");
		}

		public void log_match(final ExecutionSummaryType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !numberOfTestcases.match(match_value.constGetnumberOfTestcases(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".numberOfTestcases");
							numberOfTestcases.log_match(match_value.constGetnumberOfTestcases(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !overallStatistics.match(match_value.constGetoverallStatistics(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".overallStatistics");
							overallStatistics.log_match(match_value.constGetoverallStatistics(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ numberOfTestcases := ");
				numberOfTestcases.log_match(match_value.constGetnumberOfTestcases(), legacy);
				TTCN_Logger.log_event_str("{ overallStatistics := ");
				overallStatistics.log_match(match_value.constGetoverallStatistics(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				numberOfTestcases.encode_text(text_buf);
				overallStatistics.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				numberOfTestcases = new TitanInteger_template();
				numberOfTestcases.decode_text(text_buf);
				overallStatistics = new TitanCharString_template();
				overallStatistics.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutionSummaryType_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutionSummaryType_template temp = new ExecutionSummaryType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutionSummaryType has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getnumberOfTestcases().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getoverallStatistics().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("numberOfTestcases".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getnumberOfTestcases().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("overallStatistics".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getoverallStatistics().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutionSummaryType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutionSummaryType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.numberOfTestcases.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutionSummaryType" : name, legacy);
				this.overallStatistics.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutionSummaryType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutionSummaryType" : name));
		}
	}
	public static void ExecutionSummaryType_encoder(final ExecutionSummaryType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutionSummaryType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutionSummaryType_decoder( final TitanOctetString input_stream, final ExecutionSummaryType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutionSummaryType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Setstate_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Setstate_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Setstate_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Setstate_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void LogEventType_choice_executionSummary_encoder(final ExecutionSummaryType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(LogEventType_choice_executionSummary_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger LogEventType_choice_executionSummary_decoder( final TitanOctetString input_stream, final ExecutionSummaryType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(LogEventType_choice_executionSummary_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerEvent_choice_readTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerEvent_choice_readTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerEvent_choice_readTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerEvent_choice_readTimer_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_check___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_check___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_check___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_check___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimerGuardType_value___encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimerGuardType_value___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimerGuardType_value___decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimerGuardType_value___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void ParallelEvent_choice_parallelPTC__exit_encoder(final PTC__exit input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ParallelEvent_choice_parallelPTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ParallelEvent_choice_parallelPTC__exit_decoder( final TitanOctetString input_stream, final PTC__exit output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ParallelEvent_choice_parallelPTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__discard_target__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__discard_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__discard_target__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__discard_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingEvent extends Base_Type {
		private final MatchingEvent_choice choice; //TTCN3_Choice_Type

		public MatchingEvent() {
			this.choice = new MatchingEvent_choice();
		}

		public MatchingEvent(final MatchingEvent_choice choice ) {
			this.choice = new MatchingEvent_choice( choice );
		}

		public MatchingEvent( final MatchingEvent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingEvent.");
			}
			choice = new MatchingEvent_choice();
			assign( otherValue );
		}

		public MatchingEvent assign(final MatchingEvent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingEvent");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent ) {
				return assign((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingEvent otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent ) {
				return operatorEquals((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingEvent", otherValue));
		}

		public MatchingEvent_choice getchoice() {
			return choice;
		}

		public MatchingEvent_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.MatchingEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.MatchingEvent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingEvent_template extends Base_Template {

		private MatchingEvent_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<MatchingEvent_template> list_value;

		public MatchingEvent_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public MatchingEvent_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.MatchingEvent.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new MatchingEvent_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public MatchingEvent_template() {
			// do nothing
		}

		public MatchingEvent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public MatchingEvent_template( final MatchingEvent otherValue ) {
			copyValue(otherValue);
		}

		public MatchingEvent_template( final MatchingEvent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public MatchingEvent_template( final Optional<MatchingEvent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingEvent from an unbound optional field.");
			}
		}

		//originally operator=
		public MatchingEvent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingEvent_template assign( final MatchingEvent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public MatchingEvent_template assign( final MatchingEvent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public MatchingEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent) {
				return assign((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingEvent_template) {
				return assign((MatchingEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingEvent' can not be cast to {1}_template", otherValue));
		}

		public MatchingEvent_template assign( final Optional<MatchingEvent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingEvent.");
			}
			return this;
		}

		private void copyValue(final MatchingEvent other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final MatchingEvent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<MatchingEvent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final MatchingEvent_template temp = new MatchingEvent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingEvent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingEvent.");
			}
			final MatchingEvent ret_val = new MatchingEvent();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public MatchingEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingEvent) {
				return match((MatchingEvent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingEvent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingEvent) {
				log_match((MatchingEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.");
		}

		public void log_match(final MatchingEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new MatchingEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingEvent_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingEvent_template temp = new MatchingEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.MatchingEvent has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.MatchingEvent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.MatchingEvent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingEvent" : name));
		}
	}
	public static void MatchingEvent_encoder(final MatchingEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_decoder( final TitanOctetString input_stream, final MatchingEvent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Dualface__mapped_value___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__mapped_value___descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__mapped_value___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__mapped_value___descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class Dualface__discard extends Base_Type {
		private final TitanBoolean incoming; //Boolean_Type
		private final TitanCharString target__type; //CharString_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanBoolean unhandled; //Boolean_Type

		public Dualface__discard() {
			this.incoming = new TitanBoolean();
			this.target__type = new TitanCharString();
			this.port__name = new TitanCharString();
			this.unhandled = new TitanBoolean();
		}

		public Dualface__discard(final TitanBoolean incoming, final TitanCharString target__type, final TitanCharString port__name, final TitanBoolean unhandled ) {
			this.incoming = new TitanBoolean( incoming );
			this.target__type = new TitanCharString( target__type );
			this.port__name = new TitanCharString( port__name );
			this.unhandled = new TitanBoolean( unhandled );
		}

		public Dualface__discard( final Dualface__discard otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Dualface_discard.");
			}
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			port__name = new TitanCharString();
			unhandled = new TitanBoolean();
			assign( otherValue );
		}

		public Dualface__discard assign(final Dualface__discard otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Dualface_discard");
			}

			if (otherValue != this) {
				if ( otherValue.getincoming().isBound() ) {
					this.incoming.assign( otherValue.getincoming() );
				} else {
					this.incoming.cleanUp();
				}
				if ( otherValue.gettarget__type().isBound() ) {
					this.target__type.assign( otherValue.gettarget__type() );
				} else {
					this.target__type.cleanUp();
				}
				if ( otherValue.getport__name().isBound() ) {
					this.port__name.assign( otherValue.getport__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( otherValue.getunhandled().isBound() ) {
					this.unhandled.assign( otherValue.getunhandled() );
				} else {
					this.unhandled.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Dualface__discard assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard ) {
				return assign((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_discard", otherValue));
		}

		public void cleanUp() {
			incoming.cleanUp();
			target__type.cleanUp();
			port__name.cleanUp();
			unhandled.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( incoming.isBound() ) { return true; }
			if ( target__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( unhandled.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !incoming.isValue() ) { return false; }
			if ( !target__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !unhandled.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Dualface__discard otherValue) {
			if ( !this.incoming.operatorEquals( otherValue.incoming ) ) { return false; }
			if ( !this.target__type.operatorEquals( otherValue.target__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( otherValue.port__name ) ) { return false; }
			if ( !this.unhandled.operatorEquals( otherValue.unhandled ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard ) {
				return operatorEquals((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_discard", otherValue));
		}

		public TitanBoolean getincoming() {
			return incoming;
		}

		public TitanBoolean constGetincoming() {
			return incoming;
		}

		public TitanCharString gettarget__type() {
			return target__type;
		}

		public TitanCharString constGettarget__type() {
			return target__type;
		}

		public TitanCharString getport__name() {
			return port__name;
		}

		public TitanCharString constGetport__name() {
			return port__name;
		}

		public TitanBoolean getunhandled() {
			return unhandled;
		}

		public TitanBoolean constGetunhandled() {
			return unhandled;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(4);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" incoming := ");
			incoming.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" target_type := ");
			target__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" unhandled := ");
			unhandled.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.Dualface_discard has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getincoming().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettarget__type().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getunhandled().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("incoming".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getincoming().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("target_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettarget__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("unhandled".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getunhandled().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Dualface_discard: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.Dualface_discard");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (incoming.isBound()) {
				incoming.set_implicit_omit();
			}
			if (target__type.isBound()) {
				target__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (unhandled.isBound()) {
				unhandled.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			incoming.encode_text(text_buf);
			target__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			unhandled.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			incoming.decode_text(text_buf);
			target__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			unhandled.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class Dualface__discard_template extends Base_Template {

		private TitanBoolean_template incoming; //Boolean_Type
		private TitanCharString_template target__type; //CharString_Type
		private TitanCharString_template port__name; //CharString_Type
		private TitanBoolean_template unhandled; //Boolean_Type
		//originally value_list/list_value
		private List<Dualface__discard_template> list_value;

		public TitanBoolean_template getincoming() {
			setSpecific();
			return incoming;
		}

		public TitanBoolean_template constGetincoming() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field incoming of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			return incoming;
		}

		public TitanCharString_template gettarget__type() {
			setSpecific();
			return target__type;
		}

		public TitanCharString_template constGettarget__type() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field target_type of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			return target__type;
		}

		public TitanCharString_template getport__name() {
			setSpecific();
			return port__name;
		}

		public TitanCharString_template constGetport__name() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			return port__name;
		}

		public TitanBoolean_template getunhandled() {
			setSpecific();
			return unhandled;
		}

		public TitanBoolean_template constGetunhandled() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field unhandled of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			return unhandled;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				incoming = new TitanBoolean_template();
				target__type = new TitanCharString_template();
				port__name = new TitanCharString_template();
				unhandled = new TitanBoolean_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					incoming.assign(template_sel.ANY_VALUE);
					target__type.assign(template_sel.ANY_VALUE);
					port__name.assign(template_sel.ANY_VALUE);
					unhandled.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public Dualface__discard_template() {
			// do nothing
		}

		public Dualface__discard_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public Dualface__discard_template( final Dualface__discard otherValue ) {
			copyValue(otherValue);
		}

		public Dualface__discard_template( final Dualface__discard_template otherValue ) {
			copyTemplate( otherValue );
		}

		public Dualface__discard_template( final Optional<Dualface__discard> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.Dualface_discard from an unbound optional field.");
			}
		}

		//originally operator=
		public Dualface__discard_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public Dualface__discard_template assign( final Dualface__discard other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public Dualface__discard_template assign( final Dualface__discard_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public Dualface__discard_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard) {
				return assign((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__discard' can not be cast to {1}", otherValue));
		}

		@Override
		public Dualface__discard_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Dualface__discard_template) {
				return assign((Dualface__discard_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__discard' can not be cast to {1}_template", otherValue));
		}

		public Dualface__discard_template assign( final Optional<Dualface__discard> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Dualface_discard.");
			}
			return this;
		}

		private void copyValue(final Dualface__discard other_value) {
			if (other_value.getincoming().isBound()) {
				getincoming().assign(other_value.getincoming());
			} else {
				getincoming().cleanUp();
			}
			if (other_value.gettarget__type().isBound()) {
				gettarget__type().assign(other_value.gettarget__type());
			} else {
				gettarget__type().cleanUp();
			}
			if (other_value.getport__name().isBound()) {
				getport__name().assign(other_value.getport__name());
			} else {
				getport__name().cleanUp();
			}
			if (other_value.getunhandled().isBound()) {
				getunhandled().assign(other_value.getunhandled());
			} else {
				getunhandled().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final Dualface__discard_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getincoming().get_selection()) {
					getincoming().cleanUp();
				} else {
					getincoming().assign(other_value.getincoming());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.gettarget__type().get_selection()) {
					gettarget__type().cleanUp();
				} else {
					gettarget__type().assign(other_value.gettarget__type());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getport__name().get_selection()) {
					getport__name().cleanUp();
				} else {
					getport__name().assign(other_value.getport__name());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getunhandled().get_selection()) {
					getunhandled().cleanUp();
				} else {
					getunhandled().assign(other_value.getunhandled());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<Dualface__discard_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final Dualface__discard_template temp = new Dualface__discard_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Dualface_discard.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Dualface__discard valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			final Dualface__discard ret_val = new Dualface__discard();
			if (incoming.isBound()) {
				ret_val.getincoming().assign(incoming.valueOf());
			}
			if (target__type.isBound()) {
				ret_val.gettarget__type().assign(target__type.valueOf());
			}
			if (port__name.isBound()) {
				ret_val.getport__name().assign(port__name.valueOf());
			}
			if (unhandled.isBound()) {
				ret_val.getunhandled().assign(unhandled.valueOf());
			}
			return ret_val;
		}

		public Dualface__discard_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Dualface_discard.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Dualface_discard.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Dualface_discard.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Dualface__discard_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Dualface__discard_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (incoming.isBound()) {
				return true;
			}
			if (target__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (unhandled.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!incoming.isValue()) {
				return false;
			}
			if (!target__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!unhandled.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Dualface__discard other_value) {
			return match(other_value, false);
		}

		public boolean match(final Dualface__discard other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getincoming().isBound()) {
					return false;
				}
				if(!incoming.match(other_value.getincoming(), legacy)) {
					return false;
				}
				if(!other_value.gettarget__type().isBound()) {
					return false;
				}
				if(!target__type.match(other_value.gettarget__type(), legacy)) {
					return false;
				}
				if(!other_value.getport__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getport__name(), legacy)) {
					return false;
				}
				if(!other_value.getunhandled().isBound()) {
					return false;
				}
				if(!unhandled.match(other_value.getunhandled(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof Dualface__discard) {
				return match((Dualface__discard)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type Dualface__discard.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(4);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" incoming := ");
				incoming.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" target_type := ");
				target__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" unhandled := ");
				unhandled.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Dualface__discard match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Dualface__discard) {
				log_match((Dualface__discard)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Dualface_discard.");
		}

		public void log_match(final Dualface__discard match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !incoming.match(match_value.constGetincoming(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".incoming");
							incoming.log_match(match_value.constGetincoming(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !target__type.match(match_value.constGettarget__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".target_type");
							target__type.log_match(match_value.constGettarget__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetport__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetport__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !unhandled.match(match_value.constGetunhandled(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".unhandled");
							unhandled.log_match(match_value.constGetunhandled(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ incoming := ");
				incoming.log_match(match_value.constGetincoming(), legacy);
				TTCN_Logger.log_event_str("{ target_type := ");
				target__type.log_match(match_value.constGettarget__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetport__name(), legacy);
				TTCN_Logger.log_event_str("{ unhandled := ");
				unhandled.log_match(match_value.constGetunhandled(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming.encode_text(text_buf);
				target__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				unhandled.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming = new TitanBoolean_template();
				incoming.decode_text(text_buf);
				target__type = new TitanCharString_template();
				target__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				unhandled = new TitanBoolean_template();
				unhandled.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Dualface__discard_template>(size);
				for (int i = 0; i < size; i++) {
					final Dualface__discard_template temp = new Dualface__discard_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 4) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.Dualface_discard has 4 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getincoming().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					gettarget__type().set_param(param.get_elem(1));
				}
				if (param.get_size() > 2 && param.get_elem(2).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getport__name().set_param(param.get_elem(2));
				}
				if (param.get_size() > 3 && param.get_elem(3).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getunhandled().set_param(param.get_elem(3));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("incoming".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getincoming().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("target_type".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							gettarget__type().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("port_name".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getport__name().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("unhandled".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getunhandled().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.Dualface_discard: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.Dualface_discard");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.incoming.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_discard" : name, legacy);
				this.target__type.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_discard" : name, legacy);
				this.port__name.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_discard" : name, legacy);
				this.unhandled.check_restriction(restriction, name == null ? "@TitanLoggerApi.Dualface_discard" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.Dualface_discard" : name));
		}
	}
	public static void Dualface__discard_encoder(final Dualface__discard input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Dualface__discard_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Dualface__discard_decoder( final TitanOctetString input_stream, final Dualface__discard output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Dualface__discard_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class StatisticsType extends Base_Type {
		private final StatisticsType_choice choice; //TTCN3_Choice_Type

		public StatisticsType() {
			this.choice = new StatisticsType_choice();
		}

		public StatisticsType(final StatisticsType_choice choice ) {
			this.choice = new StatisticsType_choice( choice );
		}

		public StatisticsType( final StatisticsType otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StatisticsType.");
			}
			choice = new StatisticsType_choice();
			assign( otherValue );
		}

		public StatisticsType assign(final StatisticsType otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StatisticsType");
			}

			if (otherValue != this) {
				if ( otherValue.getchoice().isBound() ) {
					this.choice.assign( otherValue.getchoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StatisticsType assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType ) {
				return assign((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StatisticsType otherValue) {
			if ( !this.choice.operatorEquals( otherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType ) {
				return operatorEquals((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType", otherValue));
		}

		public StatisticsType_choice getchoice() {
			return choice;
		}

		public StatisticsType_choice constGetchoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(1);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.StatisticsType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StatisticsType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.StatisticsType");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class StatisticsType_template extends Base_Template {

		private StatisticsType_choice_template choice; //TTCN3_Choice_Type
		//originally value_list/list_value
		private List<StatisticsType_template> list_value;

		public StatisticsType_choice_template getchoice() {
			setSpecific();
			return choice;
		}

		public StatisticsType_choice_template constGetchoice() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.StatisticsType.");
			}
			return choice;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				choice = new StatisticsType_choice_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					choice.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public StatisticsType_template() {
			// do nothing
		}

		public StatisticsType_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public StatisticsType_template( final StatisticsType otherValue ) {
			copyValue(otherValue);
		}

		public StatisticsType_template( final StatisticsType_template otherValue ) {
			copyTemplate( otherValue );
		}

		public StatisticsType_template( final Optional<StatisticsType> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.StatisticsType from an unbound optional field.");
			}
		}

		//originally operator=
		public StatisticsType_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_template assign( final StatisticsType other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public StatisticsType_template assign( final StatisticsType_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public StatisticsType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType) {
				return assign((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType' can not be cast to {1}", otherValue));
		}

		@Override
		public StatisticsType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StatisticsType_template) {
				return assign((StatisticsType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType' can not be cast to {1}_template", otherValue));
		}

		public StatisticsType_template assign( final Optional<StatisticsType> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StatisticsType.");
			}
			return this;
		}

		private void copyValue(final StatisticsType other_value) {
			if (other_value.getchoice().isBound()) {
				getchoice().assign(other_value.getchoice());
			} else {
				getchoice().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final StatisticsType_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getchoice().get_selection()) {
					getchoice().cleanUp();
				} else {
					getchoice().assign(other_value.getchoice());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<StatisticsType_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final StatisticsType_template temp = new StatisticsType_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StatisticsType.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StatisticsType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StatisticsType.");
			}
			final StatisticsType ret_val = new StatisticsType();
			if (choice.isBound()) {
				ret_val.getchoice().assign(choice.valueOf());
			}
			return ret_val;
		}

		public StatisticsType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StatisticsType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StatisticsType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StatisticsType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StatisticsType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StatisticsType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StatisticsType other_value) {
			return match(other_value, false);
		}

		public boolean match(final StatisticsType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getchoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getchoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof StatisticsType) {
				return match((StatisticsType)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(1);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StatisticsType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StatisticsType) {
				log_match((StatisticsType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.");
		}

		public void log_match(final StatisticsType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetchoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetchoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetchoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new StatisticsType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StatisticsType_template>(size);
				for (int i = 0; i < size; i++) {
					final StatisticsType_template temp = new StatisticsType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 1) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.StatisticsType has 1 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getchoice().set_param(param.get_elem(0));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("choice".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getchoice().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.StatisticsType: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.StatisticsType");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.choice.check_restriction(restriction, name == null ? "@TitanLoggerApi.StatisticsType" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.StatisticsType" : name));
		}
	}
	public static void StatisticsType_encoder(final StatisticsType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(StatisticsType_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger StatisticsType_decoder( final TitanOctetString input_stream, final StatisticsType output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(StatisticsType_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void TimestampType_seconds_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TimestampType_seconds_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TimestampType_seconds_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TimestampType_seconds_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PortEvent_choice_dualMapped_encoder(final Dualface__mapped input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PortEvent_choice_dualMapped_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PortEvent_choice_dualMapped_decoder( final TitanOctetString input_stream, final Dualface__mapped output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PortEvent_choice_dualMapped_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void SetVerdictType_oldReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(SetVerdictType_oldReason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger SetVerdictType_oldReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(SetVerdictType_oldReason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class MatchingEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_matchingDone,  ALT_matchingSuccess,  ALT_matchingFailure,  ALT_matchingProblem,  ALT_matchingTimeout };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public MatchingEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public MatchingEvent_choice(final MatchingEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final MatchingEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_matchingDone:
				field = new MatchingDoneType((MatchingDoneType)otherValue.field);
				break;
			case ALT_matchingSuccess:
				field = new MatchingSuccessType((MatchingSuccessType)otherValue.field);
				break;
			case ALT_matchingFailure:
				field = new MatchingFailureType((MatchingFailureType)otherValue.field);
				break;
			case ALT_matchingProblem:
				field = new MatchingProblemType((MatchingProblemType)otherValue.field);
				break;
			case ALT_matchingTimeout:
				field = new MatchingTimeout((MatchingTimeout)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.MatchingEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public MatchingEvent_choice assign( final MatchingEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public MatchingEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingEvent_choice) {
				return assign((MatchingEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_matchingDone:
				return field.isValue();
			case ALT_matchingSuccess:
				return field.isValue();
			case ALT_matchingFailure:
				return field.isValue();
			case ALT_matchingProblem:
				return field.isValue();
			case ALT_matchingTimeout:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final MatchingEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_matchingDone:
				return ((MatchingDoneType)field).operatorEquals((MatchingDoneType)otherValue.field);
			case ALT_matchingSuccess:
				return ((MatchingSuccessType)field).operatorEquals((MatchingSuccessType)otherValue.field);
			case ALT_matchingFailure:
				return ((MatchingFailureType)field).operatorEquals((MatchingFailureType)otherValue.field);
			case ALT_matchingProblem:
				return ((MatchingProblemType)field).operatorEquals((MatchingProblemType)otherValue.field);
			case ALT_matchingTimeout:
				return ((MatchingTimeout)field).operatorEquals((MatchingTimeout)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingEvent_choice) {
				return operatorEquals((MatchingEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final MatchingEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public MatchingDoneType getmatchingDone() {
			if (union_selection != union_selection_type.ALT_matchingDone) {
				cleanUp();
				field = new MatchingDoneType();
				union_selection = union_selection_type.ALT_matchingDone;
			}
			return (MatchingDoneType)field;
		}

		public MatchingDoneType constGetmatchingDone() {
			if (union_selection != union_selection_type.ALT_matchingDone) {
				throw new TtcnError("Using non-selected field matchingDone in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingDoneType)field;
		}

		public MatchingSuccessType getmatchingSuccess() {
			if (union_selection != union_selection_type.ALT_matchingSuccess) {
				cleanUp();
				field = new MatchingSuccessType();
				union_selection = union_selection_type.ALT_matchingSuccess;
			}
			return (MatchingSuccessType)field;
		}

		public MatchingSuccessType constGetmatchingSuccess() {
			if (union_selection != union_selection_type.ALT_matchingSuccess) {
				throw new TtcnError("Using non-selected field matchingSuccess in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingSuccessType)field;
		}

		public MatchingFailureType getmatchingFailure() {
			if (union_selection != union_selection_type.ALT_matchingFailure) {
				cleanUp();
				field = new MatchingFailureType();
				union_selection = union_selection_type.ALT_matchingFailure;
			}
			return (MatchingFailureType)field;
		}

		public MatchingFailureType constGetmatchingFailure() {
			if (union_selection != union_selection_type.ALT_matchingFailure) {
				throw new TtcnError("Using non-selected field matchingFailure in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingFailureType)field;
		}

		public MatchingProblemType getmatchingProblem() {
			if (union_selection != union_selection_type.ALT_matchingProblem) {
				cleanUp();
				field = new MatchingProblemType();
				union_selection = union_selection_type.ALT_matchingProblem;
			}
			return (MatchingProblemType)field;
		}

		public MatchingProblemType constGetmatchingProblem() {
			if (union_selection != union_selection_type.ALT_matchingProblem) {
				throw new TtcnError("Using non-selected field matchingProblem in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingProblemType)field;
		}

		public MatchingTimeout getmatchingTimeout() {
			if (union_selection != union_selection_type.ALT_matchingTimeout) {
				cleanUp();
				field = new MatchingTimeout();
				union_selection = union_selection_type.ALT_matchingTimeout;
			}
			return (MatchingTimeout)field;
		}

		public MatchingTimeout constGetmatchingTimeout() {
			if (union_selection != union_selection_type.ALT_matchingTimeout) {
				throw new TtcnError("Using non-selected field matchingTimeout in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingTimeout)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_matchingDone:
				TTCN_Logger.log_event_str("{ matchingDone := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_matchingSuccess:
				TTCN_Logger.log_event_str("{ matchingSuccess := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_matchingFailure:
				TTCN_Logger.log_event_str("{ matchingFailure := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_matchingProblem:
				TTCN_Logger.log_event_str("{ matchingProblem := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_matchingTimeout:
				TTCN_Logger.log_event_str("{ matchingTimeout := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("matchingDone".equals(last_name)) {
				getmatchingDone().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("matchingSuccess".equals(last_name)) {
				getmatchingSuccess().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("matchingFailure".equals(last_name)) {
				getmatchingFailure().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("matchingProblem".equals(last_name)) {
				getmatchingProblem().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("matchingTimeout".equals(last_name)) {
				getmatchingTimeout().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.MatchingEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_matchingDone:
			case ALT_matchingSuccess:
			case ALT_matchingFailure:
			case ALT_matchingProblem:
			case ALT_matchingTimeout:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_matchingDone:
				text_buf.push_int(0);
				break;
			case ALT_matchingSuccess:
				text_buf.push_int(1);
				break;
			case ALT_matchingFailure:
				text_buf.push_int(2);
				break;
			case ALT_matchingProblem:
				text_buf.push_int(3);
				break;
			case ALT_matchingTimeout:
				text_buf.push_int(4);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getmatchingDone().decode_text(text_buf);
				break;
			case 1:
				getmatchingSuccess().decode_text(text_buf);
				break;
			case 2:
				getmatchingFailure().decode_text(text_buf);
				break;
			case 3:
				getmatchingProblem().decode_text(text_buf);
				break;
			case 4:
				getmatchingTimeout().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.MatchingEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class MatchingEvent_choice_template extends Base_Template {
		//if single value which value?
		private MatchingEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<MatchingEvent_choice_template> value_list;

		private void copy_value(final MatchingEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_matchingDone:
				single_value = new MatchingDoneType_template(other_value.constGetmatchingDone());
				break;
			case ALT_matchingSuccess:
				single_value = new MatchingSuccessType_template(other_value.constGetmatchingSuccess());
				break;
			case ALT_matchingFailure:
				single_value = new MatchingFailureType_template(other_value.constGetmatchingFailure());
				break;
			case ALT_matchingProblem:
				single_value = new MatchingProblemType_template(other_value.constGetmatchingProblem());
				break;
			case ALT_matchingTimeout:
				single_value = new MatchingTimeout_template(other_value.constGetmatchingTimeout());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.MatchingEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final MatchingEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_matchingDone:
					single_value = new MatchingDoneType_template(other_value.constGetmatchingDone());
					break;
				case ALT_matchingSuccess:
					single_value = new MatchingSuccessType_template(other_value.constGetmatchingSuccess());
					break;
				case ALT_matchingFailure:
					single_value = new MatchingFailureType_template(other_value.constGetmatchingFailure());
					break;
				case ALT_matchingProblem:
					single_value = new MatchingProblemType_template(other_value.constGetmatchingProblem());
					break;
				case ALT_matchingTimeout:
					single_value = new MatchingTimeout_template(other_value.constGetmatchingTimeout());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.MatchingEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<MatchingEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final MatchingEvent_choice_template temp = new MatchingEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			set_selection(other_value);
		}

		public MatchingEvent_choice_template() {
			// do nothing
		}
		public MatchingEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public MatchingEvent_choice_template(final MatchingEvent_choice other_value) {
			copy_value(other_value);
		}
		public MatchingEvent_choice_template(final MatchingEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_matchingDone:
					((MatchingDoneType_template)single_value).cleanUp();
					break;
				case ALT_matchingSuccess:
					((MatchingSuccessType_template)single_value).cleanUp();
					break;
				case ALT_matchingFailure:
					((MatchingFailureType_template)single_value).cleanUp();
					break;
				case ALT_matchingProblem:
					((MatchingProblemType_template)single_value).cleanUp();
					break;
				case ALT_matchingTimeout:
					((MatchingTimeout_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public MatchingEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public MatchingEvent_choice_template assign( final MatchingEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public MatchingEvent_choice_template assign( final MatchingEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public MatchingEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof MatchingEvent_choice) {
				return assign((MatchingEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to MatchingEvent_choice.");
		}

		@Override
		public MatchingEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof MatchingEvent_choice_template) {
				return assign((MatchingEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to MatchingEvent_choice_template.");
		}

		// originally match
		public boolean match(final MatchingEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final MatchingEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final MatchingEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_matchingDone:
					return ((MatchingDoneType_template)single_value).match(other_value.getmatchingDone(), legacy);
				case ALT_matchingSuccess:
					return ((MatchingSuccessType_template)single_value).match(other_value.getmatchingSuccess(), legacy);
				case ALT_matchingFailure:
					return ((MatchingFailureType_template)single_value).match(other_value.getmatchingFailure(), legacy);
				case ALT_matchingProblem:
					return ((MatchingProblemType_template)single_value).match(other_value.getmatchingProblem(), legacy);
				case ALT_matchingTimeout:
					return ((MatchingTimeout_template)single_value).match(other_value.getmatchingTimeout(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.MatchingEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof MatchingEvent_choice) {
				return match((MatchingEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingEvent_choice.");
		}
		public boolean isChosen(final MatchingEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_matchingDone:
				return ((MatchingDoneType_template)single_value).isValue();
			case ALT_matchingSuccess:
				return ((MatchingSuccessType_template)single_value).isValue();
			case ALT_matchingFailure:
				return ((MatchingFailureType_template)single_value).isValue();
			case ALT_matchingProblem:
				return ((MatchingProblemType_template)single_value).isValue();
			case ALT_matchingTimeout:
				return ((MatchingTimeout_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
		}

		public MatchingEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			final MatchingEvent_choice ret_val = new MatchingEvent_choice();
			switch (single_value_union_selection) {
			case ALT_matchingDone:
				ret_val.getmatchingDone().assign(((MatchingDoneType_template)single_value).valueOf());
				break;
			case ALT_matchingSuccess:
				ret_val.getmatchingSuccess().assign(((MatchingSuccessType_template)single_value).valueOf());
				break;
			case ALT_matchingFailure:
				ret_val.getmatchingFailure().assign(((MatchingFailureType_template)single_value).valueOf());
				break;
			case ALT_matchingProblem:
				ret_val.getmatchingProblem().assign(((MatchingProblemType_template)single_value).valueOf());
				break;
			case ALT_matchingTimeout:
				ret_val.getmatchingTimeout().assign(((MatchingTimeout_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<MatchingEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new MatchingEvent_choice_template());
			}
		}

		public MatchingEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public MatchingDoneType_template getmatchingDone() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingDone) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingDoneType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingDoneType_template();
				}
				single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_matchingDone;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingDoneType_template)single_value;
		}

		public MatchingDoneType_template constGetmatchingDone() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingDone in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingDone) {
				throw new TtcnError("Accessing non-selected field matchingDone in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingDoneType_template)single_value;
		}

		public MatchingSuccessType_template getmatchingSuccess() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingSuccess) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingSuccessType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingSuccessType_template();
				}
				single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_matchingSuccess;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingSuccessType_template)single_value;
		}

		public MatchingSuccessType_template constGetmatchingSuccess() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingSuccess in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingSuccess) {
				throw new TtcnError("Accessing non-selected field matchingSuccess in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingSuccessType_template)single_value;
		}

		public MatchingFailureType_template getmatchingFailure() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingFailure) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingFailureType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingFailureType_template();
				}
				single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_matchingFailure;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingFailureType_template)single_value;
		}

		public MatchingFailureType_template constGetmatchingFailure() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingFailure in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingFailure) {
				throw new TtcnError("Accessing non-selected field matchingFailure in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingFailureType_template)single_value;
		}

		public MatchingProblemType_template getmatchingProblem() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingProblem) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingProblemType_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingProblemType_template();
				}
				single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_matchingProblem;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingProblemType_template)single_value;
		}

		public MatchingProblemType_template constGetmatchingProblem() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingProblem in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingProblem) {
				throw new TtcnError("Accessing non-selected field matchingProblem in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingProblemType_template)single_value;
		}

		public MatchingTimeout_template getmatchingTimeout() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingTimeout) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new MatchingTimeout_template(template_sel.ANY_VALUE);
				} else {
					single_value = new MatchingTimeout_template();
				}
				single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_matchingTimeout;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (MatchingTimeout_template)single_value;
		}

		public MatchingTimeout_template constGetmatchingTimeout() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field matchingTimeout in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_matchingTimeout) {
				throw new TtcnError("Accessing non-selected field matchingTimeout in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
			}
			return (MatchingTimeout_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingEvent_choice) {
				log_match((MatchingEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
		}

		public void log_match(final MatchingEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_matchingDone:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingDone");
						single_value.log_match(match_value.getmatchingDone(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingDone := ");
						single_value.log_match(match_value.getmatchingDone(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_matchingSuccess:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingSuccess");
						single_value.log_match(match_value.getmatchingSuccess(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingSuccess := ");
						single_value.log_match(match_value.getmatchingSuccess(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_matchingFailure:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingFailure");
						single_value.log_match(match_value.getmatchingFailure(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingFailure := ");
						single_value.log_match(match_value.getmatchingFailure(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_matchingProblem:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingProblem");
						single_value.log_match(match_value.getmatchingProblem(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingProblem := ");
						single_value.log_match(match_value.getmatchingProblem(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_matchingTimeout:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".matchingTimeout");
						single_value.log_match(match_value.getmatchingTimeout(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ matchingTimeout := ");
						single_value.log_match(match_value.getmatchingTimeout(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.MatchingEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new MatchingDoneType_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new MatchingSuccessType_template();
					single_value.decode_text(text_buf);
					break;
				case 2:
					single_value = new MatchingFailureType_template();
					single_value.decode_text(text_buf);
					break;
				case 3:
					single_value = new MatchingProblemType_template();
					single_value.decode_text(text_buf);
					break;
				case 4:
					single_value = new MatchingTimeout_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<MatchingEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final MatchingEvent_choice_template temp2 = new MatchingEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.MatchingEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.MatchingEvent.choice");
				}
				if("matchingDone".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("matchingSuccess".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("matchingFailure".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("matchingProblem".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("matchingTimeout".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.MatchingEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("matchingDone".equals(last_name)) {
					getmatchingDone().set_param(mp_last);
					break;
				}
				if("matchingSuccess".equals(last_name)) {
					getmatchingSuccess().set_param(mp_last);
					break;
				}
				if("matchingFailure".equals(last_name)) {
					getmatchingFailure().set_param(mp_last);
					break;
				}
				if("matchingProblem".equals(last_name)) {
					getmatchingProblem().set_param(mp_last);
					break;
				}
				if("matchingTimeout".equals(last_name)) {
					getmatchingTimeout().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.MatchingEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.MatchingEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_matchingDone:
					((MatchingDoneType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name, legacy);
					return;
				case ALT_matchingSuccess:
					((MatchingSuccessType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name, legacy);
					return;
				case ALT_matchingFailure:
					((MatchingFailureType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name, legacy);
					return;
				case ALT_matchingProblem:
					((MatchingProblemType_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name, legacy);
					return;
				case ALT_matchingTimeout:
					((MatchingTimeout_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.MatchingEvent.choice" : name));
		}
	}
	public static void MatchingEvent_choice_encoder(final MatchingEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(MatchingEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger MatchingEvent_choice_decoder( final TitanOctetString input_stream, final MatchingEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(MatchingEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class FunctionEvent_choice extends Base_Type {
		public enum union_selection_type { UNBOUND_VALUE,  ALT_unqualified,  ALT_random };
		private union_selection_type union_selection;
		//originally a union which can not be mapped to Java
		private Base_Type field;
		public FunctionEvent_choice() {
			union_selection = union_selection_type.UNBOUND_VALUE;
		};
		public FunctionEvent_choice(final FunctionEvent_choice otherValue) {
			copy_value(otherValue);
		};

		private void copy_value(final FunctionEvent_choice otherValue) {
			switch (otherValue.union_selection){
			case ALT_unqualified:
				field = new TitanCharString((TitanCharString)otherValue.field);
				break;
			case ALT_random:
				field = new FunctionEvent_choice_random((FunctionEvent_choice_random)otherValue.field);
				break;
			default:
				throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.FunctionEvent.choice.");
			}
			union_selection = otherValue.union_selection;
		}

		//originally operator=
		public FunctionEvent_choice assign( final FunctionEvent_choice otherValue ) {
			if (otherValue != this) {
				cleanUp();
				copy_value(otherValue);
			}

			return this;
		}
		@Override
		public FunctionEvent_choice assign( final Base_Type otherValue ) {
			if (otherValue instanceof FunctionEvent_choice) {
				return assign((FunctionEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
		}

		//originally clean_up
		public void cleanUp() {
			field = null;
			union_selection = union_selection_type.UNBOUND_VALUE;
		}

		public boolean isChosen(final union_selection_type checked_selection) {
			if(checked_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return union_selection == checked_selection;
		}

		@Override
		public boolean isBound() {
			return union_selection != union_selection_type.UNBOUND_VALUE;
		}

		@Override
		public boolean isValue() {
			switch (union_selection) {
			case UNBOUND_VALUE:
				return false;
			case ALT_unqualified:
				return field.isValue();
			case ALT_random:
				return field.isValue();
			default:
				throw new TtcnError("Invalid selection in union is_bound");
			}
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		//originally operator==
		public boolean operatorEquals( final FunctionEvent_choice otherValue ) {
			if (union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.FunctionEvent.choice." );
			}
			if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.FunctionEvent.choice." );
			}
			if (union_selection != otherValue.union_selection) {
				return false;
			}
			switch (union_selection) {
			case ALT_unqualified:
				return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
			case ALT_random:
				return ((FunctionEvent_choice_random)field).operatorEquals((FunctionEvent_choice_random)otherValue.field);
			default:
				return false;
			}
		}
		@Override
		public boolean operatorEquals( final Base_Type otherValue ) {
			if (otherValue instanceof FunctionEvent_choice) {
				return operatorEquals((FunctionEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
		}

		//originally operator!=
		public boolean operatorNotEquals( final FunctionEvent_choice otherValue ) {
			return !operatorEquals(otherValue);
		}

		public TitanCharString getunqualified() {
			if (union_selection != union_selection_type.ALT_unqualified) {
				cleanUp();
				field = new TitanCharString();
				union_selection = union_selection_type.ALT_unqualified;
			}
			return (TitanCharString)field;
		}

		public TitanCharString constGetunqualified() {
			if (union_selection != union_selection_type.ALT_unqualified) {
				throw new TtcnError("Using non-selected field unqualified in a value of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return (TitanCharString)field;
		}

		public FunctionEvent_choice_random getrandom() {
			if (union_selection != union_selection_type.ALT_random) {
				cleanUp();
				field = new FunctionEvent_choice_random();
				union_selection = union_selection_type.ALT_random;
			}
			return (FunctionEvent_choice_random)field;
		}

		public FunctionEvent_choice_random constGetrandom() {
			if (union_selection != union_selection_type.ALT_random) {
				throw new TtcnError("Using non-selected field random in a value of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return (FunctionEvent_choice_random)field;
		}

		public union_selection_type get_selection() {
			return union_selection;
		}
		public void log() {
			switch (union_selection) {
			case ALT_unqualified:
				TTCN_Logger.log_event_str("{ unqualified := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case ALT_random:
				TTCN_Logger.log_event_str("{ random := ");
				field.log();
				TTCN_Logger.log_event_str(" }");
				break;
			default:
				TTCN_Logger.log_event_unbound();
				break;
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "union value");
			if(param.get_type() == Module_Parameter.type_t.MP_Value_List && param.get_size() == 0) {
				return;
			}
			if (param.get_type() != Module_Parameter.type_t.MP_Assignment_List) {
				param.error("union value with field name was expected");
			}
			final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
			final String last_name = mp_last.get_id().get_name();
			if ("unqualified".equals(last_name)) {
				getunqualified().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			if ("random".equals(last_name)) {
				getrandom().set_param(mp_last);
				if (!field.isBound()) {
					cleanUp();
				}
				return;
			}
			mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.FunctionEvent.choice.", last_name));
		}

		@Override
		public void set_implicit_omit() {
			switch (union_selection) {
			case ALT_unqualified:
			case ALT_random:
				field.set_implicit_omit();
				break;
			default:
				break;
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			switch (union_selection) {
			case ALT_unqualified:
				text_buf.push_int(0);
				break;
			case ALT_random:
				text_buf.push_int(1);
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			field.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			switch (temp) {
			case 0:
				getunqualified().decode_text(text_buf);
				break;
			case 1:
				getrandom().decode_text(text_buf);
				break;
			default:
				throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.FunctionEvent.choice.");
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class FunctionEvent_choice_template extends Base_Template {
		//if single value which value?
		private FunctionEvent_choice.union_selection_type single_value_union_selection;
		//originally a union which can not be mapped to Java
		private Base_Template single_value;
		// value_list part
		private ArrayList<FunctionEvent_choice_template> value_list;

		private void copy_value(final FunctionEvent_choice other_value) {
			single_value_union_selection = other_value.get_selection();
			switch (other_value.get_selection()) {
			case ALT_unqualified:
				single_value = new TitanCharString_template(other_value.constGetunqualified());
				break;
			case ALT_random:
				single_value = new FunctionEvent_choice_random_template(other_value.constGetrandom());
				break;
			default:
				throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.FunctionEvent.choice.");
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}
		private void copy_template(final FunctionEvent_choice_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				single_value_union_selection = other_value.single_value_union_selection;
				switch (single_value_union_selection) {
				case ALT_unqualified:
					single_value = new TitanCharString_template(other_value.constGetunqualified());
					break;
				case ALT_random:
					single_value = new FunctionEvent_choice_random_template(other_value.constGetrandom());
					break;
				default:
					throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.FunctionEvent.choice.");
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<FunctionEvent_choice_template>(other_value.value_list.size());
				for(int i = 0; i < other_value.value_list.size(); i++) {
					final FunctionEvent_choice_template temp = new FunctionEvent_choice_template(other_value.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			set_selection(other_value);
		}

		public FunctionEvent_choice_template() {
			// do nothing
		}
		public FunctionEvent_choice_template(final template_sel other_value) {
			super(other_value);
			checkSingleSelection(other_value);
		}
		public FunctionEvent_choice_template(final FunctionEvent_choice other_value) {
			copy_value(other_value);
		}
		public FunctionEvent_choice_template(final FunctionEvent_choice_template other_value) {
			copy_template(other_value);
		}

		@Override
		public void cleanUp() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				switch (single_value_union_selection) {
				case ALT_unqualified:
					((TitanCharString_template)single_value).cleanUp();
					break;
				case ALT_random:
					((FunctionEvent_choice_random_template)single_value).cleanUp();
					break;
				default:
					break;
				}
				single_value = null;
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list.clear();
				value_list = null;
				break;
			default:
				break;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		//originally operator=
		public FunctionEvent_choice_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_choice_template assign( final FunctionEvent_choice other_value ) {
			cleanUp();
			copy_value(other_value);
			return this;
		}

		//originally operator=
		public FunctionEvent_choice_template assign( final FunctionEvent_choice_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copy_template(other_value);
			}
			return this;
		}

		@Override
		public FunctionEvent_choice_template assign( final Base_Type otherValue ) {
			if (otherValue instanceof FunctionEvent_choice) {
				return assign((FunctionEvent_choice)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to FunctionEvent_choice.");
		}

		@Override
		public FunctionEvent_choice_template assign( final Base_Template otherValue ) {
			if (otherValue instanceof FunctionEvent_choice_template) {
				return assign((FunctionEvent_choice_template)otherValue);
			}
			throw new TtcnError("Internal Error: value can not be cast to FunctionEvent_choice_template.");
		}

		// originally match
		public boolean match(final FunctionEvent_choice other_value) {
			return match(other_value, false);
		}

		// originally match
		public boolean match(final FunctionEvent_choice other_value, final boolean legacy) {
			if(!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				final FunctionEvent_choice.union_selection_type value_selection = other_value.get_selection();
				if (value_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
					return false;
				}
				if (value_selection != single_value_union_selection) {
					return false;
				}
				switch (value_selection) {
				case ALT_unqualified:
					return ((TitanCharString_template)single_value).match(other_value.getunqualified(), legacy);
				case ALT_random:
					return ((FunctionEvent_choice_random_template)single_value).match(other_value.getrandom(), legacy);
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.FunctionEvent.choice.");
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof FunctionEvent_choice) {
				return match((FunctionEvent_choice)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent_choice.");
		}
		public boolean isChosen(final FunctionEvent_choice.union_selection_type checked_selection) {
			if(checked_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
				throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (single_value_union_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
				}
				return single_value_union_selection == checked_selection;
			case VALUE_LIST:
				if (value_list.isEmpty()) {
					throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.FunctionEvent.choice containing an empty list.");
				}
				for (int i = 0; i < value_list.size(); i++) {
					if(!value_list.get(i).isChosen(checked_selection)) {
						return false;
					}
				}
				return true;
			default:
				return false;
			}
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			switch (single_value_union_selection) {
			case ALT_unqualified:
				return ((TitanCharString_template)single_value).isValue();
			case ALT_random:
				return ((FunctionEvent_choice_random_template)single_value).isValue();
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
		}

		public FunctionEvent_choice valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			final FunctionEvent_choice ret_val = new FunctionEvent_choice();
			switch (single_value_union_selection) {
			case ALT_unqualified:
				ret_val.getunqualified().assign(((TitanCharString_template)single_value).valueOf());
				break;
			case ALT_random:
				ret_val.getrandom().assign(((FunctionEvent_choice_random_template)single_value).valueOf());
				break;
			default:
				throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return ret_val;
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			cleanUp();
			set_selection(template_type);
			value_list = new ArrayList<FunctionEvent_choice_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new FunctionEvent_choice_template());
			}
		}

		public FunctionEvent_choice_template listItem(final int list_index)  {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			if (list_index < 0) {
				throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit(legacy)) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
				return false;
			default:
				return false;
			}
		}

		public TitanCharString_template getunqualified() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_unqualified) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new TitanCharString_template(template_sel.ANY_VALUE);
				} else {
					single_value = new TitanCharString_template();
				}
				single_value_union_selection = FunctionEvent_choice.union_selection_type.ALT_unqualified;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (TitanCharString_template)single_value;
		}

		public TitanCharString_template constGetunqualified() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field unqualified in a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			if (single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_unqualified) {
				throw new TtcnError("Accessing non-selected field unqualified in a template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return (TitanCharString_template)single_value;
		}

		public FunctionEvent_choice_random_template getrandom() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_random) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					single_value = new FunctionEvent_choice_random_template(template_sel.ANY_VALUE);
				} else {
					single_value = new FunctionEvent_choice_random_template();
				}
				single_value_union_selection = FunctionEvent_choice.union_selection_type.ALT_random;
				set_selection(template_sel.SPECIFIC_VALUE);
			}
			return (FunctionEvent_choice_random_template)single_value;
		}

		public FunctionEvent_choice_random_template constGetrandom() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field random in a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			if (single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_random) {
				throw new TtcnError("Accessing non-selected field random in a template of union type @TitanLoggerApi.FunctionEvent.choice.");
			}
			return (FunctionEvent_choice_random_template)single_value;
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				single_value.log();
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FunctionEvent_choice) {
				log_match((FunctionEvent_choice)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
		}

		public void log_match(final FunctionEvent_choice match_value, final boolean legacy) {
			if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
				switch (single_value_union_selection) {
				case ALT_unqualified:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".unqualified");
						single_value.log_match(match_value.getunqualified(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ unqualified := ");
						single_value.log_match(match_value.getunqualified(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				case ALT_random:
					if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
						TTCN_Logger.log_logmatch_info(".random");
						single_value.log_match(match_value.getrandom(), legacy);
					} else {
						TTCN_Logger.log_logmatch_info("{ random := ");
						single_value.log_match(match_value.getrandom(), legacy);
						TTCN_Logger.log_event_str(" }");
					}
					break;
				default:
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str("<invalid selector>");
				}
			} else {
				TTCN_Logger.print_logmatch_buffer();
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if (match(match_value, legacy)) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value_union_selection.ordinal());
				single_value.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.FunctionEvent.choice.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				switch (temp) {
				case 0:
					single_value = new TitanCharString_template();
					single_value.decode_text(text_buf);
					break;
				case 1:
					single_value = new FunctionEvent_choice_random_template();
					single_value.decode_text(text_buf);
					break;
				}
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<FunctionEvent_choice_template>(size);
				for (int i = 0; i < size; i++) {
					final FunctionEvent_choice_template temp2 = new FunctionEvent_choice_template();
					temp2.decode_text(text_buf);
					value_list.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.FunctionEvent.choice.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			if((param.get_id() instanceof Module_Param_Name) && param.get_id().next_name()) {
				final String param_field = param.get_id().get_current_name();
				if (param_field.charAt(0) >= '0' && param_field.charAt(0) <= '9') {
					param.error("Unexpected array index in module parameter, expected a valid field name for union template type `@TitanLoggerApi.FunctionEvent.choice");
				}
				if("unqualified".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else if("random".equals(param_field)) {
					single_value.set_param(param);
					return;
				} else {
					param.error(MessageFormat.format("Field `{0}' not found in union template type `{0}", param_field));
				}
			}
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "union template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() == 0) {
					break;
				}
				param.type_error("union template", "@TitanLoggerApi.FunctionEvent.choice");
				break;
			case MP_Assignment_List: {
				final Module_Parameter mp_last = param.get_elem(param.get_size() - 1);
				final String last_name = mp_last.get_id().get_name();
				if("unqualified".equals(last_name)) {
					getunqualified().set_param(mp_last);
					break;
				}
				if("random".equals(last_name)) {
					getrandom().set_param(mp_last);
					break;
				}
				mp_last.error(MessageFormat.format("Field {0} does not exist in type @TitanLoggerApi.FunctionEvent.choice.", last_name));
				break;
			}
			default:
				param.type_error("union template", "@TitanLoggerApi.FunctionEvent.choice");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				switch (single_value_union_selection) {
				case ALT_unqualified:
					((TitanCharString_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent.choice" : name, legacy);
					return;
				case ALT_random:
					((FunctionEvent_choice_random_template)single_value).check_restriction(restriction, name == null ? "@TitanLoggerApi.FunctionEvent.choice" : name, legacy);
					return;
				default:
					throw new TtcnError("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
				}
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.FunctionEvent.choice" : name));
		}
	}
	public static void FunctionEvent_choice_encoder(final FunctionEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(FunctionEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger FunctionEvent_choice_decoder( final TitanOctetString input_stream, final FunctionEvent_choice output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(FunctionEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class RandomAction extends Base_Type {
		public enum enum_type {
			read__out (0),
			seed (1),
			UNKNOWN_VALUE(2),
			UNBOUND_VALUE(3);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return read__out;
				case 1:  return seed;
				case 2:  return UNKNOWN_VALUE;
				case 3:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public RandomAction() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public RandomAction(final RandomAction otherValue) {
			enum_value = otherValue.enum_value;
		}

		public RandomAction(final RandomAction.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public RandomAction(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `RandomAction' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public RandomAction assign(final RandomAction otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public RandomAction assign(final Base_Type otherValue){
			if( otherValue instanceof RandomAction ) {
				return assign((RandomAction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public RandomAction assign(final RandomAction.enum_type otherValue){
			return assign( new RandomAction(otherValue) );
		}

		//originally operator=
		public RandomAction assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `RandomAction'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final RandomAction otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof RandomAction) {
				return operatorEquals( (RandomAction) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.RandomAction.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final RandomAction.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final RandomAction otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final RandomAction.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final RandomAction.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final RandomAction otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final RandomAction.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final RandomAction otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final RandomAction.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final RandomAction otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final RandomAction.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final RandomAction otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final RandomAction.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final RandomAction enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("read__out".equals(strPar) || "read_out".equals(strPar)) {
				return enum_type.read__out;
			}
			if ("seed".equals(strPar)) {
				return enum_type.seed;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.RandomAction");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.RandomAction.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.RandomAction.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.RandomAction.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class RandomAction_template extends Base_Template {
		// single_value
		private RandomAction.enum_type single_value;
		// value_list part
		private ArrayList<RandomAction_template> value_list;

		private void copy_template(final RandomAction_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<RandomAction_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final RandomAction_template temp = new RandomAction_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type RandomAction.");
			}
		}

		public RandomAction_template() {
			// do nothing
		}

		public RandomAction_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public RandomAction_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!RandomAction.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type RandomAction with unknown numeric value "+ otherValue +".");
			}
			single_value = RandomAction.enum_type.getValue(otherValue);
		}

		public RandomAction_template(final RandomAction otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == RandomAction.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type RandomAction. ");
			}
			single_value = otherValue.enum_value;
		}

		public RandomAction_template(final RandomAction_template otherValue) {
			copy_template(otherValue);
		}

		public RandomAction_template(final RandomAction.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != RandomAction.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public RandomAction_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public RandomAction_template assign(final int otherValue) {
			if (!RandomAction.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type RandomAction.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public RandomAction_template assign(final RandomAction.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public RandomAction_template assign(final RandomAction_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public RandomAction_template assign(final RandomAction otherValue){
			if (otherValue.enum_value == RandomAction.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type RandomAction to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public RandomAction_template assign(final Base_Type otherValue){
			if( otherValue instanceof RandomAction ) {
				return assign((RandomAction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
		}

		@Override
		public RandomAction_template assign(final Base_Template otherValue){
			if( otherValue instanceof RandomAction_template ) {
				return assign((RandomAction_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final RandomAction.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final RandomAction.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type RandomAction.");
			}
		}

		// originally match
		public boolean match(final RandomAction otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final RandomAction otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof RandomAction ) {
				return match((RandomAction) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
		}

		public RandomAction valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type RandomAction.");
			}
			return new RandomAction(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type RandomAction.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<RandomAction_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new RandomAction_template());
			}
		}

		public RandomAction_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type RandomAction.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type RandomAction.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type RandomAction.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(RandomAction.enum2str(single_value), RandomAction.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof RandomAction) {
				log_match((RandomAction)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.RandomAction.");
		}
		public void log_match(final RandomAction match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final RandomAction.enum_type enum_value = RandomAction.str_to_enum(param.get_enumerated());
				if (!RandomAction.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.RandomAction.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.RandomAction");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.RandomAction.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!RandomAction.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.RandomAction.", temp));
				}
				single_value = RandomAction.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<RandomAction_template>(size);
				for (int i = 0; i < size; i++) {
					final RandomAction_template temp = new RandomAction_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.RandomAction.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.RandomAction" : name));
		}
	}
	public static void RandomAction_encoder(final RandomAction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(RandomAction_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger RandomAction_decoder( final TitanOctetString input_stream, final RandomAction output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(RandomAction_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Proc__port__in_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Proc__port__in_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Proc__port__in_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Proc__port__in_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorComponent extends Base_Type {
		private final ExecutorComponent_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanInteger> compref; //Integer_Type

		public ExecutorComponent() {
			this.reason = new ExecutorComponent_reason();
			this.compref = new Optional<TitanInteger>(TitanInteger.class);
		}

		public ExecutorComponent(final ExecutorComponent_reason reason, final Optional<TitanInteger> compref ) {
			this.reason = new ExecutorComponent_reason( reason );
			this.compref = new Optional<TitanInteger>(TitanInteger.class);
			this.compref.assign( compref );
		}

		public ExecutorComponent( final ExecutorComponent otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorComponent.");
			}
			reason = new ExecutorComponent_reason();
			compref = new Optional<TitanInteger>(TitanInteger.class);
			assign( otherValue );
		}

		public ExecutorComponent assign(final ExecutorComponent otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorComponent");
			}

			if (otherValue != this) {
				if ( otherValue.getreason().isBound() ) {
					this.reason.assign( otherValue.getreason() );
				} else {
					this.reason.cleanUp();
				}
				if ( otherValue.getcompref().isBound() ) {
					this.compref.assign( otherValue.getcompref() );
				} else {
					this.compref.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorComponent assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent ) {
				return assign((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorComponent", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			compref.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(compref.get_selection()) || compref.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(compref.get_selection()) && !compref.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorComponent otherValue) {
			if ( !this.reason.operatorEquals( otherValue.reason ) ) { return false; }
			if ( !this.compref.operatorEquals( otherValue.compref ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent ) {
				return operatorEquals((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorComponent", otherValue));
		}

		public ExecutorComponent_reason getreason() {
			return reason;
		}

		public ExecutorComponent_reason constGetreason() {
			return reason;
		}

		public Optional<TitanInteger> getcompref() {
			return compref;
		}

		public Optional<TitanInteger> constGetcompref() {
			return compref;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (compref.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.ExecutorComponent has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorComponent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.ExecutorComponent");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			} else {
				compref.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			compref.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			compref.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorComponent_template extends Base_Template {

		private ExecutorComponent_reason_template reason; //TTCN3_Enumerated_Type
		private TitanInteger_template compref; //Integer_Type
		//originally value_list/list_value
		private List<ExecutorComponent_template> list_value;

		public ExecutorComponent_reason_template getreason() {
			setSpecific();
			return reason;
		}

		public ExecutorComponent_reason_template constGetreason() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
			}
			return reason;
		}

		public TitanInteger_template getcompref() {
			setSpecific();
			return compref;
		}

		public TitanInteger_template constGetcompref() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
			}
			return compref;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				reason = new ExecutorComponent_reason_template();
				compref = new TitanInteger_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					reason.assign(template_sel.ANY_VALUE);
					compref.assign(template_sel.ANY_OR_OMIT);
				}
			}
		}

		public ExecutorComponent_template() {
			// do nothing
		}

		public ExecutorComponent_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public ExecutorComponent_template( final ExecutorComponent otherValue ) {
			copyValue(otherValue);
		}

		public ExecutorComponent_template( final ExecutorComponent_template otherValue ) {
			copyTemplate( otherValue );
		}

		public ExecutorComponent_template( final Optional<ExecutorComponent> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorComponent from an unbound optional field.");
			}
		}

		//originally operator=
		public ExecutorComponent_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public ExecutorComponent_template assign( final ExecutorComponent other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public ExecutorComponent_template assign( final ExecutorComponent_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public ExecutorComponent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent) {
				return assign((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorComponent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorComponent_template) {
				return assign((ExecutorComponent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent' can not be cast to {1}_template", otherValue));
		}

		public ExecutorComponent_template assign( final Optional<ExecutorComponent> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorComponent.");
			}
			return this;
		}

		private void copyValue(final ExecutorComponent other_value) {
			if (other_value.getreason().isBound()) {
				getreason().assign(other_value.getreason());
			} else {
				getreason().cleanUp();
			}
			if (other_value.getcompref().isBound()) {
				if (other_value.getcompref().isPresent()) {
					getcompref().assign(other_value.getcompref().get());
				} else {
					getcompref().assign(template_sel.OMIT_VALUE);
				}
			} else {
				getcompref().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final ExecutorComponent_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getreason().get_selection()) {
					getreason().cleanUp();
				} else {
					getreason().assign(other_value.getreason());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getcompref().get_selection()) {
					getcompref().cleanUp();
				} else {
					getcompref().assign(other_value.getcompref());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<ExecutorComponent_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final ExecutorComponent_template temp = new ExecutorComponent_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorComponent.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorComponent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
			}
			final ExecutorComponent ret_val = new ExecutorComponent();
			if (reason.isBound()) {
				ret_val.getreason().assign(reason.valueOf());
			}
			if (compref.isOmit()) {
				ret_val.getcompref().assign(template_sel.OMIT_VALUE);
			} else if (compref.isBound()) {
				ret_val.getcompref().assign(compref.valueOf());
			}
			return ret_val;
		}

		public ExecutorComponent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorComponent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorComponent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorComponent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorComponent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorComponent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (compref.isOmit() || compref.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!compref.isOmit() && !compref.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorComponent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorComponent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getreason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getreason(), legacy)) {
					return false;
				}
				if(!other_value.getcompref().isBound()) {
					return false;
				}
				if((other_value.getcompref().isPresent() ? !compref.match(other_value.getcompref().get(), legacy) : !compref.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof ExecutorComponent) {
				return match((ExecutorComponent)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorComponent.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (compref.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorComponent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorComponent) {
				log_match((ExecutorComponent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.");
		}

		public void log_match(final ExecutorComponent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetreason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetreason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetcompref().isPresent()) {
							if( !compref.match(match_value.constGetcompref().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".compref");
								compref.log_match(match_value.constGetcompref().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!compref.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".compref := omit with ");
								TTCN_Logger.print_logmatch_buffer();
								compref.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetreason(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetcompref(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				compref.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorComponent_reason_template();
				reason.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorComponent_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorComponent_template temp = new ExecutorComponent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.ExecutorComponent has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getreason().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getcompref().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("reason".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getreason().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("compref".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getcompref().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.ExecutorComponent: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.ExecutorComponent");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.reason.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorComponent" : name, legacy);
				this.compref.check_restriction(restriction, name == null ? "@TitanLoggerApi.ExecutorComponent" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorComponent" : name));
		}
	}
	public static void ExecutorComponent_encoder(final ExecutorComponent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorComponent_decoder( final TitanOctetString input_stream, final ExecutorComponent output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void PTC__exit_pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(PTC__exit_pid_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger PTC__exit_pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(PTC__exit_pid_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static void Msg__port__recv_sys__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(Msg__port__recv_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger Msg__port__recv_sys__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(Msg__port__recv_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class TitanLog_sequence__list_0 extends Base_Type {
		private final ComponentIDType entityId; //Referenced_Type
		private final TitanLog_sequence__list_0_event__list event__list; //SequenceOf_Type

		public TitanLog_sequence__list_0() {
			this.entityId = new ComponentIDType();
			this.event__list = new TitanLog_sequence__list_0_event__list();
		}

		public TitanLog_sequence__list_0(final ComponentIDType entityId, final TitanLog_sequence__list_0_event__list event__list ) {
			this.entityId = new ComponentIDType( entityId );
			this.event__list = new TitanLog_sequence__list_0_event__list( event__list );
		}

		public TitanLog_sequence__list_0( final TitanLog_sequence__list_0 otherValue) {
			if(!otherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			entityId = new ComponentIDType();
			event__list = new TitanLog_sequence__list_0_event__list();
			assign( otherValue );
		}

		public TitanLog_sequence__list_0 assign(final TitanLog_sequence__list_0 otherValue ) {
			if ( !otherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype");
			}

			if (otherValue != this) {
				if ( otherValue.getentityId().isBound() ) {
					this.entityId.assign( otherValue.getentityId() );
				} else {
					this.entityId.cleanUp();
				}
				if ( otherValue.getevent__list().isBound() ) {
					this.event__list.assign( otherValue.getevent__list() );
				} else {
					this.event__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLog_sequence__list_0 assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0 ) {
				return assign((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype", otherValue));
		}

		public void cleanUp() {
			entityId.cleanUp();
			event__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( entityId.isBound() ) { return true; }
			if ( event__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !entityId.isValue() ) { return false; }
			if ( !event__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLog_sequence__list_0 otherValue) {
			if ( !this.entityId.operatorEquals( otherValue.entityId ) ) { return false; }
			if ( !this.event__list.operatorEquals( otherValue.event__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0 ) {
				return operatorEquals((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype", otherValue));
		}

		public ComponentIDType getentityId() {
			return entityId;
		}

		public ComponentIDType constGetentityId() {
			return entityId;
		}

		public TitanLog_sequence__list_0_event__list getevent__list() {
			return event__list;
		}

		public TitanLog_sequence__list_0_event__list constGetevent__list() {
			return event__list;
		}

		public TitanInteger sizeOf() {
			return new TitanInteger(2);
		}

		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" entityId := ");
			entityId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" event_list := ");
			event__list.log();
			TTCN_Logger.log_event_str(" }");
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "record value");
			switch (param.get_type()) {
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record value of type @TitanLoggerApi.TitanLog.sequence_list.oftype has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getentityId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getevent__list().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("entityId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getentityId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("event_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getevent__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLog.sequence_list.oftype: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record value", "@TitanLoggerApi.TitanLog.sequence_list.oftype");
			}
		}

		@Override
		public void set_implicit_omit() {
			if (entityId.isBound()) {
				entityId.set_implicit_omit();
			}
			if (event__list.isBound()) {
				event__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			entityId.encode_text(text_buf);
			event__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			entityId.decode_text(text_buf);
			event__list.decode_text(text_buf);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class TitanLog_sequence__list_0_template extends Base_Template {

		private ComponentIDType_template entityId; //Referenced_Type
		private TitanLog_sequence__list_0_event__list_template event__list; //SequenceOf_Type
		//originally value_list/list_value
		private List<TitanLog_sequence__list_0_template> list_value;

		public ComponentIDType_template getentityId() {
			setSpecific();
			return entityId;
		}

		public ComponentIDType_template constGetentityId() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field entityId of a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			return entityId;
		}

		public TitanLog_sequence__list_0_event__list_template getevent__list() {
			setSpecific();
			return event__list;
		}

		public TitanLog_sequence__list_0_event__list_template constGetevent__list() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				throw new TtcnError("Accessing field event_list of a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			return event__list;
		}

		private void setSpecific() {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				final template_sel old_selection = templateSelection;
				cleanUp();
				set_selection(template_sel.SPECIFIC_VALUE);
				entityId = new ComponentIDType_template();
				event__list = new TitanLog_sequence__list_0_event__list_template();
				if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
					entityId.assign(template_sel.ANY_VALUE);
					event__list.assign(template_sel.ANY_VALUE);
				}
			}
		}

		public TitanLog_sequence__list_0_template() {
			// do nothing
		}

		public TitanLog_sequence__list_0_template(final template_sel other_value ) {
			super( other_value );
			checkSingleSelection( other_value );
		}

		public TitanLog_sequence__list_0_template( final TitanLog_sequence__list_0 otherValue ) {
			copyValue(otherValue);
		}

		public TitanLog_sequence__list_0_template( final TitanLog_sequence__list_0_template otherValue ) {
			copyTemplate( otherValue );
		}

		public TitanLog_sequence__list_0_template( final Optional<TitanLog_sequence__list_0> other_value ) {
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype from an unbound optional field.");
			}
		}

		//originally operator=
		public TitanLog_sequence__list_0_template assign( final template_sel other_value ) {
			checkSingleSelection(other_value);
			cleanUp();
			set_selection(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_0_template assign( final TitanLog_sequence__list_0 other_value ) {
			cleanUp();
			copyValue(other_value);
			return this;
		}

		//originally operator=
		public TitanLog_sequence__list_0_template assign( final TitanLog_sequence__list_0_template other_value ) {
			if (other_value != this) {
				cleanUp();
				copyTemplate(other_value);
			}
			return this;
		}

		@Override
		public TitanLog_sequence__list_0_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0) {
				return assign((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog_sequence__list_0' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLog_sequence__list_0_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_template) {
				return assign((TitanLog_sequence__list_0_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog_sequence__list_0' can not be cast to {1}_template", otherValue));
		}

		public TitanLog_sequence__list_0_template assign( final Optional<TitanLog_sequence__list_0> other_value ) {
			cleanUp();
			switch (other_value.get_selection()) {
			case OPTIONAL_PRESENT:
				copyValue(other_value.constGet());
				break;
			case OPTIONAL_OMIT:
				set_selection(template_sel.OMIT_VALUE);
				break;
			default:
				throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			return this;
		}

		private void copyValue(final TitanLog_sequence__list_0 other_value) {
			if (other_value.getentityId().isBound()) {
				getentityId().assign(other_value.getentityId());
			} else {
				getentityId().cleanUp();
			}
			if (other_value.getevent__list().isBound()) {
				getevent__list().assign(other_value.getevent__list());
			} else {
				getevent__list().cleanUp();
			}
			set_selection(template_sel.SPECIFIC_VALUE);
		}

		private void copyTemplate(final TitanLog_sequence__list_0_template other_value) {
			switch (other_value.templateSelection) {
			case SPECIFIC_VALUE:
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getentityId().get_selection()) {
					getentityId().cleanUp();
				} else {
					getentityId().assign(other_value.getentityId());
				}
				if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getevent__list().get_selection()) {
					getevent__list().cleanUp();
				} else {
					getevent__list().assign(other_value.getevent__list());
				}
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				list_value = new ArrayList<TitanLog_sequence__list_0_template>(other_value.list_value.size());
				for(int i = 0; i < other_value.list_value.size(); i++) {
					final TitanLog_sequence__list_0_template temp = new TitanLog_sequence__list_0_template(other_value.list_value.get(i));
					list_value.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			set_selection(other_value);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLog_sequence__list_0 valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			final TitanLog_sequence__list_0 ret_val = new TitanLog_sequence__list_0();
			if (entityId.isBound()) {
				ret_val.getentityId().assign(entityId.valueOf());
			}
			if (event__list.isBound()) {
				ret_val.getevent__list().assign(event__list.valueOf());
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLog_sequence__list_0_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLog_sequence__list_0_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (entityId.isBound()) {
				return true;
			}
			if (event__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!entityId.isValue()) {
				return false;
			}
			if (!event__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLog_sequence__list_0 other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLog_sequence__list_0 other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getentityId().isBound()) {
					return false;
				}
				if(!entityId.match(other_value.getentityId(), legacy)) {
					return false;
				}
				if(!other_value.getevent__list().isBound()) {
					return false;
				}
				if(!event__list.match(other_value.getevent__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy) {
			if (otherValue instanceof TitanLog_sequence__list_0) {
				return match((TitanLog_sequence__list_0)otherValue, legacy);
			}

			throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0.");
		}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return new TitanInteger(2);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" entityId := ");
				entityId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" event_list := ");
				event__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLog_sequence__list_0 match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog_sequence__list_0) {
				log_match((TitanLog_sequence__list_0)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}

		public void log_match(final TitanLog_sequence__list_0 match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !entityId.match(match_value.constGetentityId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".entityId");
							entityId.log_match(match_value.constGetentityId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !event__list.match(match_value.constGetevent__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".event_list");
							event__list.log_match(match_value.constGetevent__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ entityId := ");
				entityId.log_match(match_value.constGetentityId(), legacy);
				TTCN_Logger.log_event_str("{ event_list := ");
				event__list.log_match(match_value.constGetevent__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId.encode_text(text_buf);
				event__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId = new ComponentIDType_template();
				entityId.decode_text(text_buf);
				event__list = new TitanLog_sequence__list_0_event__list_template();
				event__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_0_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_sequence__list_0_template temp = new TitanLog_sequence__list_0_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "record template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Value_List:
				if (param.get_size() > 2) {
					param.error(MessageFormat.format("record template of type @TitanLoggerApi.TitanLog.sequence_list.oftype has 2 fields but list value has {0} fields.", param.get_size()));
				}
				if (param.get_size() > 0 && param.get_elem(0).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getentityId().set_param(param.get_elem(0));
				}
				if (param.get_size() > 1 && param.get_elem(1).get_type() != Module_Parameter.type_t.MP_NotUsed) {
					getevent__list().set_param(param.get_elem(1));
				}
				break;
			case MP_Assignment_List: {
				final boolean value_used[] = new boolean[param.get_size()];
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("entityId".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getentityId().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					final Module_Parameter curr_param = param.get_elem(val_idx);
					if ("event_list".equals(curr_param.get_id().get_name())) {
						if (curr_param.get_type() != Module_Parameter.type_t.MP_NotUsed) {
							getevent__list().set_param(curr_param);
						}
						value_used[val_idx] = true;
					}
				}
				for (int val_idx = 0; val_idx < param.get_size(); val_idx++) {
					if (!value_used[val_idx]) {
						final Module_Parameter curr_param = param.get_elem(val_idx);
						curr_param.error(MessageFormat.format("Non existent field name in type @TitanLoggerApi.TitanLog.sequence_list.oftype: {0}", curr_param.get_id().get_name()));
						break;
					}
				}
				break;
			}
			default:
				param.type_error("record template", "@TitanLoggerApi.TitanLog.sequence_list.oftype");
			}
			is_ifPresent = param.get_ifpresent();
		}
		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_OMIT:
				if (templateSelection == template_sel.OMIT_VALUE) {
					return;
				}
			case TR_VALUE:
				if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
					break;
				}
				this.entityId.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLog.sequence_list.oftype" : name, legacy);
				this.event__list.check_restriction(restriction, name == null ? "@TitanLoggerApi.TitanLog.sequence_list.oftype" : name, legacy);
				return;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.TitanLog.sequence_list.oftype" : name));
		}
	}
	public static void TitanLog_sequence__list_0_encoder(final TitanLog_sequence__list_0 input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(TitanLog_sequence__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger TitanLog_sequence__list_0_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list_0 output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(TitanLog_sequence__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public static class ExecutorComponent_reason extends Base_Type {
		public enum enum_type {
			mtc__started (0),
			mtc__finished (1),
			ptc__started (2),
			ptc__finished (3),
			component__init__fail (4),
			UNKNOWN_VALUE(5),
			UNBOUND_VALUE(6);

			private int enum_num;
			enum_type(final int num) {
				this.enum_num = num;
			}

			private int getInt() {
				return enum_num;
			}

			public static enum_type getValue(final int index) {
				switch (index) {
				case 0:  return mtc__started;
				case 1:  return mtc__finished;
				case 2:  return ptc__started;
				case 3:  return ptc__finished;
				case 4:  return component__init__fail;
				case 5:  return UNKNOWN_VALUE;
				case 6:  return UNBOUND_VALUE;
				default:
					return null;
				}
			}

		}

		public enum_type enum_value;
		//===Constructors===;
		public ExecutorComponent_reason() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public ExecutorComponent_reason(final ExecutorComponent_reason otherValue) {
			enum_value = otherValue.enum_value;
		}

		public ExecutorComponent_reason(final ExecutorComponent_reason.enum_type otherValue ) {
			enum_value = otherValue;
		}

		public ExecutorComponent_reason(final int otherValue) {
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorComponent_reason' with invalid numeric value {1} .", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
		}

		//===Methods===;
		//originally operator=
		public ExecutorComponent_reason assign(final ExecutorComponent_reason otherValue){
			otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				this.enum_value = otherValue.enum_value;
			}

			return this;
		}

		@Override
		public ExecutorComponent_reason assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorComponent_reason ) {
				return assign((ExecutorComponent_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
		}

		//originally operator=
		public ExecutorComponent_reason assign(final ExecutorComponent_reason.enum_type otherValue){
			return assign( new ExecutorComponent_reason(otherValue) );
		}

		//originally operator=
		public ExecutorComponent_reason assign(final int otherValue){
			if (!isValidEnum(otherValue)) {
				throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorComponent_reason'.", otherValue));
			}

			enum_value =  enum_type.getValue(otherValue);
			return this;
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorComponent_reason otherValue){
			return enum_value == otherValue.enum_value;
		}

		//originally operator==
		public boolean operatorEquals(final Base_Type otherValue){
			if (otherValue instanceof ExecutorComponent_reason) {
				return operatorEquals( (ExecutorComponent_reason) otherValue);
			} else {
				throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.reason.");
			}
		}

		//originally operator==
		public boolean operatorEquals(final ExecutorComponent_reason.enum_type otherValue){
			return enum_value == otherValue;
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorComponent_reason otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final Base_Type otherValue){
			return !operatorEquals(otherValue);
		}

		//originally operator!=
		public boolean operatorNotEquals(final ExecutorComponent_reason.enum_type otherValue){
			return !operatorEquals(otherValue);
		}

		// originally operator<
		public boolean isLessThan(final ExecutorComponent_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return enum_value.enum_num < otherValue.enum_num;
		}

		// originally operator<
		public boolean isLessThan(final ExecutorComponent_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return  enum_value.enum_num < otherValue.enum_value.enum_num ;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorComponent_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return enum_value.enum_num <= otherValue.enum_num;
		}

		// originally operator<=
		public boolean isLessThanOrEqual(final ExecutorComponent_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorComponent_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return enum_value.enum_num > otherValue.enum_num;
		}

		// originally operator>
		public boolean isGreaterThan(final ExecutorComponent_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return  enum_value.enum_num > otherValue.enum_value.enum_num ;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorComponent_reason.enum_type otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return enum_value.enum_num >= otherValue.enum_num;
		}

		// originally operator>=
		public boolean isGreaterThanOrEqual(final ExecutorComponent_reason otherValue){
			if (this.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isBound() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void mustBound(final String errorMessage) {
			if ( !isBound() ) {
				throw new TtcnError( errorMessage );
			}
		}

		@Override
		public boolean isValue() {
			return enum_value != enum_type.UNBOUND_VALUE;
		}

		public void cleanUp() {
			enum_value = enum_type.UNBOUND_VALUE;
		}

		public static boolean isValidEnum(final int otherValue) {
			final enum_type helper =  enum_type.getValue(otherValue);
			return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
		}

		public static boolean isValidEnum(final enum_type otherValue) {
			return otherValue != enum_type.UNKNOWN_VALUE && otherValue != enum_type.UNBOUND_VALUE ;
		}

		public void int2enum(final int intValue) {
			if (!isValidEnum(intValue)) {
				throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue);
		}

		public void int2enum(final TitanInteger intValue) {
			if (!isValidEnum(intValue.getInt())) {
				throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
			}
			enum_value = enum_type.getValue(intValue.getInt());
		}

		public static int enum2int(final ExecutorComponent_reason.enum_type enumPar) {
			if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_num;
		}

		public static int enum2int(final ExecutorComponent_reason enumPar) {
			if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
				throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
			}
			return enumPar.enum_value.enum_num;
		}

		public static enum_type str_to_enum(final String strPar) {
			if ("mtc__started".equals(strPar) || "mtc_started".equals(strPar)) {
				return enum_type.mtc__started;
			}
			if ("mtc__finished".equals(strPar) || "mtc_finished".equals(strPar)) {
				return enum_type.mtc__finished;
			}
			if ("ptc__started".equals(strPar) || "ptc_started".equals(strPar)) {
				return enum_type.ptc__started;
			}
			if ("ptc__finished".equals(strPar) || "ptc_finished".equals(strPar)) {
				return enum_type.ptc__finished;
			}
			if ("component__init__fail".equals(strPar) || "component_init_fail".equals(strPar)) {
				return enum_type.component__init__fail;
			}
			return enum_type.UNKNOWN_VALUE;
		}

		public static String enum2str(final enum_type enumPar) {
			return enumPar.name();
		}

		//originally int as_int()
		public int asInt() {
			return enum2int(enum_value);
		}

		public void fromInt(final int otherValue) {
			enum_value = enum_type.getValue(otherValue);
		}

		/** 
		 * Do not use this function!<br>
		 * It is provided by Java and currently used for debugging.
		 * But it is not part of the intentionally provided interface,
		 *   and so can be changed without notice. 
		 * <p>
		 * JAVA DESCRIPTION:
		 * <p>
		 * {@inheritDoc}
		 *  */
		public String toString() {
			return enum_value.name() + "("+enum_value.enum_num+")";
		}

		public void log() {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				TTCN_Logger.log_event_unbound();
			} else {
				TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_VALUE.getValue(), "enumerated value");
			if (param.get_type() != Module_Parameter.type_t.MP_Enumerated) {
				param.type_error("enumerated_value", "@TitanLoggerApi.ExecutorComponent.reason");
			}
			enum_value = str_to_enum(param.get_enumerated());
			if (!isValidEnum(enum_value)) {
				param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorComponent.reason.");
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			if (enum_value == enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
			}
			text_buf.push_int(enum_value.enum_num);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			final int temp = text_buf.pull_int().getInt();
			if (!isValidEnum(temp)) {
				throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorComponent.reason.", temp));
			}
			int2enum(temp);
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

	}
	public static class ExecutorComponent_reason_template extends Base_Template {
		// single_value
		private ExecutorComponent_reason.enum_type single_value;
		// value_list part
		private ArrayList<ExecutorComponent_reason_template> value_list;

		private void copy_template(final ExecutorComponent_reason_template otherValue) {
			set_selection(otherValue);switch (otherValue.templateSelection) {
			case SPECIFIC_VALUE:
				single_value = otherValue.single_value;
				break;
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				value_list = new ArrayList<ExecutorComponent_reason_template>(otherValue.value_list.size());
				for(int i = 0; i < otherValue.value_list.size(); i++) {
					final ExecutorComponent_reason_template temp = new ExecutorComponent_reason_template(otherValue.value_list.get(i));
					value_list.add(temp);
				}
				break;
			default:
				throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorComponent_reason.");
			}
		}

		public ExecutorComponent_reason_template() {
			// do nothing
		}

		public ExecutorComponent_reason_template(final template_sel otherValue) {
			super(otherValue);
			checkSingleSelection(otherValue);
		}

		public ExecutorComponent_reason_template(final int otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (!ExecutorComponent_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Initializing a template of enumerated type ExecutorComponent_reason with unknown numeric value "+ otherValue +".");
			}
			single_value = ExecutorComponent_reason.enum_type.getValue(otherValue);
		}

		public ExecutorComponent_reason_template(final ExecutorComponent_reason otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			if (otherValue.enum_value == ExecutorComponent_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorComponent_reason. ");
			}
			single_value = otherValue.enum_value;
		}

		public ExecutorComponent_reason_template(final ExecutorComponent_reason_template otherValue) {
			copy_template(otherValue);
		}

		public ExecutorComponent_reason_template(final ExecutorComponent_reason.enum_type otherValue) {
			super(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
		}

		public void cleanUp() {
			if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
				value_list.clear();
				value_list = null;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				single_value = null;
			}
			templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
		}

		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			return true;
		}

		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			return single_value != ExecutorComponent_reason.enum_type.UNBOUND_VALUE;
		}

		//originally operator=
		public ExecutorComponent_reason_template assign(final template_sel otherValue) {
			checkSingleSelection(otherValue);
			cleanUp();
			set_selection(otherValue);
			return this;
		}

		//originally operator=
		public ExecutorComponent_reason_template assign(final int otherValue) {
			if (!ExecutorComponent_reason.isValidEnum(otherValue)) {
				throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorComponent_reason.");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			return this;
		}

		//originally operator=
		public ExecutorComponent_reason_template assign(final ExecutorComponent_reason.enum_type otherValue){
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue;
			return this;
		}

		//originally operator=
		public ExecutorComponent_reason_template assign(final ExecutorComponent_reason_template otherValue){
			// otherValue.mustBound("Assignment of an unbound enumerated value");

			if (otherValue != this) {
				cleanUp();
				copy_template(otherValue);
			}
			return this;
		}

		//originally operator=
		public ExecutorComponent_reason_template assign(final ExecutorComponent_reason otherValue){
			if (otherValue.enum_value == ExecutorComponent_reason.enum_type.UNBOUND_VALUE) {
				throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorComponent_reason to a template. ");
			}
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			single_value = otherValue.enum_value;
			return this;
		}

		@Override
		public ExecutorComponent_reason_template assign(final Base_Type otherValue){
			if( otherValue instanceof ExecutorComponent_reason ) {
				return assign((ExecutorComponent_reason) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorComponent_reason_template assign(final Base_Template otherValue){
			if( otherValue instanceof ExecutorComponent_reason_template ) {
				return assign((ExecutorComponent_reason_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason'_template can not be cast to {1}", otherValue));
		}

		// originally match
		public boolean match(final ExecutorComponent_reason.enum_type otherValue) {
			return match(otherValue, false);
		}

		// originally match
		public boolean match(final ExecutorComponent_reason.enum_type otherValue, final boolean legacy) {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				return single_value == otherValue;
			case OMIT_VALUE:
				return false;
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for(int i = 0 ; i < value_list.size(); i++) {
					if(value_list.get(i).match(otherValue)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorComponent_reason.");
			}
		}

		// originally match
		public boolean match(final ExecutorComponent_reason otherValue) {
			return match(otherValue.enum_value, false);
		}

		// originally match
		public boolean match(final ExecutorComponent_reason otherValue, final boolean legacy) {
			return match(otherValue.enum_value, false);
		}

		@Override
		public boolean match(final Base_Type otherValue, final boolean legacy){
			if( otherValue instanceof ExecutorComponent_reason ) {
				return match((ExecutorComponent_reason) otherValue, legacy);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
		}

		public ExecutorComponent_reason valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorComponent_reason.");
			}
			return new ExecutorComponent_reason(single_value);
		}

		public void setType(final template_sel templateType, final int list_length) {
			if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorComponent_reason.");
			}
			cleanUp();
			set_selection(templateType);
			value_list = new ArrayList<ExecutorComponent_reason_template>();
			for(int i = 0 ; i < list_length; i++) {
				value_list.add(new ExecutorComponent_reason_template());
			}
		}

		public ExecutorComponent_reason_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorComponent_reason.");
			}
			if (list_index < 0) {
				throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorComponent_reason.");
			}
			if(list_index >= value_list.size()) {
				throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorComponent_reason.");
			}
			return value_list.get(list_index);
		}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int i = 0 ; i < value_list.size(); i++) {
						if (value_list.get(i).match_omit()) {
							return templateSelection == template_sel.VALUE_LIST;
						}
					}
					return templateSelection == template_sel.COMPLEMENTED_LIST;
				}
			default:
				return false;
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_event_enum(ExecutorComponent_reason.enum2str(single_value), ExecutorComponent_reason.enum2int(single_value));
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < value_list.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					value_list.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}
		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorComponent_reason) {
				log_match((ExecutorComponent_reason)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.reason.");
		}
		public void log_match(final ExecutorComponent_reason match_value, final boolean legacy){
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if (match(match_value, legacy)) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}

		@Override
		public void set_param(final Module_Parameter param) {
			param.basic_check(Module_Parameter.basic_check_bits_t.BC_TEMPLATE.getValue(), "enumerated template");
			switch (param.get_type()) {
			case MP_Omit:
				assign(template_sel.OMIT_VALUE);
				break;
			case MP_Any:
				assign(template_sel.ANY_VALUE);
				break;
			case MP_AnyOrNone:
				assign(template_sel.ANY_OR_OMIT);
				break;
			case MP_List_Template:
			case MP_ComplementList_Template: {
				final int size = param.get_size();
				setType(param.get_type() == Module_Parameter.type_t.MP_List_Template ? template_sel.VALUE_LIST : template_sel.COMPLEMENTED_LIST, size);
				for (int i = 0; i < size; i++) {
					listItem(i).set_param(param.get_elem(i));
				}
				break;
			}
			case MP_Enumerated: {
				final ExecutorComponent_reason.enum_type enum_value = ExecutorComponent_reason.str_to_enum(param.get_enumerated());
				if (!ExecutorComponent_reason.isValidEnum(enum_value)) {
					param.error("Invalid enumerated value for type @TitanLoggerApi.ExecutorComponent.reason.");
				}
				assign(enum_value);
				break;
			}
			default:
				param.type_error("enumerated template", "@TitanLoggerApi.ExecutorComponent.reason");
			}
			is_ifPresent = param.get_ifpresent();
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(single_value.getInt());
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(value_list.size());
				for (int i = 0; i < value_list.size(); i++) {
					value_list.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:{
				final int temp = text_buf.pull_int().getInt();
				if (!ExecutorComponent_reason.isValidEnum(temp)) {
					throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorComponent.reason.", temp));
				}
				single_value = ExecutorComponent_reason.enum_type.values()[temp];
				break;
			}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				value_list = new ArrayList<ExecutorComponent_reason_template>(size);
				for (int i = 0; i < size; i++) {
					final ExecutorComponent_reason_template temp = new ExecutorComponent_reason_template();
					temp.decode_text(text_buf);
					value_list.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
			}
		}

		@Override
		public void check_restriction(final template_res restriction, final String name, final boolean legacy) {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
				return;
			}
			switch ((name != null && restriction == template_res.TR_VALUE) ? template_res.TR_OMIT : restriction) {
			case TR_VALUE:
				if (!is_ifPresent && templateSelection == template_sel.SPECIFIC_VALUE) {
					return;
				}
				break;
			case TR_OMIT:
				if (!is_ifPresent && (templateSelection == template_sel.OMIT_VALUE || templateSelection == template_sel.SPECIFIC_VALUE)) {
					return;
				}
				break;
			case TR_PRESENT:
				if (!match_omit(legacy)) {
					return;
				}
				break;
			default:
				return;
			}
			throw new TtcnError(MessageFormat.format("Restriction `{0}'' on template of type {1} violated.", getResName(restriction), name == null ? "@TitanLoggerApi.ExecutorComponent.reason" : name));
		}
	}
	public static void ExecutorComponent_reason_encoder(final ExecutorComponent_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
		input_value.encode(ExecutorComponent_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		ttcnBuffer.get_string(output_stream);
	}

	public static TitanInteger ExecutorComponent_reason_decoder( final TitanOctetString input_stream, final ExecutorComponent_reason output_value, final TitanUniversalCharString coding_name) {
		final AtomicInteger extra_options = new AtomicInteger(0);
		final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
		if (codingType != TTCN_EncDec.coding_type.CT_XER) {
			TTCN_Logger.begin_event_log2str();
			coding_name.log();
			throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
		}
		final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
		output_value.decode(ExecutorComponent_reason_descr_, ttcnBuffer, codingType, extra_options.get());
		switch (TTCN_EncDec.get_last_error_type()) {
		case ET_NONE:
			ttcnBuffer.cut();
			ttcnBuffer.get_string(input_stream);
			return new TitanInteger(0);
		case ET_INCOMPL_MSG:
		case ET_LEN_ERR:
			return new TitanInteger(2);
		default:
			return new TitanInteger(1);
		}
	}

	public void pre_init_module()
	{
		if (pre_init_called) {
			return;
		}
		pre_init_called = true;
		final TTCN_Location current_location = TTCN_Location.enter("TitanLoggerApi.ttcn", 0, entity_type_t.LOCATION_UNKNOWN, "TitanLoggerApi");
		TitanLogEvent_sourceInfo__list_descr_.oftype_descr = TitanLogEvent_sourceInfo__list_0_descr_;
		Strings_str__list_descr_.oftype_descr = Strings_str__list_0_descr_;
		TitanLog_sequence__list_0_event__list_descr_.oftype_descr = TitanLog_sequence__list_0_event__list_0_descr_;
		TitanLog_sequence__list_descr_.oftype_descr = TitanLog_sequence__list_0_descr_;
		StartFunction_parameter__list_descr_.oftype_descr = StartFunction_parameter__list_0_descr_;
		current_location.leave();
	}

}
